[{"categories":["Golang"],"content":"1 背景知识 ","date":"2021-01-14","objectID":"/posts/language/golang/go-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%80%BB%E7%BB%93/:1:0","tags":["Golang","Golang 原理"],"title":"Go 垃圾收集总结","uri":"/posts/language/golang/go-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%80%BB%E7%BB%93/"},{"categories":["Golang"],"content":"1.1 术语 垃圾回收算法有一些基本的术语，首先需要知道对应的含义： Mutator：具有“改变对象”的意思，GC 中就是改动对象间引用关系的意思，也就是程序； 堆：对象使用的内存空间，GC 就是将垃圾对象空间放回到堆中； 根对象：对象的指针的“起点”部分，一般就是全局对象和栈对象； ","date":"2021-01-14","objectID":"/posts/language/golang/go-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%80%BB%E7%BB%93/:1:1","tags":["Golang","Golang 原理"],"title":"Go 垃圾收集总结","uri":"/posts/language/golang/go-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%80%BB%E7%BB%93/"},{"categories":["Golang"],"content":"1.2 三色标记算法 三色标记算法是 GC 标记清除算法Mark-Sweep 的一种，也是 Golang 中使用的算法。 Note 推荐阅读： 首先，三色标记算法的最基本逻辑为： 标记的最开始，所有对象默认为白色； 将 根对象标记为灰色，放入灰色集合； 从灰色集合中取出灰色对象，将其子对象标记为灰色，加入灰色集合，该灰色对象标记为黑色； 重复第 3 步，直到灰色集合为空； 清理所有的白色对象； 整个逻辑很简单，就是一个树的层次遍历，将所有可达的结点标记，然后清理未标记的不可达结点。 但是，仅仅是普通的三色标记算法要求执行时，Mutator 不能同时运行。因为如果 Mutator 并行时，某个扫描过的结点的引用关系变化，就可能导致悬挂指针dangling pointer问题。 例如，上图中第 3 步将 A 指向 D，那么 D 还是无法被标记，被错误回收。 而想要让 Mutator 同时运行时，标记的结果还保持正确，那么每个时刻标记的结果要满足三色不变性Tri-color invariant 强三色不变性：黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象。 因为黑色对象不会再被扫描，如果黑色对象指向白色对象，那么肯定该白色对象会被错误回收。 当然，除非这种情况能够满足弱三色不变性。 弱三色不变性：黑色对象执行白色对象，那么必须包含一条灰色对象经由多个白色对象的可达路径。 因为有了后面这个可达路径，也就是说白色对象还是可以被标记的，那么黑色对象可以指向该白色对象。 ","date":"2021-01-14","objectID":"/posts/language/golang/go-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%80%BB%E7%BB%93/:1:2","tags":["Golang","Golang 原理"],"title":"Go 垃圾收集总结","uri":"/posts/language/golang/go-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%80%BB%E7%BB%93/"},{"categories":["Golang"],"content":"1.3 屏障技术 为了满足两个不变性，所以要在对象引用变更时，做出一些操作改变对象标记。这就是 GC 里 屏障技术barrier 的作用。 Go 中使用了写屏障，即在用户程序更新对象指针时，执行一些代码，使得继续满足不变性。 Note 这里的屏障技术似乎和我知道的 CPU 的屏障技术含义不太类似，更像是回调函数，也挺困惑 ","date":"2021-01-14","objectID":"/posts/language/golang/go-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%80%BB%E7%BB%93/:1:3","tags":["Golang","Golang 原理"],"title":"Go 垃圾收集总结","uri":"/posts/language/golang/go-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%80%BB%E7%BB%93/"},{"categories":["Golang"],"content":"1.3.1 插入写屏障 Dijkstra 提出的 插入写屏障，在更新对象指针时，将其被指向的对象重新加入扫描集合（三色标记中也就是变为灰色），这样接下来还是能够被扫描。 可以看到，这样黑色对象始终指向的是灰色对象，永远都会满足强三色不变性。 但是，Dijkstra 也有一些缺点： 对象指针变动时，没有考虑旧的指针引用。例如 *field 原来的对象 oldobj 已经扫描成黑色了，那么 *field = newobj 变动后，可能 oldobj 变为垃圾对象，只有等到下一轮标记时才会被回收。 TODO ","date":"2021-01-14","objectID":"/posts/language/golang/go-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%80%BB%E7%BB%93/:1:4","tags":["Golang","Golang 原理"],"title":"Go 垃圾收集总结","uri":"/posts/language/golang/go-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%80%BB%E7%BB%93/"},{"categories":["Golang"],"content":"1.3.2 删除写屏障 Yuasa 提出的 删除写屏障，让老对象的引用被删除时，将白色的老对象涂成灰色，这样删除写屏障就可以保证弱三色不变性。 ","date":"2021-01-14","objectID":"/posts/language/golang/go-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%80%BB%E7%BB%93/:1:5","tags":["Golang","Golang 原理"],"title":"Go 垃圾收集总结","uri":"/posts/language/golang/go-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%80%BB%E7%BB%93/"},{"categories":["Golang"],"content":"1.3.3 Go 中的屏障 Go 中使用 混合写屏障，即插入写屏障与删除写屏障都开启，并且在标记阶段开始后，将创建的所有新对象都标记为黑色，防止新分配的对象被错误的回收。 具体操作为： GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW)， GC期间，任何在栈上创建的新对象，均为黑色。 被删除的对象标记为灰色。 被添加的对象标记为灰色。 ","date":"2021-01-14","objectID":"/posts/language/golang/go-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%80%BB%E7%BB%93/:1:6","tags":["Golang","Golang 原理"],"title":"Go 垃圾收集总结","uri":"/posts/language/golang/go-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%80%BB%E7%BB%93/"},{"categories":["Golang"],"content":"Go 中的三色标记算法 我们先不看整个的流程实现，而是从核心的标记算法入手。 ","date":"2021-01-14","objectID":"/posts/language/golang/go-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%80%BB%E7%BB%93/:2:0","tags":["Golang","Golang 原理"],"title":"Go 垃圾收集总结","uri":"/posts/language/golang/go-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%80%BB%E7%BB%93/"},{"categories":["Golang"],"content":"2.1 标记 2.1.1 并发标记框架 runtime 使用并发的标记方式，多个 groutine 同时执行一部分内存的标记操作。其整个就是基于一个工作池框架。 首先，有着一个全局的工作队列，其放在 work 全局变量中： var work struct { full lfstack // lock-free list of full blocks workbuf empty lfstack // lock-free list of empty blocks workbuf } full：全局的非空的队列组成的链表，单个 groutine 没有任务时就从这里取一个队列使用； empty：全局的空的队列组成的链表，单个 groutine 的工作队列满时就会这里去一个队列切换； 每个 goroutine 有着独立对应的 gcWork 对象，其类似一个队列，从队列中取出需要扫描的内存的地址。 type workbuf struct { workbufhdr obj [(_WorkbufSize - unsafe.Sizeof(workbufhdr{})) / sys.PtrSize]uintptr } type gcWork struct { // wbuf1 and wbuf2 are the primary and secondary work buffers.  //  // This can be thought of as a stack of both work buffers'  // pointers concatenated. When we pop the last pointer, we  // shift the stack up by one work buffer by bringing in a new  // full buffer and discarding an empty one. When we fill both  // buffers, we shift the stack down by one work buffer by  // bringing in a new empty buffer and discarding a full one.  // This way we have one buffer's worth of hysteresis, which  // amortizes the cost of getting or putting a work buffer over  // at least one buffer of work and reduces contention on the  // global work lists.  //  // wbuf1 is always the buffer we're currently pushing to and  // popping from and wbuf2 is the buffer that will be discarded  // next.  //  // Invariant: Both wbuf1 and wbuf2 are nil or neither are.  wbuf1, wbuf2 *workbuf … } wbuf1 与 wbuf2: 就是主队列与备队列。所有操作都会先操作 wbuf1，如果 wbuf1 空间不足或者没有对象，就会触发 wbuf1 与 wbuf2 切换。当两个缓冲区都空间不足或者满时，就会从 work.free 或者 work.list 得到一个空闲的，并赋值 wbuf1。 gcWork 有几个重要的方法： gcWork.tryGetFast() ：从 wbuf1 快速得到一个 obj 的地址； gcWork.tryGet() ：从 wbuf1 -\u003e wbuf2 -\u003e work.full 获取一个 obj； gcWork.putFast() ：将一个待扫描的 obj 放入 wbuf1； gcWork.put() ：将一个待扫描的 obj 放入 wbuf1 -\u003e wbuf2 -\u003e work.empty； gcWork.balance() ：将 wbuf2/wbuf1 放入 work.full 中； gcWork.empty() ：判断是否 gcWork 为空，为空表明没有会灰色 obj； 可以看到，整个过程就是围绕了各个工作队列的生产-消费过程。先从根对象开始，goroutine 从 gcWork 取出待扫描的 obj，将其标记，然后将 obj 指向的子 obj 再次放入 gcWork。不断循环，直到 gcWork 为空。 2.1.2 groutine 标记流程 下面看下核心的标记流程，这里我们仅仅关注一个 groutine 的工作。大致的标记步骤如下： 将根对象放入 gcWork； groutine 从 gcWork 取出一个 object 地址，将其标记； 将 object 包含的指针指向的 object 再次放入 gcWork； 重复 2-3 步，直到 gcWork 为空； 而对应于三色标记，我们可以确认不同颜色的对象在 runtime 中的对应： 灰色对象 -\u003e gcWork 中的 object； 黑色对象 -\u003e 不在 gcWork 中，但是被 mark 的 object； 白色对象 -\u003e 不在 gcWork 中，没有被 mark 的 object； 每个 P 会对应一个标记使用的 groutine，执行 gcDrain() 函数（runtime/mgcmark.go）： // gcDrain scans roots and objects in work buffers, blackening grey // objects until it is unable to get more work. It may return before // GC is done; it's the caller's responsibility to balance work from // other Ps. // // If flags\u0026gcDrainUntilPreempt != 0, gcDrain returns when g.preempt // is set. // // If flags\u0026gcDrainIdle != 0, gcDrain returns when there is other work // to do. // // If flags\u0026gcDrainFractional != 0, gcDrain self-preempts when // pollFractionalWorkerExit() returns true. This implies // gcDrainNoBlock. // // If flags\u0026gcDrainFlushBgCredit != 0, gcDrain flushes scan work // credit to gcController.bgScanCredit every gcCreditSlack units of // scan work. // // gcDrain will always return if there is a pending STW. // //go:nowritebarrier func gcDrain(gcw *gcWork, flags gcDrainFlags) { gp := getg().m.curg preemptible := flags\u0026gcDrainUntilPreempt != 0 flushBgCredit := flags\u0026gcDrainFlushBgCredit != 0 idle := flags\u0026gcDrainIdle != 0 initScanWork := gcw.scanWork // 配置退出标记的 check 函数，根据不同策略退出标记  checkWork := int64(1\u003c\u003c63 - 1) var check func() bool if flags\u0026(gcDrainIdle|gcDrainFractional) != 0 { checkWork = initScanWork + drainCheckThreshold if idle { check = pollWork } else if flags\u0026gcDrainFractional != 0 { check = pollFractionalWorkerExit } } // 扫描根对象放入 gcWork  if work.markrootNext \u003c work.markrootJobs { // Stop if we're preemptible or if someone wants to STW.  for !(gp.preempt \u0026\u0026 (preemptible || atomic.Load(\u0026sched.gcwaiting) != 0)) { job := atomic.Xadd(\u0026work.markrootNext, +1) - 1 if job \u003e= work.markrootJobs { break } markroot(gcw, job) if check != nil \u0026\u0026 check() { goto done } } } // 标记循环  for !(gp.preem","date":"2021-01-14","objectID":"/posts/language/golang/go-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%80%BB%E7%BB%93/:2:1","tags":["Golang","Golang 原理"],"title":"Go 垃圾收集总结","uri":"/posts/language/golang/go-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%80%BB%E7%BB%93/"},{"categories":["Golang"],"content":"2.2 写屏障 在各个代码的注释中，可以看到 “//go:nowritebarrier”。显然，这样让编译器编译时不加入写屏障的意思，因此可以想到，默认的函数执行都会加入写屏障的逻辑。 在 SSA 中间代码生成阶段，编译器会在 Store、Move、Zero 操作中加入写屏障，写屏障函数为 writebarrier() 函数（cmd/compile/internal/ssa/writebarrier.go）。 writebarrier() 函数很复杂，这里不展开。再次看一下混合写屏障操作： GC 开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW)。 GC 期间，任何在栈上创建的新对象，均为黑色。 被删除的对象标记为灰色。 被添加的对象标记为灰色。 当开始 GC 时，全局变量 runtime.writeBarrier.enabled 变为 true，所有的写操作都会经过 writebarrier() 的操作。 ","date":"2021-01-14","objectID":"/posts/language/golang/go-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%80%BB%E7%BB%93/:2:2","tags":["Golang","Golang 原理"],"title":"Go 垃圾收集总结","uri":"/posts/language/golang/go-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%80%BB%E7%BB%93/"},{"categories":["Golang"],"content":"本文是对 Golang 内存模型与内存管理的一个总结，基本内容来源于网络的学习，以及自己观摩了下源码。 所以学习的书籍与文章见 参考。 下面代码都是基于 go 1.15.6。 ","date":"2021-01-05","objectID":"/posts/language/golang/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/:0:0","tags":["Golang","Golang 原理"],"title":"Go 内存管理总结","uri":"/posts/language/golang/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/"},{"categories":["Golang"],"content":"1 Linux 内存模型 所有语言的内存管理，在 Linux 上都是在以基本的进程内存模型基础上实现的，首先需要知道 Linux 进程内存布局。 在进程角度，看到的所有内存就是 虚拟地址空间virtual address space ，整个是一个线性的存储地址。其中一部分高地址区域用户态无法访问，是内核地址空间。而另一部分就是由栈、mmap、堆等内存区域组成的用户地址空间。 上面进程可以自己分配与管理的进程，就是 mmap 与 堆，对应的系统调用为 mmap() 与 brk()，因此所有语言的内存管理都是基于这两个内存区域在进一步实现的（包括 glibc 的 malloc() 与 free()）。 mmap 最基本有两个用途： 文件映射 ：申请一块内存区域，映射到文件系统上一个文件（这也是 page_cache 的基本原理，所以他们在内核中都使用 address_space 实现） 匿名映射 ：申请一块内存区域，但是没有映射到具体文件，相当于分配了一块内存区域（可以用于父子进程共享、或者自己管理内存的分配等功能） 而所有在内存上所说的地址，包括代码指令地址、变量地址都是上面地址空间的一个地址。 ","date":"2021-01-05","objectID":"/posts/language/golang/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/:1:0","tags":["Golang","Golang 原理"],"title":"Go 内存管理总结","uri":"/posts/language/golang/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/"},{"categories":["Golang"],"content":"2 PC 与 SP Goroutine 将进程的切换变为了协程间的切换，那么就需要在用户空间负责执行代码与协程上下文的保留与切换。因此，有两个关键的寄存器：PC 与 SP。 ","date":"2021-01-05","objectID":"/posts/language/golang/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/:2:0","tags":["Golang","Golang 原理"],"title":"Go 内存管理总结","uri":"/posts/language/golang/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/"},{"categories":["Golang"],"content":"2.1 PC 程序计数器 PCProgram Counter 是 CPU 中的一个寄存器，保存着下一个 CPU 执行的指令的位置。顺序执行指令时，PC = PC + 1（一个指令）。而调用函数或者条件跳转时，会将跳到的指令地址设置到 PC 中。 所以，可以想到，当需要切换执行的 goroutine，调用 JMP 指令跳转到 G 对应的代码。 ","date":"2021-01-05","objectID":"/posts/language/golang/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/:2:1","tags":["Golang","Golang 原理"],"title":"Go 内存管理总结","uri":"/posts/language/golang/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/"},{"categories":["Golang"],"content":"2.2 SP 栈顶指针 SPstack pointer 是保存栈顶地址的寄存器，我们平时所说的临时变量在栈上，就是将临时变量的值写入 SP 保存的内存地址，然后 SP 保存的地址减小（栈是从高地址向低地址变化），然后临时变量销毁时，SP 地址又变为高地址。 不过，因为 goroutine 切换时，必须要保存当前 goroutine 的上下文，也就是栈里的变量。因此，goroutine 栈肯定是不能使用 Linux 进程栈了（因为进程栈有上限，也无法实现“保存”这种功能）。所以所说的协程栈，都是基于 mmap 申请内存空间（基于 Go 内存管理，内存管理基于 mmap），然后切换时修改 SP 寄存器地址实现的。 这也是为什么 goroutine 栈可以“无限大”的原因了。 ","date":"2021-01-05","objectID":"/posts/language/golang/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/:2:2","tags":["Golang","Golang 原理"],"title":"Go 内存管理总结","uri":"/posts/language/golang/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/"},{"categories":["Golang"],"content":"3 Goroutine 栈 整体的一个 G 的栈如下图所示： stack.lo： G 栈的最大低地址（也就是上限）； stack.hi：G 栈的初始地址； stackguard0：阈值地址，用于判断 G 栈是否需要扩容； StackGuard：常量，栈的保护区，也就是预留的地址； StackSmall：常量，用于小函数调用的优化； 先看一下 g 的实现中包含的 stack 属性（runtime/runtime2.go），其实注释写的就很明白了： type g struct { // Stack parameters. // stack describes the actual stack memory: [stack.lo, stack.hi). // stackguard0 is the stack pointer compared in the Go stack growth prologue. // It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption. // stackguard1 is the stack pointer compared in the C stack growth prologue. // It is stack.lo+StackGuard on g0 and gsignal stacks. // It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash). stack stack // offset known to runtime/cgo stackguard0 uintptr // offset known to liblink stackguard1 uintptr // offset known to liblink // ... } stack 属性就是 G 对应的栈了（这也表明了不是使用的进程栈）； Note stack 与 stackguard0 属性一定要在 g 结构的开头，因为汇编中会使用指定的偏移(0x10)来获取对应的值; 具体看一下 stack 结构（runtime/runtime2.go）： // Stack describes a Go execution stack. // The bounds of the stack are exactly [lo, hi), // with no implicit data structures on either side. type stack struct { lo uintptr hi uintptr } ","date":"2021-01-05","objectID":"/posts/language/golang/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/:3:0","tags":["Golang","Golang 原理"],"title":"Go 内存管理总结","uri":"/posts/language/golang/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/"},{"categories":["Golang"],"content":"3.1 新 G 的栈 在 malg 函数中，可以看到对于新 G 的栈的分配（一开始为 2KB）： // Allocate a new g, with a stack big enough for stacksize bytes. func malg(stacksize int32) *g { newg := new(g) if stacksize \u003e= 0 { stacksize = round2(_StackSystem + stacksize) // 在公共的 goroutine(g0) 上调用函数 systemstack(func() { // 分配一个 stack newg.stack = stackalloc(uint32(stacksize)) }) // 设置 stackguard0 地址 newg.stackguard0 = newg.stack.lo + _StackGuard newg.stackguard1 = ^uintptr(0) // Clear the bottom word of the stack. We record g // there on gsignal stack during VDSO on ARM and ARM64. *(*uintptr)(unsafe.Pointer(newg.stack.lo)) = 0 } return newg } Note 注意 systemstack()，用于将当前栈切换到 M 的 g0 协程栈上执行命令。 Why? 因为 G 用于执行用户逻辑，而某些管理操作不方便在 G 栈上执行（例如 G 可能中途停止，垃圾回收时 G 栈空间也有可能被回收），所以需要执行管理命令时，都会通过 systemstack 方法将线程栈切换为 g0 的栈执行，与用户逻辑隔离。 ","date":"2021-01-05","objectID":"/posts/language/golang/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/:3:1","tags":["Golang","Golang 原理"],"title":"Go 内存管理总结","uri":"/posts/language/golang/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/"},{"categories":["Golang"],"content":"3.2 栈的分配 stackalloc() 函数用于分配一个栈，无论是给新 G 还是扩容栈时都会用到，因此栈空间的分配与回收是一个比较频繁的操作，所以栈空间采取了缓存复用的方式。 主要逻辑如下： 如果分配的栈空间不大，就走缓存复用这种方式分配。没有可以复用的就创建； 如果分配的栈空间很大（大于 32KB），就直接从 heap 分配； 这里主要关注第 1 中方式，会调用 stackpoolalloc() 函数。 // Allocates a stack from the free pool. Must be called with // stackpool[order].item.mu held. func stackpoolalloc(order uint8) gclinkptr { list := \u0026stackpool[order].item.span s := list.first // ... if s == nil { // 没有可以复用的栈，走内存管理创建 s = mheap_.allocManual(_StackCacheSize\u003e\u003e_PageShift, \u0026memstats.stacks_inuse) // ... } x := s.manualFreeList if x.ptr() == nil { throw(\"span has no free stacks\") } s.manualFreeList = x.ptr().next // ... return x } 可以看到，首先尝试从 stackpool 缓存的空闲的 stack 获取，如果没有则走 Go 内存管理申请一个。 再接下来就是 Go 内存管理模块负责的事了，不深入下去（后面再说）。底层创建都是使用 mmap 系统调用实现的，这里可以看下使用的参数： // Don't split the stack as this method may be invoked without a valid G, which // prevents us from allocating more stack. //go:nosplit func sysAlloc(n uintptr, sysStat *uint64) unsafe.Pointer { p, err := mmap(nil, n, _PROT_READ|_PROT_WRITE, _MAP_ANON|_MAP_PRIVATE, -1, 0) if err != 0 { if err == _EACCES { print(\"runtime: mmap: access denied\\n\") exit(2) } if err == _EAGAIN { print(\"runtime: mmap: too much locked memory (check 'ulimit -l').\\n\") exit(2) } return nil } mSysStatInc(sysStat, n) return p } 通过 mmap 调用的参数可以看到，申请了一个系统分配的匿名内存映射。 ","date":"2021-01-05","objectID":"/posts/language/golang/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/:3:2","tags":["Golang","Golang 原理"],"title":"Go 内存管理总结","uri":"/posts/language/golang/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/"},{"categories":["Golang"],"content":"3.3 栈的扩容 3.3.1 扩容判断 Go 编译器会在执行函数前，插入一些汇编指令，其中一个功能就是检查 G 栈是否需要扩容。看一个函数调用的实现： // main() 调用 test() $ go build -gcflags \"-l\" -o test main.go $ go tool objump -s \"main\\.test\" test TEXT main.test(SB) /root/yusihao/onething/BizImages/main.go main.go:3 0x45dc80 MOVQ FS:0xfffffff8, CX // CX 为当前 G 地址 main.go:3 0x45dc89 CMPQ 0x10(CX), SP // CX+0x10 执行 g.stackguard0 属性，与 SP 指针地址比较 main.go:3 0x45dc8d JBE 0x45dccf // 如果 SP \u003c=stackguard0 跳转到 0x45dccf，也就是调用 runtime.morestack_noctxt(SB) 函数 main.go:3 0x45dc8f SUBQ $0x18, SP // ... main.go:5 0x45dcce RET // 函数执行结束，RET 返回，不会执行后面两个指令 main.go:3 0x45dccf CALL runtime.morestack_noctxt(SB) // 执行栈扩容 main.go:3 0x45dcd4 MP main.test(SB) // 执行结束后，重新执行当前函数 逻辑很简单，如果 SP \u003c= stackguard0，那么就执行栈的扩容，扩容结束重新执行当前函数。 Note 上面比较 SP 时候，没有考虑当前函数调用使用的空间大小。Why? 因为测试程序这个函数中使用的空间比较小，而 stackguard0 与 stack.lo 有一段保护区，所以编译器允许这里 “溢出” 一些，所以这里就没有让 SP 考虑函数使用空间。 如果函数中使用的空间大过保护区时，比较时就会让 SP 减去当前函数使用空间再比较了。 3.3.2 扩容 扩容逻辑大致分为三步： 分配一个 2x 新栈； 拷贝当前栈数据至新栈； “释放\"掉旧栈； 从上面扩容判断可以看到，会调用 morestack 的汇编代码： // Called during function prolog when more stack is needed. // R3 prolog's LR // using NOFRAME means do not save LR on stack. // // The traceback routines see morestack on a g0 as being // the top of a stack (for example, morestack calling newstack // calling the scheduler calling newm calling gc), so we must // record an argument size. For that purpose, it has no arguments. TEXT runtime·morestack(SB),NOSPLIT|NOFRAME,$0-0 // Cannot grow scheduler stack (m-\u003eg0). MOVW g_m(g), R8 MOVW m_g0(R8), R4 CMP g, R4 BNE 3(PC) BL runtime·badmorestackg0(SB) B runtime·abort(SB) // Cannot grow signal stack (m-\u003egsignal). MOVW m_gsignal(R8), R4 CMP g, R4 BNE 3(PC) BL runtime·badmorestackgsignal(SB) B runtime·abort(SB) // Called from f. // Set g-\u003esched to context in f. MOVW R13, (g_sched+gobuf_sp)(g) MOVW LR, (g_sched+gobuf_pc)(g) MOVW R3, (g_sched+gobuf_lr)(g) MOVW R7, (g_sched+gobuf_ctxt)(g) // Called from f. // Set m-\u003emorebuf to f's caller. MOVW R3, (m_morebuf+gobuf_pc)(R8) // f's caller's PC MOVW R13, (m_morebuf+gobuf_sp)(R8) // f's caller's SP MOVW g, (m_morebuf+gobuf_g)(R8) // Call newstack on m-\u003eg0's stack. MOVW m_g0(R8), R0 BL setg\u003c\u003e(SB) MOVW (g_sched+gobuf_sp)(g), R13 MOVW $0, R0 MOVW.W R0, -4(R13) // create a call frame on g0 (saved LR) BL runtime·newstack(SB) // Not reached, but make sure the return PC from the call to newstack // is still in this function, and not the beginning of the next. RET TEXT runtime·morestack_noctxt(SB),NOSPLIT|NOFRAME,$0-0 MOVW $0, R7 B runtime·morestack(SB) 可以看到 g0，gsignal 的栈都不会扩容 在 g0 栈上会调用 newstack() 函数 调用的 newstack() 函数（runtime/stack.go），过程很复杂，只看一下关键点： // Called from runtime·morestack when more stack is needed. // Allocate larger stack and relocate to new stack. // Stack growth is multiplicative, for constant amortized cost. // // g-\u003eatomicstatus will be Grunning or Gscanrunning upon entry. // If the scheduler is trying to stop this g, then it will set preemptStop. // // This must be nowritebarrierrec because it can be called as part of // stack growth from other nowritebarrierrec functions, but the // compiler doesn't check this. // //go:nowritebarrierrec func newstack() { thisg := getg() gp := thisg.m.curg // ... // 新栈大小为当前两倍 oldsize := gp.stack.hi - gp.stack.lo newsize := oldsize * 2 // ... // 改变 G 状态为 copy stack，gc 会跳过该状态的 G casgstatus(gp, _Grunning, _Gcopystack) // 分配新栈，拷贝数据，释放旧站 // The concurrent GC will not scan the stack while we are doing the copy since // the gp is in a Gcopystack status. copystack(gp, newsize) if stackDebug \u003e= 1 { print(\"stack grow done\\n\") } casgstatus(gp, _Gcopystack, _Grunning) // 执行 G 代码 gogo(\u0026gp.sched) } // Copies gp's stack to a new stack of a different size. // Caller must have changed gp status to Gcopystack. func copystack(gp *g, newsize uintptr) { // 创建新 stack new := stackalloc(uint32(newsize)) // ... // 拷贝数据 memmove(unsafe.Pointer(new.hi-ncopy), unsafe.Pointer(old.hi-ncopy), ncopy) // ... gp.stack = new gp.stackguard0 = new.lo + _StackGuard // 释放旧 stack if stackPoisonCopy != 0 { fillstac","date":"2021-01-05","objectID":"/posts/language/golang/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/:3:3","tags":["Golang","Golang 原理"],"title":"Go 内存管理总结","uri":"/posts/language/golang/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/"},{"categories":["Golang"],"content":"3.4 栈的释放 stackfree 栈的释放与申请相反，放入 stackpool，或者直接调用内存管理删除，重点还是内存管理的活，所以这里不展开。 ","date":"2021-01-05","objectID":"/posts/language/golang/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/:3:4","tags":["Golang","Golang 原理"],"title":"Go 内存管理总结","uri":"/posts/language/golang/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/"},{"categories":["Golang"],"content":"3.5 栈的切换 切换应该是属于 goroutine 调度的内容，不过这里可以关注一下栈时如何切换的。 当 M 执行的 G 需要切换，或者一个新创建 G 执行时，最后都会调用 execute() 函数，而 execute() 函数会调用 gogo 汇编实现的函数。 // func gogo(buf *gobuf) // restore state from Gobuf; longjmp TEXT runtime·gogo(SB), NOSPLIT, $16-8 MOVQ buf+0(FP), BX // gobuf MOVQ gobuf_g(BX), DX MOVQ 0(DX), CX // make sure g != nil get_tls(CX) MOVQ DX, g(CX) MOVQ gobuf_sp(BX), SP // restore SP (关键!) MOVQ gobuf_ret(BX), AX MOVQ gobuf_ctxt(BX), DX MOVQ gobuf_bp(BX), BP MOVQ $0, gobuf_sp(BX) // clear to help garbage collector MOVQ $0, gobuf_ret(BX) MOVQ $0, gobuf_ctxt(BX) MOVQ $0, gobuf_bp(BX) MOVQ gobuf_pc(BX), BX JMP BX gobuf 中保存着要执行的 G 的 sp、pc 指针，可以看到通过将对应 gobuf.sp 写入到 SP 寄存器中，也就是将使用的栈切换为了 G 的栈。 ","date":"2021-01-05","objectID":"/posts/language/golang/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/:3:5","tags":["Golang","Golang 原理"],"title":"Go 内存管理总结","uri":"/posts/language/golang/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/"},{"categories":["Golang"],"content":"3.6 g0 的栈 在阅读网上的文章时，许多文章都说 g0 使用的是系统栈，我理解为使用的是进程的栈内存区域。但是思考一下，每个 M 对应一个 g0，也就是说有多个线程要同时共享系统栈，这是不可能的。例如在 pthread 实现中，对应新建的线程也是使用 mmap 分配一个内存区域，然后调用 clone() 系统调用时传入栈地址参数。 看一下代码，确认一下到底 g0 的栈到底是啥，找到一个新建 m 的地方： mp := new(m) mp.mstartfn = fn mcommoninit(mp, id) // In case of cgo or Solaris or illumos or Darwin, pthread_create will make us a stack. // Windows and Plan 9 will layout sched stack on OS stack. if iscgo || GOOS == \"solaris\" || GOOS == \"illumos\" || GOOS == \"windows\" || GOOS == \"plan9\" || GOOS == \"darwin\" { mp.g0 = malg(-1) } else { mp.g0 = malg(8192 * sys.StackGuardMultiplier) } mp.g0.m = mp 可以看到，m 的 g0 属性还是使用的 malg() 函数 去创建的，与普通的 g 创建一样，只不过初始大小为 8KB。malg() 流程上面有说到，就是走内存管理分配 mspan 作为栈的方式。 不过，g0 的栈还是有些不同的，不会进行栈的扩容（因为仅仅内部管理时用到，不需要进行自动扩容），在栈扩容的 morestack 汇编代码里可以看到。 ","date":"2021-01-05","objectID":"/posts/language/golang/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/:3:6","tags":["Golang","Golang 原理"],"title":"Go 内存管理总结","uri":"/posts/language/golang/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/"},{"categories":["Golang"],"content":"4 内存模型 ","date":"2021-01-05","objectID":"/posts/language/golang/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/:4:0","tags":["Golang","Golang 原理"],"title":"Go 内存管理总结","uri":"/posts/language/golang/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/"},{"categories":["Golang"],"content":"4.1 概览 Golang 内存管理包含四个组件： object ：object 代表用户代码申请的一个对象，没有实际的数据结构，而是在 mspan 中以逻辑切分的方式分配； page：切分内存的单元，mheap 将内存以 8KB page 切分，然后组合成为 mspan； runtime.mspan ：内存管理的最小单元，由多个 8KB 大小的 page 构成，按照固定大小来切分为多个 object； runtime.mcache ：单个 P 对应的 mspan 的缓存，无锁分配； runtime.mcentral ：按照不同大小的 mspan 分组的管理链表，为 mcache 提供空闲 mspan runtime.mheap ：保存闲置的 mspan 与 largerspan 链表，与操作系统申请与释放内存； 上面的组件也可以看做分层，普通对象（object）的申请与释放就是按照上下层顺序申请与释放的。 Note 下面不会说（后面再说）具体的 object 分配流程，而是说明各个层次时的申请与释放操作。 ","date":"2021-01-05","objectID":"/posts/language/golang/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/:4:1","tags":["Golang","Golang 原理"],"title":"Go 内存管理总结","uri":"/posts/language/golang/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/"},{"categories":["Golang"],"content":"4.2 mspan 每个 mspan 由多个 8KB 的 page 组成，所有的 mspan 会以 list 的方式构建，而不同的模块（mcache、mcentral）通过引用指针，来不同方式来组织不同的 mspan。 每个 mspan 管理多个固定大小的 object，通过编号(index)方式来寻找 object 的地址。 结构如下图所示： 其数据结构如下（省略部分）： type mspan struct { next *mspan // next span in list, or nil if none  prev *mspan // previous span in list, or nil if none startAddr uintptr // address of first byte of span aka s.base()  npages uintptr // number of pages in span manualFreeList gclinkptr // list of free objects in mSpanManual spans  freeindex uintptr nelems uintptr // number of object in the span.  allocCache uint64 allocBits *gcBits gcmarkBits *gcBits // sweep generation: // if sweepgen == h-\u003esweepgen - 2, the span needs sweeping // if sweepgen == h-\u003esweepgen - 1, the span is currently being swept // if sweepgen == h-\u003esweepgen, the span is swept and ready to use // if sweepgen == h-\u003esweepgen + 1, the span was cached before sweep began and is still cached, and needs sweeping // if sweepgen == h-\u003esweepgen + 3, the span was swept and then cached and is still cached // h-\u003esweepgen is incremented by 2 after every GC  sweepgen uint32 spanclass spanClass // size class and noscan (uint8)  allocCount uint16 // number of allocated objects  elemsize uintptr // computed from sizeclass or from npages } next、prev ：链表前后 span； startAddr ：span 在 arena 区域的起始地址; npages ：占用 page(8KB) 数量； manualFreeList ：空闲 object 链表； freeindex ：下一个空闲的 object 的编号，如果 freeindex == nelem，表明没有空闲 object 可以分配 nelems ：当前 span 中分配的 object 的上限； allocCache ：freeindex 的 cache，通过 bitmap 的方式记录对应编号的 object 内存是否是空闲的； sweepgen ：mspan 的状态, 见注释； spanclass ：mspan 大小类别； allocCount ：已经分配的 object 数量； elemsize ：管理的 object 的固定大小； 可以看到，每个 mspan 管理着固定大小的 object，并通过一个 freeindex+allocCache 来记录空闲的 object 的编号。由此可以得出: mspan 的地址区域: [startAddr, startAddr + npages*8*1024) 某个 object 的起始地址: \u003cindex\u003e*elemsize + startAddr 4.2.1 object 分配 在创建新的 object 时，对于普通大小的 object 分配（16\u003csize\u003c32KB)，会在从 mcache 中选出具有空闲空间的 mspan，然后记录到 mspan.allocCache 中。 具体代码如下，nextFreeIndex() 函数就是用于得到下一个空闲 object，并移动 freeindex（runtime/mbitmap.go)： // nextFreeIndex returns the index of the next free object in s at // or after s.freeindex. // There are hardware instructions that can be used to make this // faster if profiling warrants it. func (s *mspan) nextFreeIndex() uintptr { sfreeindex := s.freeindex snelems := s.nelems if sfreeindex == snelems { return sfreeindex } aCache := s.allocCache bitIndex := sys.Ctz64(aCache) for bitIndex == 64 { // Move index to start of next cached bits.  sfreeindex = (sfreeindex + 64) \u0026^ (64 - 1) if sfreeindex \u003e= snelems { s.freeindex = snelems return snelems } whichByte := sfreeindex / 8 // Refill s.allocCache with the next 64 alloc bits.  s.refillAllocCache(whichByte) aCache = s.allocCache bitIndex = sys.Ctz64(aCache) // nothing available in cached bits  // grab the next 8 bytes and try again.  } result := sfreeindex + uintptr(bitIndex) if result \u003e= snelems { s.freeindex = snelems return snelems } s.allocCache \u003e\u003e= uint(bitIndex + 1) sfreeindex = result + 1 if sfreeindex%64 == 0 \u0026\u0026 sfreeindex != snelems { // We just incremented s.freeindex so it isn't 0.  // As each 1 in s.allocCache was encountered and used for allocation  // it was shifted away. At this point s.allocCache contains all 0s.  // Refill s.allocCache so that it corresponds  // to the bits at s.allocBits starting at s.freeindex.  whichByte := sfreeindex / 8 s.refillAllocCache(whichByte) } s.freeindex = sfreeindex return result } 注意：目前跳过了 “nextFreeFast” 实现，该获取 span 比 “nextFree” 更快，使用了 mspan.allocCache。 4.2.2 mspan 的清理 TODO ","date":"2021-01-05","objectID":"/posts/language/golang/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/:4:2","tags":["Golang","Golang 原理"],"title":"Go 内存管理总结","uri":"/posts/language/golang/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/"},{"categories":["Golang"],"content":"4.3 mcache 每个 P 拥有一个 mcache，mcache 中保存着具有空闲空间的 mspan，用于分配 object 时，不需要加锁即可从 mspan 分配对象。 有两种 object 走 mcache 分配： tiny object：mcache 还单独使用一个 mspan 进行非指针微小对象的分配。与普通 object 对象分配不同的是，tiny object 不是固定大小分配的，而是通过 mcache 记录其 offset 偏移量，让 tiny object “挤在” 同一个 mspan 中。 normal object：普通大小的 object，会使用 mcache.alloc 进行分配。mcache.alloc 包含 134 个数组项（67 sizeclass * 2），对于每个大小规格的 mspan 有着两个类型： scan：包含指针的对象 noscan：不包含指针的对象，GC 时无需进一步扫描是否引用着其他活跃对象 mcache “永远” 有空闲的 mspan 用于 object 的分配，当 mcache 缓存的 mspan 没有空闲空间时，就会找 mcentral 去申请新的 mspan 用于使用。 数据结构如下（runtime/mcache.go）： // Per-thread (in Go, per-P) cache for small objects. // No locking needed because it is per-thread (per-P). // // mcaches are allocated from non-GC'd memory, so any heap pointers // must be specially handled. type mcache struct { // Allocator cache for tiny objects w/o pointers.  // See \"Tiny allocator\" comment in malloc.go. // tiny points to the beginning of the current tiny block, or  // nil if there is no current tiny block.  //  // tiny is a heap pointer. Since mcache is in non-GC'd memory,  // we handle it by clearing it in releaseAll during mark  // termination.  tiny uintptr tinyoffset uintptr local_tinyallocs uintptr // number of tiny allocs not counted in other stats // The rest is not accessed on every malloc. alloc [numSpanClasses]*mspan // spans to allocate from, indexed by spanClass stackcache [_NumStackOrders]stackfreelist } tiny tinyoffset ：用于小对象（\u003c16）的分配。tiny 指向当前为 tiny object 准备的 span 的起始地址，tinyoffset 指向对象使用的偏移地址； alloc ：最重要的属性，保存着不同大小的 mspan 各一个。目前，包含固定 64 类 sizeclass：0、8 … 32768； 4.3.1 mspan 的分配 先看下 tiny object 分配，在分配一个 object 时，如果大小小于 16 字节时，就会走 tiny object 逻辑。 func mallocgc(size uintptr, typ *_type, needzero bool) unsafe.Pointer { if size \u003c= maxSmallSize { if noscan \u0026\u0026 size \u003c maxTinySize { off := c.tinyoffset // Align tiny pointer for required (conservative) alignment. if size\u00267 == 0 { off = alignUp(off, 8) } else if size\u00263 == 0 { off = alignUp(off, 4) } else if size\u00261 == 0 { off = alignUp(off, 2) } if off+size \u003c= maxTinySize \u0026\u0026 c.tiny != 0 { // The object fits into existing tiny block. x = unsafe.Pointer(c.tiny + off) c.tinyoffset = off + size c.local_tinyallocs++ mp.mallocing = 0 releasem(mp) return x } // Allocate a new maxTinySize block. span = c.alloc[tinySpanClass] v := nextFreeFast(span) if v == 0 { v, span, shouldhelpgc = c.nextFree(tinySpanClass) } x = unsafe.Pointer(v) (*[2]uint64)(x)[0] = 0 (*[2]uint64)(x)[1] = 0 // See if we need to replace the existing tiny block with the new one // based on amount of remaining free space. if size \u003c c.tinyoffset || c.tiny == 0 { c.tiny = uintptr(x) c.tinyoffset = size } size = maxTinySize } else { ... } } else { ... } } 如果当前 tinyoffset+size \u003c 16B（因为每个 tiny span 的大小为 32B，而每个 tiny object 最大为 16，所以比较 16 即可），那么表明当前的 tiny span 肯定可以放下，那么移动 c.tinyoffset 偏移即可； 如果没有，那么就需要重新申请 tinySpanClass=5 的 span（32B），并替换当前 c.tiny 与 c.tinyoffset（当前 object 可以放在老的 span 或者新的 span）。 接着看下普通大小的 object 的分配，在外层函数计算好 spanClass 后，就会调用 nextFree() 函数（runtime/malloc.go）： // nextFree returns the next free object from the cached span if one is available. // Otherwise it refills the cache with a span with an available object and // returns that object along with a flag indicating that this was a heavy // weight allocation. If it is a heavy weight allocation the caller must // determine whether a new GC cycle needs to be started or if the GC is active // whether this goroutine needs to assist the GC. // // Must run in a non-preemptible context since otherwise the owner of // c could change. func (c *mcache) nextFree(spc spanClass) (v gclinkptr, s *mspan, shouldhelpgc bool) { s = c.alloc[spc] shouldhelpgc = false freeIndex := s.nextFreeIndex() if freeIndex == s.nelems { // The span is full.  if uintptr(s.allocCount) != s.nelems { println(\"runtime: s.allocCount=\", s.allocCount, \"s.nelems=\", s.nelems) throw(\"s.allocCount != s.nelems \u0026\u0026 freeIndex == s.nelems\") } c.refill(spc) shouldhelpgc = true s = c.alloc[spc] freeIndex = s.nextFreeIndex() } if freeIndex \u003e= s.nele","date":"2021-01-05","objectID":"/posts/language/golang/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/:4:3","tags":["Golang","Golang 原理"],"title":"Go 内存管理总结","uri":"/posts/language/golang/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/"},{"categories":["Golang"],"content":"4.4 mcentral mcentral 是内存分配器的中心缓存，用于给 mcache 提供空闲的 mspan。因为不是 P 对应的，所以访问也需要锁。 mheap 会创建 64 个 sizeClass 的 mcentral，每个 mcentral 管理相同大小的所有 mspan，以两个链表结构管理： nonempty ：包含空闲空间的 mspan 组成的链表； empty ：不包含空闲空间，或者被 mcache 申请的 mspan 组成的链表（判断是否被 mcache 使用是通过 mspan.sweepgen 属性来判断）； 当 mcache 要申请某大小的 mspan 时，会回去指定大小的 mcentral 实例上申请。 数据结构如下： // Central list of free objects of a given size. // //go:notinheap type mcentral struct { lock mutex spanclass spanClass // For !go115NewMCentralImpl. nonempty mSpanList // list of spans with a free object, ie a nonempty free list empty mSpanList // list of spans with no free objects (or cached in an mcache) … } lock ：访问需要加的锁； spanclass ：当前 mcentral 管理的 mspan 大小； nonempty ：包含空闲空间的 mspan 链表； empty ：不包含空闲空间，或者被 mcache 申请了的 mspan 链表； Note 源码中存在 go115NewMCentralImpl 的注释，对 mcentral 结构做了很大的改动，但是在 go1.15 release 页面上并没有看到对应的说明。 其 commit 见: runtime: add new mcentral implementation 4.4.1 从 mcentral 申请 mspan 在 mcache 中，可以看到 mcache 通过调用 mcentral.cacheSpan() 申请新的空闲 mspan。在 go1.15 中，因为有新版 mcentral 的实现，因此双链表方式移动到了 mcentral.oldCacheSpan() 方法中。 // Allocate a span to use in an mcache. func (c *mcentral) cacheSpan() *mspan { if !go115NewMCentralImpl { return c.oldCacheSpan() } … } // Allocate a span to use in an mcache. // // For !go115NewMCentralImpl. func (c *mcentral) oldCacheSpan() *mspan { lock(\u0026c.lock) sg := mheap_.sweepgen retry: var s *mspan // 走 nonempty 链表找  for s = c.nonempty.first; s != nil; s = s.next { if s.sweepgen == sg-2 \u0026\u0026 atomic.Cas(\u0026s.sweepgen, sg-2, sg-1) { c.nonempty.remove(s) c.empty.insertBack(s) unlock(\u0026c.lock) s.sweep(true) goto havespan } if s.sweepgen == sg-1 { // the span is being swept by background sweeper, skip  continue } // we have a nonempty span that does not require sweeping, allocate from it  c.nonempty.remove(s) c.empty.insertBack(s) unlock(\u0026c.lock) goto havespan } // 走 empty 链表找  for s = c.empty.first; s != nil; s = s.next { if s.sweepgen == sg-2 \u0026\u0026 atomic.Cas(\u0026s.sweepgen, sg-2, sg-1) { // we have an empty span that requires sweeping,  // sweep it and see if we can free some space in it  c.empty.remove(s) // swept spans are at the end of the list  c.empty.insertBack(s) unlock(\u0026c.lock) s.sweep(true) freeIndex := s.nextFreeIndex() if freeIndex != s.nelems { s.freeindex = freeIndex goto havespan } lock(\u0026c.lock) // the span is still empty after sweep  // it is already in the empty list, so just retry  goto retry } if s.sweepgen == sg-1 { // the span is being swept by background sweeper, skip  continue } // already swept empty span,  // all subsequent ones must also be either swept or in process of sweeping  break } unlock(\u0026c.lock) // 向 heap 申请新的 mspan  // Replenish central list if empty.  s = c.grow() if s == nil { return nil } lock(\u0026c.lock) c.empty.insertBack(s) unlock(\u0026c.lock) // At this point s is a non-empty span, queued at the end of the empty list,  // c is unlocked. havespan: … freeByteBase := s.freeindex \u0026^ (64 - 1) whichByte := freeByteBase / 8 // Init alloc bits cache.  s.refillAllocCache(whichByte) // Adjust the allocCache so that s.freeindex corresponds to the low bit in  // s.allocCache.  s.allocCache \u003e\u003e= s.freeindex % 64 return s } 上面逻辑可以大致分为几个步骤： 遍历 nonempty 链表，找到可用的 mspan（对于需要 sweep 的 mspan 先进行 sweep）； 没找到，遍历 empty 链表，仅仅遍历需要 sweep 的 mspan，执行 sweep 并判断是否可用； 还是没有，通过 mcentral.grow() 向 mheap 申请新的 mspan，mheap 中都没有，return nil； 找到空闲 mspan 后，会放置到 empty 链表尾部，并返回； 4.4.2 mcentral 扩容 在 mcentral 没有任何空闲 mspan 给 mcache 时，就会调用 mcentral.grow() 申请新的 mspan。 // grow allocates a new empty span from the heap and initializes it for c's size class. func (c *mcentral) grow() *mspan { npages := uintptr(class_to_allocnpages[c.spanclass.sizeclass()]) size := uintptr(class_to_size[c.spanclass.sizeclass()]) s := mheap_.alloc(npages, c.spanclass, true) if s == nil { return nil } // Use division by multiplication and shifts to quickly compute:  // n := (npages \u003c\u003c _PageShift) / size  n := (npages \u003c\u003c _PageShift) \u003e\u003e s.divShift * uintptr(s.divMul) \u003e\u003e s.divShift2 s.limit = s.base() + size*n heapBitsForAddr(s.ba","date":"2021-01-05","objectID":"/posts/language/golang/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/:4:4","tags":["Golang","Golang 原理"],"title":"Go 内存管理总结","uri":"/posts/language/golang/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/"},{"categories":["Golang"],"content":"4.5 mheap mheap 是最核心的组件了，runtime 只存在一个 mheap 对象，分配、初始化 mspan 都从 mheap 开始。 mheap 直接与虚拟内存打交道，并将在虚拟内存上创建 mspan 提供给上层使用。 mheap 的功能可以看做两个方面： 与下层（虚拟内存）：内存管理（类似文件系统）。申请虚拟内存得到多个 heaparena，每个 heaparena 将可用内存区域切分为 page 单元，以倍数组成 mspan 分配给上层； 与上层：提供创建 mspan 的接口。通过 mcentral 分类不同大小的 mspan，或者大内存需要直接走 mspan 分配； 其数据结构很大，省略了部分不会提到的属性（runtime/mheap.go），mheap_ 就是 heap 的单实例对象： var mheap_ mheap // Main malloc heap. // The heap itself is the \"free\" and \"scav\" treaps, // but all the other global data is here too. // // mheap must not be heap-allocated because it contains mSpanLists, // which must not be heap-allocated. // //go:notinheap type mheap struct { // arenas is the heap arena map. It points to the metadata for // the heap for every arena frame of the entire usable virtual // address space. // // Use arenaIndex to compute indexes into this array. // // For regions of the address space that are not backed by the // Go heap, the arena map contains nil. // // Modifications are protected by mheap_.lock. Reads can be // performed without locking; however, a given entry can // transition from nil to non-nil at any time when the lock // isn't held. (Entries never transitions back to nil.) // // In general, this is a two-level mapping consisting of an L1 // map and possibly many L2 maps. This saves space when there // are a huge number of arena frames. However, on many // platforms (even 64-bit), arenaL1Bits is 0, making this // effectively a single-level map. In this case, arenas[0] // will never be nil. arenas [1 \u003c\u003c arenaL1Bits]*[1 \u003c\u003c arenaL2Bits]*heapArena // central free lists for small size classes. // the padding makes sure that the mcentrals are // spaced CacheLinePadSize bytes apart, so that each mcentral.lock // gets its own cache line. // central is indexed by spanClass. central [numSpanClasses]struct { mcentral mcentral pad [cpu.CacheLinePadSize - unsafe.Sizeof(mcentral{})%cpu.CacheLinePadSize]byte } pages pageAlloc // page allocation data structure spanalloc fixalloc // allocator for span* cachealloc fixalloc // allocator for mcache* specialfinalizeralloc fixalloc // allocator for specialfinalizer* specialprofilealloc fixalloc // allocator for specialprofile* speciallock mutex // lock for special record allocators. arenaHintAlloc fixalloc // allocator for arenaHints } arenas ：内存管理的元信息数组，对于虚拟内存的逻辑切割与管理就靠这个数组了； central ：按照大小分类的各个 mcentral 对象； pages ：在 arena 区域上用于分配空闲的 pages，依旧使用空闲链表； spanalloc、cachealloc 等 ：各个数据结构的空闲链表分配器，通过连接空闲的 mspan、mcache 等对象，调用 fixalloc.alloc() 函数就获取下一个空闲的内存空间； 4.5.1 虚拟内存布局 网上大部分文章还是说 mheap 管理的虚拟内存以 spans+bitmap+arena 管理，如下图： 但是从 go 1.11 开始，Go 开始使稀疏内存方式管理，即管理相互之间不连续的连续的内存区域，如下图（图片来自 《Golang 设计与实现》）： 使用的就是 mheap.arenas，一个二维的 heapArena 数组。 不同平台的 heapArena 管理的 arena 大小不同，在 Linux 64bit 平台下，每个 heapArena 管理着 64MB 的 arena 内存区域。 // Currently, we balance these as follows: // // Platform Addr bits Arena size L1 entries L2 entries // -------------- --------- ---------- ---------- ----------- // */64-bit 48 64MB 1 4M (32MB) // windows/64-bit 48 4MB 64 1M (8MB) // */32-bit 32 4MB 1 1024 (4KB) // */mips(le) 31 4MB 1 512 (2KB) Note 这里不太好理解，但是我觉可以简单理解就是，将原来的 spans+bitmap+arena 管理方式，变为了多个 spans+bitmap+arena 实现。而不同 arena 之间的地址不是连续的。 但是为什么要用二维数组？目前不知道，但是 Linux x86-64 架构上一维数组大小为 1，就是相当于 1 维数组。 heapArena 数据结构如下（runtime/mheap.go）： // A heapArena stores metadata for a heap arena. heapArenas are stored // outside of the Go heap and accessed via the mheap_.arenas index. // //go:notinheap type heapArena struct { // bitmap stores the pointer/scalar bitmap for the words in  // this arena. See mbitmap.go for a description. Use the  // heapBits type to access this.  bitmap [heapArenaBitmapBytes]byte // spans maps from virtual address page ID within this arena to *mspan.  // For allocated spans, their pages map to the span itself.  // For free spans, only the lowest and highest pages map to the span itself.  // Internal pages map to an arbitrary span.  // For pages that have never been allocated, spans entries are nil.  //  // Modifications are prote","date":"2021-01-05","objectID":"/posts/language/golang/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/:4:5","tags":["Golang","Golang 原理"],"title":"Go 内存管理总结","uri":"/posts/language/golang/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/"},{"categories":["Golang"],"content":"4.6 总结 粗略地看完整个内存模型后，大概内存的结构如下： 其中比较核心的就是：内存被切分为 page，多个 page 组成不同大小的 mspan，而在 mspan 上又分割为固定大小的 object。 而上层的 mcache、mcentral 只是以不同的方式组织 mspan，通过多级缓存的思想，使得并发的获取一个可用的 mspan 更快。 mcache 将一部分 mspan 独立于 P 所有，使得不需要加锁既可以获取 mspan； mcentral 以大小来分类 mspan，将各个大小的 mspan 请求独立，缩小了锁的粒度； mheap 作为最底层，就好像文件系统一样，管理着整个内存分配的骨架。而与上层的交互就是靠 mspan 作为单位。 ","date":"2021-01-05","objectID":"/posts/language/golang/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/:4:6","tags":["Golang","Golang 原理"],"title":"Go 内存管理总结","uri":"/posts/language/golang/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/"},{"categories":["Golang"],"content":"5 对象分配流程 前面一直提到的，对象的分配分为三类： tiny object (0, 16B): 使用 tiny allocator 分配，使用 mcahe 一个独立的 mspan，挤压式的； object [16B, 32KB]: 使用 mcache 分配； large object (32KB, +∞): 直接通过 mheap 分配； 所有的分配逻辑在 mallocgc() 开始分叉，下面分别看下具体的分配代码。 ","date":"2021-01-05","objectID":"/posts/language/golang/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/:5:0","tags":["Golang","Golang 原理"],"title":"Go 内存管理总结","uri":"/posts/language/golang/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/"},{"categories":["Golang"],"content":"5.1 tiny object 分配 tiny object 分配的代码在 mspan 分配中已经说明了，这里再理一下大致步骤： 不包含指针(noscan)并且小于 16B 的对象才走微小对象分配； tiny object 分配仅仅是增大 mcache.tinyoffset 的值，所以是不同大小 tiny object 挤压在一个 mspan 中； 如果当前的 mspan 没有空间了，通过 mcache.nextFree() 来获取新的指定大小的 mspan，而获取的流程就是前面所说的（走 mcentral-\u003emheap); ","date":"2021-01-05","objectID":"/posts/language/golang/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/:5:1","tags":["Golang","Golang 原理"],"title":"Go 内存管理总结","uri":"/posts/language/golang/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/"},{"categories":["Golang"],"content":"5.2 object 分配 普通大小 object 分配流程就很简单了: func mallocgc(size uintptr, typ *_type, needzero bool) unsafe.Pointer { if size \u003c= maxSmallSize { if noscan \u0026\u0026 size \u003c maxTinySize { ... } else { var sizeclass uint8 if size \u003c= smallSizeMax-8 { sizeclass = size_to_class8[divRoundUp(size, smallSizeDiv)] } else { sizeclass = size_to_class128[divRoundUp(size-smallSizeMax, largeSizeDiv)] } size = uintptr(class_to_size[sizeclass]) spc := makeSpanClass(sizeclass, noscan) span = c.alloc[spc] v := nextFreeFast(span) if v == 0 { v, span, shouldhelpgc = c.nextFree(spc) } x = unsafe.Pointer(v) if needzero \u0026\u0026 span.needzero != 0 { memclrNoHeapPointers(unsafe.Pointer(v), size) } } } else { ... } } 计算出对应的 sizeclass； 从 mcache.alloc[] 得到对应的 mspan。如果没有，通过 nextFree() 申请； 调用 memclrNoHeapPointers() 清理空闲内存中所有数据； ","date":"2021-01-05","objectID":"/posts/language/golang/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/:5:2","tags":["Golang","Golang 原理"],"title":"Go 内存管理总结","uri":"/posts/language/golang/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/"},{"categories":["Golang"],"content":"5.3 large object 分配 func mallocgc(size uintptr, typ *_type, needzero bool) unsafe.Pointer { if size \u003c= maxSmallSize { if noscan \u0026\u0026 size \u003c maxTinySize { ... } else { ... } } else { shouldhelpgc = true systemstack(func() { span = largeAlloc(size, needzero, noscan) }) span.freeindex = 1 span.allocCount = 1 x = unsafe.Pointer(span.base()) size = span.elemsize } } func largeAlloc(size uintptr, needzero bool, noscan bool) *mspan { // print(\"largeAlloc size=\", size, \"\\n\") if size+_PageSize \u003c size { throw(\"out of memory\") } npages := size \u003e\u003e _PageShift if size\u0026_PageMask != 0 { npages++ } // Deduct credit for this span allocation and sweep if // necessary. mHeap_Alloc will also sweep npages, so this only // pays the debt down to npage pages. deductSweepCredit(npages*_PageSize, npages) spc := makeSpanClass(0, noscan) s := mheap_.alloc(npages, spc, needzero) if s == nil { throw(\"out of memory\") } if go115NewMCentralImpl { // Put the large span in the mcentral swept list so that it's // visible to the background sweeper. mheap_.central[spc].mcentral.fullSwept(mheap_.sweepgen).push(s) } s.limit = s.base() + size heapBitsForAddr(s.base()).initSpan(s) return s } large object 会切换到系统栈，然后走 mheap 申请； 计算对象需要的 page 数量，然后调用 mheap.alloc() 申请空闲的 mspan； 而 mheap.alloc() 就是 mcentral 申请 mspan 的方法。 ","date":"2021-01-05","objectID":"/posts/language/golang/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/:5:3","tags":["Golang","Golang 原理"],"title":"Go 内存管理总结","uri":"/posts/language/golang/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/"},{"categories":["Golang"],"content":"参考 《Golang 学习笔记》 Blog：Go 内存管理可视化 《Golang 设计与实现》：内存分配器 知乎：图解Go语言内存分配 ","date":"2021-01-05","objectID":"/posts/language/golang/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/:6:0","tags":["Golang","Golang 原理"],"title":"Go 内存管理总结","uri":"/posts/language/golang/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/"},{"categories":["VM"],"content":"总结 KVM 虚拟机使用存储与网络的方式","date":"2020-11-28","objectID":"/posts/cloud_computing/vm/kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%BD%91%E7%BB%9C/","tags":["虚拟机","KVM","云计算"],"title":"KVM 虚拟机的存储与网络","uri":"/posts/cloud_computing/vm/kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%BD%91%E7%BB%9C/"},{"categories":["VM"],"content":"本文主要总结一些遇到的虚拟机使用存储与网络的方式，在不断更新中 ~ 下面所有的虚拟机启动都使用 libvirt，通过修改其配置文件来设置网络或者存储，省略了虚拟机的启动、停止等操作命令。 ","date":"2020-11-28","objectID":"/posts/cloud_computing/vm/kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%BD%91%E7%BB%9C/:0:0","tags":["虚拟机","KVM","云计算"],"title":"KVM 虚拟机的存储与网络","uri":"/posts/cloud_computing/vm/kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%BD%91%E7%BB%9C/"},{"categories":["VM"],"content":"1 virtio 概述 KVM 在 IO 虚拟化方面，传统的方式是使用 QEMU 纯软件方式模拟网卡、磁盘。 KVM 中，可以在客户机使用 半虚拟化驱动Paravirtualized Drivers 来提高客户机性能。 目前，采用的是 virtio 这个设备驱动标准框架。 ","date":"2020-11-28","objectID":"/posts/cloud_computing/vm/kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%BD%91%E7%BB%9C/:1:0","tags":["虚拟机","KVM","云计算"],"title":"KVM 虚拟机的存储与网络","uri":"/posts/cloud_computing/vm/kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%BD%91%E7%BB%9C/"},{"categories":["VM"],"content":"1.1 全模拟 I/O 设备基本原理 纯软件模拟 I/O 如下图所示： 客户机中设备驱动程序（Device Driver）发起 I/O 操作请求时，KVM 内核模块会拦截这次请求，然后将请求信息放到 I/O 共享页（sharing page）； KVM 模块通知用户空间 QEMU 程序（客户机对应 qemu 进程的一个线程）有 I/O 请求； QEMU 模拟程序根据 I/O 请求信息，交由硬件模拟代码（Emulation Code）模拟 I/O 请求，阻塞等待 I/O 结果； 如果是普通的 I/O 请求完成后，将结果放回到 I/O 共享页； 如果客户机是通过 DMA 访问大块 I/O 时，QEMU 模拟程序会直接通过内存映射的将结果直接写到客户机内存中，并通知 KVM 模块客户机 DMA 操作已经完成； KVM 内核模块读取 I/O 共享页中结果，将结果返回给客户机； 或者，接受到 QEMU 通知，通知客户机 DMA 操作已经完成； QEMU 模拟 I/O 设备的优点：可以通过软件模拟出各种设备，兼容性好。但是也有明显缺点：每次 I/O 操作比较长，有较多的 VMEntry、VMExit 发生，需要多次上下文切换与数据复制，性能很差。 ","date":"2020-11-28","objectID":"/posts/cloud_computing/vm/kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%BD%91%E7%BB%9C/:1:1","tags":["虚拟机","KVM","云计算"],"title":"KVM 虚拟机的存储与网络","uri":"/posts/cloud_computing/vm/kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%BD%91%E7%BB%9C/"},{"categories":["VM"],"content":"1.2 virtio 基本原理 virtio 是一个在 Hypervisor 上抽象 API 接口，让客户机知道运行与虚拟化环境中，进而根据 virtio 标准与 Hypervisor 协作，从而在客户机达到更好性能。 其 virtio 基本结构如下： 前端驱动fronded 是在客户机中的驱动模块，如 virtio-blk、virtio-net 等； 后端处理程序backend 在 QEMU 中实现，执行具体的 I/O 操作； virtio 是虚拟队列接口，在逻辑上将前端驱动附加到后端处理程序，虚拟队列实际上被实现为跨越客户机操作系统和 Hypervisor 的衔接点，该衔接点可以用任意方式实现，前提是前后端都遵循标准实现。 一个前端驱动可以有 0 或多个队列，例如 virtio-net 使用两个虚拟队列（接受+发送）。 virtio-ring 实现了环形缓冲区（ring buffer），用于保存前端驱动和后端处理程序执行的信息。 环形缓冲区可以一次性保存前端驱动多个 I/O 请求，并交由后端驱动批量处理，最后实际调用宿主机设备驱动实现的设备 I/O 操作，以提升效率。 virtio 的性能很好，一般都推荐使用 virtio。但是，virtio 要求客户机必须安装特定的 virtio 驱动，并且按照 virtio 规定格式传输数据，一些老的 Linux 系统可能不支持。 在客户机中查看是否存在 virtio 相关内核模块，以确定系统是否支持 virtio： [root@kvm-guest ~]# lsmod | grep virtio virtio_net 28024 0 virtio_pci 22913 0 virtio_ring 21524 2 virtio_net,virtio_pci virtio 15008 2 virtio_net,virtio_pci 其中，virtio、virtio_ring、virtio_pci 等驱动提供对 virtio API 支持，任何 virtio 前端驱动都必须使用。 ","date":"2020-11-28","objectID":"/posts/cloud_computing/vm/kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%BD%91%E7%BB%9C/:1:2","tags":["虚拟机","KVM","云计算"],"title":"KVM 虚拟机的存储与网络","uri":"/posts/cloud_computing/vm/kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%BD%91%E7%BB%9C/"},{"categories":["VM"],"content":"1.3 vhost 正如前面所述，virtio 分为前后端，而后端默认为用户空间的 QEMU 进程。由 QEMU 进程模拟虚拟机的命令，在将结果返回给虚拟机。可以看到，这里存在着一次 用户空间至内核空间的转换。 而 vhost 出现就是用于优化这一次的转换。vhost 是宿主机中的一个内核模块，用于和虚拟机直接进行通信，也是通过 virtio 提供的数据队列进行通信。 目前，网络支持有 vhost-net，块设备支持有 vhost-blk，它们都依赖于基础的内核模块 vhost。 $ lsmod | grep vhost vhost_net 28672 1 vhost 53248 1 vhost_net vhost_iotlb 16384 1 vhost ","date":"2020-11-28","objectID":"/posts/cloud_computing/vm/kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%BD%91%E7%BB%9C/:1:3","tags":["虚拟机","KVM","云计算"],"title":"KVM 虚拟机的存储与网络","uri":"/posts/cloud_computing/vm/kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%BD%91%E7%BB%9C/"},{"categories":["VM"],"content":"1.4 总结 首先，需要明白 virtio 为什么比纯模拟的方式快？ 最主要因为纯模拟的方式存在多次内核 KVM 与用户空间 QEMU 进程的数据交互，简单点说，客户机需要 KVM 进行数据的中转。 而 virtio 消除了 KVM 进行数据的中转，通过一套标准框架实现虚拟机与 QEMU 进程的直接信息交互。也是因此，虚拟机需要使用特殊的 virtio 相关的驱动，也就知道了自己处于虚拟化环境，所以是半虚拟化。 其次，需要明确，virtio 由前后端组成，其中后端是由 QEMU 实现的，目前主流的 QEMU 版本都实现了，不需要 care。而需要注意的是，virtio 的前端是要在虚拟机中满足，也就是相关的 virtio 驱动，这在使用时需要进行确认。 而 virtio 的通信方式中，还存在 QEMU 模拟命令执行这一个优化点，因此，vhost 出现优化了这一次的用户空间至内核空间的切换。 ","date":"2020-11-28","objectID":"/posts/cloud_computing/vm/kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%BD%91%E7%BB%9C/:1:4","tags":["虚拟机","KVM","云计算"],"title":"KVM 虚拟机的存储与网络","uri":"/posts/cloud_computing/vm/kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%BD%91%E7%BB%9C/"},{"categories":["VM"],"content":"2 设备直接分配 ","date":"2020-11-28","objectID":"/posts/cloud_computing/vm/kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%BD%91%E7%BB%9C/:2:0","tags":["虚拟机","KVM","云计算"],"title":"KVM 虚拟机的存储与网络","uri":"/posts/cloud_computing/vm/kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%BD%91%E7%BB%9C/"},{"categories":["VM"],"content":"2.1 PCI 设备直接分配 PCI 设备直接分配 允许将宿主机的物理 PCI（或 PCI-E）设备直接分配给客户机完全使用。 设备直接分配相当于虚拟机直接使用硬件设备，也就没有了 QEMU 进程的模拟，因此速度最快。 但是，设备直接分配有一些条件： 硬件平台需要支持 Intel 硬件支持设备直接分配规范为 “Intel(R)Virtualization Technology for Directed I/O”（VT-d）或者 AMD 的规范为 “AMD-Vi”（也叫作IOMMU）。 目前市面上的 x86 硬件平台基本都支持 VT-d，在 BIOS 中设置打开 VT-d 特性。 内核配置支持相关 VT-d 的特性，并且加载内核模块 vfio-pci（内核 \u003e= 3.10）。 内核启动参数需要打开 intel_iommu=on（intel 平台） $ modprobe vfio_pci $ lsmod | grep vfio vfio_pci 53248 0 vfio_virqfd 16384 1 vfio_pci vfio_iommu_type1 32768 0 vfio 36864 2 vfio_iommu_type1,vfio_pci irqbypass 16384 8 vfio_pci,kvm ","date":"2020-11-28","objectID":"/posts/cloud_computing/vm/kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%BD%91%E7%BB%9C/:2:1","tags":["虚拟机","KVM","云计算"],"title":"KVM 虚拟机的存储与网络","uri":"/posts/cloud_computing/vm/kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%BD%91%E7%BB%9C/"},{"categories":["VM"],"content":"2.2 SR-IOV VT-d 技术只能讲一个物理设备分配给一个客户机使用，为了让多个虚拟机共享同一个物理设备，PCI_SIG 组织发布了 SR-IOVSingle Root I/O Virtualizaiton and Sharing 规范，该规范定义了标准化机制，用以原生的支持多个共享的设备（不一定网卡）。 目前，SR-IOV 最广泛应用在以太网设备的虚拟化方面。 SR-IOV 引入了两个新的 function： PF 物理功能Physical Function ：PF 是一个普通的 PCI-e 设备（带有 SR-IOV 功能），在宿主机中配置和管理其他 VF，本身也可以作为独立 function 使用； VF 虚拟功能Virtual Function ：由 PF 衍生的 “轻量级” PCI-e 功能，可以分配到客户机中作为独立 function 使用； SR-IOV 为客户机中使用的 VF 提供了独立的内存空间、中断、DMA 流，从而不需要 Hypervisor 介入数据传输。 一个具有 SR-IOV 功能的设备能够被配置为 PCI 配置空间中呈现出多个 Function（1 个 PF + 多个 VF），每个 VF 有独立的配置空间和完整的 BAR（Base Address Register，基址寄存器）。 Hypervisor 通过将 VF 实际的配置空间映射到客户机看到的配置空间的方式，将一个或多个 VF 分配给一个客户机。并且，通过 Intel VT-x 和 VT-d 等硬件辅助虚拟化技术提供的内存转换技术，允许直接的 DMA 传输去往或来自一个客户机，因此几乎不需要 Hypervisor 的参与。 在客户机中看到的 VF，表现给客户机操作系统的就是一个完整的普通的设备。 SR-IOV 需要硬件平台支持 Intel VT-x 和 VT-d（或 AMD 的 SVM 和 IOMMU）虚拟化特性，并且需要具体设备支持 SR-IOV 规范。 在 Linux 中，可以查看 PCI 信息的“Capabilities”项目，以确定设备是否具备 SR-IOV 功能： $ lspci -s 82:00.0 -v 82:00.0 Ethernet controller: Intel Corporation I350 Gigabit Network Connection (rev 01) Flags: bus master, fast devsel, latency 0, IRQ 38, NUMA node 1 Memory at d0100000 (32-bit, non-prefetchable) [size=1M] I/O ports at c020 [size=32] Memory at d0204000 (32-bit, non-prefetchable) [size=16K] Expansion ROM at d0400000 [disabled] [size=1M] Capabilities: [40] Power Management version 3 Capabilities: [50] MSI: Enable- Count=1/1 Maskable+ 64bit+ Capabilities: [70] MSI-X: Enable+ Count=10 Masked- Capabilities: [a0] Express Endpoint, MSI 00 Capabilities: [100] Advanced Error Reporting Capabilities: [140] Device Serial Number a4-dc-be-ff-ff-17-8d-52 Capabilities: [150] Alternative Routing-ID Interpretation (ARI) Capabilities: [160] Single Root I/O Virtualization (SR-IOV) Capabilities: [1a0] Transaction Processing Hints Capabilities: [1c0] Latency Tolerance Reporting Capabilities: [1d0] Access Control Services Kernel driver in use: igb Kernel modules: igb “Capabilities: [160] Single Root I/O Virtualization (SR-IOV)\" 表示网卡支持 SR-IOV 功能 具体使用方式见网络模式中的示例。 ","date":"2020-11-28","objectID":"/posts/cloud_computing/vm/kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%BD%91%E7%BB%9C/:2:2","tags":["虚拟机","KVM","云计算"],"title":"KVM 虚拟机的存储与网络","uri":"/posts/cloud_computing/vm/kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%BD%91%E7%BB%9C/"},{"categories":["VM"],"content":"3 存储模式 下面的磁盘测试都是以 4k 随机读写测试，命令如下： fio -thread -name=${DISK} -filename=${DISK} \\ -ioengine=libaio -direct=1 -bs=4k -rw=randrw -iodepth=32 \\ -size=8G -rw=readrw 说明，测试仅仅适用于简单对比各个模式之间性能差异，而不是标准的基准测试，不能作为靠谱数据。 ","date":"2020-11-28","objectID":"/posts/cloud_computing/vm/kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%BD%91%E7%BB%9C/:3:0","tags":["虚拟机","KVM","云计算"],"title":"KVM 虚拟机的存储与网络","uri":"/posts/cloud_computing/vm/kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%BD%91%E7%BB%9C/"},{"categories":["VM"],"content":"3.1 纯模拟 纯模拟是最简单的方式，所有的 IO 请求发送给 QEMU，由 QEMU 在宿主机执行后将结果返回给虚拟机中（见 1.1）。 创建一个 qcow2 文件，并将其以 sata 驱动方式提供给虚拟机： … \u003cdisk type='file' device='disk'\u003e \u003cdriver name='qemu' type='qcow2'/\u003e \u003csource file='/root/disk1.qcow2'/\u003e \u003ctarget dev='sda' bus='sata'/\u003e \u003caddress type='drive' controller='0' bus='0' target='0' unit='0'/\u003e \u003c/disk\u003e … 在虚拟机中，可以看到对应的磁盘与对应的驱动： [root@localhost ~]# lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT sda 8:0 0 500G 0 disk vda 253:0 0 500G 0 disk └─vda1 253:1 0 500G 0 part / [root@localhost ~]# lspci … 00:09.0 SATA controller: Intel Corporation 82801IR/IO/IH (ICH9R/DO/DH) 6 port SATA Controller [AHCI mode] (rev 02) 压测结果： read: IOPS=9183, BW=35.9MiB/s (37.6MB/s)(4098MiB/114246msec) write: IOPS=9172, BW=35.8MiB/s (37.6MB/s)(4094MiB/114246msec) ","date":"2020-11-28","objectID":"/posts/cloud_computing/vm/kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%BD%91%E7%BB%9C/:3:1","tags":["虚拟机","KVM","云计算"],"title":"KVM 虚拟机的存储与网络","uri":"/posts/cloud_computing/vm/kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%BD%91%E7%BB%9C/"},{"categories":["VM"],"content":"3.2 virtio-blk virtio-blk 实现了 virtio 标准，在虚拟机中使用 virtio 驱动，加速存储的访问。当然，需要客户机中系统支持 virtio-blk 内核模块。 [root@localhost ~]# lsmod | grep blk virtio_blk 18323 2 目前，virtio-blk 可用于宿主机文件、裸设备、LVM 设备，挂载到虚拟机后命名为 vdx。 将 \u003cdisk\u003e.\u003ctarget\u003e 中的 bus 改为 virtio，就是使用 virtio-blk 方式。 … \u003cdisk type='file' device='disk'\u003e \u003cdriver name='qemu' type='qcow2'/\u003e \u003csource file='/root/disk1.qcow2'/\u003e \u003ctarget dev='sda' bus='virtio'/\u003e \u003caddress type='pci' domain='0x0000' bus='0x00' slot='0x0a' function='0x0'/\u003e \u003c/disk\u003e … 不过使用 virtio 驱动，设置的 dev 名称会失效，自动使用 vdx 这种命名方式。在虚拟机中看到对应的磁盘以及驱动： [root@localhost ~]# lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT vda 253:0 0 500G 0 disk └─vda1 253:1 0 500G 0 part / vdb 253:16 0 500G 0 disk [root@localhost ~]# lspci … 00:0a.0 SCSI storage controller: Red Hat, Inc. Virtio block device 压测结果，可以看到，比纯模拟要快很多： read: IOPS=41.7k, BW=163MiB/s (171MB/s)(4098MiB/25145msec) write: IOPS=41.7k, BW=163MiB/s (171MB/s)(4094MiB/25145msec) virtio-blk 虽然提供了很高的存储访问性能，但是其设计上也有着一些缺点： virtio blk 的范围有限，这使得新的命令实现变得复杂。每次开发一个新命令时，virtio blk 驱动程序都必须在每个客户机中更新 virtio blk 将 PCI 功能和存储设备映射为1:1，一个映射就需要占用虚拟机一个 PCI 地址，限制了可扩展性。 virtio blk 不是真正的 SCSI 设备。这会导致一些应用程序在从物理机移动到虚拟机时中断。 ","date":"2020-11-28","objectID":"/posts/cloud_computing/vm/kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%BD%91%E7%BB%9C/:3:2","tags":["虚拟机","KVM","云计算"],"title":"KVM 虚拟机的存储与网络","uri":"/posts/cloud_computing/vm/kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%BD%91%E7%BB%9C/"},{"categories":["VM"],"content":"3.3 virtio-scsi virito-scsi 有着与 virtio-blk 相同的性能，但是改善了 virtio-blk 的相关缺点，其中最大的优势就是 virtio-scsi 可以允许虚拟机处理数百个设备，而 virtio-blk 只能处理大约 30 个设备就会耗尽 PCI 插槽。 因为 virtio-scsi 在虚拟机里使用的是 scsi 驱动，因此设备的命名也变为了 sdx。 将磁盘的驱动设置为 scsi，同时将 scsi 驱动设置为使用 virtio-scsi（默认使用的驱动是 lsi）： … \u003cdisk type='file' device='disk'\u003e \u003cdriver name='qemu' type='qcow2'/\u003e \u003csource file='/root/disk1.qcow2'/\u003e \u003ctarget dev='sdc' bus='scsi'/\u003e \u003caddress type='drive' controller='0' bus='0' target='0' unit='2'/\u003e \u003c/disk\u003e \u003ccontroller type='scsi' index='0' model='virtio-scsi'/\u003e … 可以看到，\u003caddress\u003e 中设置相关设备地址时，可以看到不是设置 pci 槽地址，而是设置设备对应 SCSI 映射地址，因此通过增加 “target” 属性就可以添加多个硬盘，不需要占用多个 PCI 槽； 虚拟机中看到对应的块设备 “sda”，以及驱动 “Virtio SCSI”： [root@localhost ~]# lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT sda 8:0 0 500G 0 disk vda 253:0 0 500G 0 disk └─vda1 253:1 0 500G 0 part / [root@localhost ~]# lspci … 00:08.0 SCSI storage controller: Red Hat, Inc. Virtio SCSI 压测结果： read: IOPS=45.5k, BW=178MiB/s (186MB/s)(4098MiB/23055msec) write: IOPS=46.2k, BW=180MiB/s (189MB/s)(4094MiB/22695msec) 目前，virtio-scsi 还存在一种设备直通的模式，IO 性能更高（具体实现原理还不了解）。但是，这种模式还能用于块设备，并且是使用 scsi 协议的块设备（测试文件、usb 都不支持）。 通过设置 device=“lun” 使用： ... \u003cdisk type='block' device='lun'\u003e \u003cdriver name='qemu' type='raw'/\u003e \u003csource dev='/dev/sda'/\u003e \u003ctarget dev='sdc' bus='scsi'/\u003e \u003caddress type='drive' controller='0' bus='0' target='0' unit='2'/\u003e \u003c/disk\u003e \u003ccontroller type='scsi' index='0' model='virtio-scsi' /\u003e ... 使用 lun 方式，并指定使用宿主机块设备 sda 虚拟机中看到对应块设备 “sda”，以及驱动 \"” ： [root@localhost ~]# lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT sda 8:0 0 465.8G 0 disk vda 253:0 0 500G 0 disk └─vda1 253:1 0 500G 0 part / [root@localhost ~]# lspci … 00:08.0 SCSI storage controller: Red Hat, Inc. Virtio SCSI 发现的问题 在使用 lun 分配磁盘时，发现虚拟机内部对磁盘的修改，在宿主机上是无法可见的（可能出现磁盘文件系统 UUID 都不一致的问题）。并且，在虚拟机内部给磁盘创建文件系统还会出现有报错的情况。 如果是要将 scsi 磁盘单独分给虚拟机，推荐使用设备直接分配中的 scsi 设备分配。 ","date":"2020-11-28","objectID":"/posts/cloud_computing/vm/kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%BD%91%E7%BB%9C/:3:3","tags":["虚拟机","KVM","云计算"],"title":"KVM 虚拟机的存储与网络","uri":"/posts/cloud_computing/vm/kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%BD%91%E7%BB%9C/"},{"categories":["VM"],"content":"3.4 设备直接分配 3.4.1 PCI 设备 在 2.1 中所说，PCI 设备都支持进行设备直接分配，使得虚拟机中直接对 PCI 设备进行访问，速度最快。nvme 磁盘可以使用这种方式。 使用设备直接分配时，需要现在宿主机上取消对应设备的驱动绑定，然后将其分配给虚拟机，然后 libvirt 中配置好相关参数后，会自动帮我们执行这些步骤。 在设备 xml 配置文件中添加 \u003chostdev\u003e 项，指定对应的设备 PCI 地址，来直接分配设备（也可以使用 \u003cinterface type=‘hostdev’/\u003e，这是一种 libvirt 提供的较新的配置方式，但是不兼容所有设备）。 … \u003chostdev mode='subsystem' type='pci' managed='yes'\u003e \u003csource\u003e \u003caddress domain='0x0000' bus='0x08' slot='0x00' function='0x0'/\u003e \u003c/source\u003e \u003c/hostdev\u003e … 3.4.2 SCSI 设备 对于 SCSI 磁盘，通过 PCI 无法单独分配某个磁盘，而 libvirt 中提供了 type=‘scsi’ 类型的直接分配。但是与 PCI 不同的是，scsi 无法设置 ‘managed’ 参数，也就是说宿主机上还是能够看见该 scsi 设备，如果想不可见，需要自己 unbind。 添加 scsi 类型的 \u003chostdev\u003e 项，其中 \u003csource\u003e.\u003caddress\u003e 中指定宿主机对应磁盘的 scsi 地址。 ... \u003chostdev mode='subsystem' type='scsi' managed='no' sgio='filtered' rawio='yes'\u003e \u003csource\u003e \u003cadapter name='scsi_host0'/\u003e \u003caddress bus='2' target='1' unit='0'/\u003e \u003c/source\u003e \u003caddress type='drive' controller='0' bus='0' target='0' unit='2'/\u003e \u003c/hostdev\u003e \u003ccontroller type='scsi' index='0' model='virtio-scsi'/\u003e ... Note 这种模式还是会使用 virtio-scsi 驱动，我不确定这是否属于设备直接分配，但是在文档中其属于 passthrough 的一类 ","date":"2020-11-28","objectID":"/posts/cloud_computing/vm/kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%BD%91%E7%BB%9C/:3:4","tags":["虚拟机","KVM","云计算"],"title":"KVM 虚拟机的存储与网络","uri":"/posts/cloud_computing/vm/kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%BD%91%E7%BB%9C/"},{"categories":["VM"],"content":"3.5 libvirt 提供的存储模型 TODO ","date":"2020-11-28","objectID":"/posts/cloud_computing/vm/kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%BD%91%E7%BB%9C/:3:5","tags":["虚拟机","KVM","云计算"],"title":"KVM 虚拟机的存储与网络","uri":"/posts/cloud_computing/vm/kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%BD%91%E7%BB%9C/"},{"categories":["VM"],"content":"4 网络模式 虚拟机网络的构建一般都是需要构建 宿主机网络环境 + 虚拟机虚拟网络设备，得益于 libvirt，一些常用的网络的构建只需要配置好相关配置就行，libvirt 会进行网络的构建。在 libvirt 中，一个可用的网络就称为 netowrk 首先需要明确的，下面所说的网络模式不同的在于如何让宿主机接收的数据包，到达 qemu 进程 或者 vhost 内核模块。而 qemu 进程与 vhost 模块如何将数据包传递到虚拟机中，这是虚拟化方式的问题，即全虚拟化或者半虚拟化。 更简单点说，虚拟机的网络收发有三个点：宿主机 \u003c-\u003e qemu/vhost \u003c-\u003e 虚拟机。而不同网络模式不同点在 宿主机至 qemu/vhost 阶段，而数据包到虚拟机，这就是不同虚拟化的工作了。 在下面的配置中，你会发现网络模式还需要配置 driver 选项，这就是配置具体的虚拟化方式了。但是这不是这里的重点，所以不会有特殊的说明。 libvirt 支持的网络模式有很多，下面仅仅提到我使用过的。 ","date":"2020-11-28","objectID":"/posts/cloud_computing/vm/kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%BD%91%E7%BB%9C/:4:0","tags":["虚拟机","KVM","云计算"],"title":"KVM 虚拟机的存储与网络","uri":"/posts/cloud_computing/vm/kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%BD%91%E7%BB%9C/"},{"categories":["VM"],"content":"4.1 虚拟机网络 4.1.1 NAT Mode NAT 网络是最简单的网络，不需要任何的依赖。通过虚拟的 bridge 网卡创建一个属于虚拟机的内网，然后在宿主机上通过 iptables 实现内网地址的 NAT。（没错，这和 docker bridge network 的原理一样） libvirt 会存在一个名为 default 的 network，其就是一个 NAT 网络。通过 virsh net-list 查看: $ virsh net-list Name State Autostart Persistent -------------------------------------------- default active yes yes 其默认会被 active，也就是说宿主机环境在 libvirtd 启动后就会构建好，你可以看到对应的 bridge 网卡。 $ ip a ... 3: virbr0: \u003cNO-CARRIER,BROADCAST,MULTICAST,UP\u003e mtu 1500 qdisc noqueue state DOWN group default qlen 1000 link/ether 52:54:00:12:34:56 brd ff:ff:ff:ff:ff:ff inet 172.27.0.1/16 brd 172.27.255.255 scope global galaxybr0 valid_lft forever preferred_lft forever ... 默认下，default 网络的内网为 192.168.122.1/24，我通过修改其配置文件 /etc/libvirt/qemu/networks/default.xml 修改了内网范围: $ cat /etc/libvirt/qemu/networks/default.xml \u003cnetwork\u003e \u003cname\u003edefault\u003c/name\u003e \u003cuuid\u003e341adece-b07a-4eb0-92f2-d92f59ed266f\u003c/uuid\u003e \u003cforward mode='nat'/\u003e \u003cbridge name='virbr0' stp='on' delay='0'/\u003e \u003cmac address='52:54:00:12:34:56'/\u003e \u003cip address='172.27.0.1' netmask='255.255.0.0'\u003e \u003cdhcp\u003e \u003crange start='172.27.0.2' end='172.27.255.254'/\u003e \u003c/dhcp\u003e \u003c/ip\u003e \u003c/network\u003e libvirtd 会为启动的 nat 网络启动一个 dnsmasq 进程，用于提供 DNS 与 DHCP 功能，其对应配置就是对应网络的配置 $ ps x | grep dns 2185 ? S 0:00 /usr/sbin/dnsmasq --conf-file=/var/lib/libvirt/dnsmasq/default.conf --leasefile-ro --dhcp-script=/usr/libexec/libvirt_leaseshelper $ cat /var/lib/libvirt/dnsmasq/default.conf strict-order pid-file=/var/run/libvirt/network/default.pid except-interface=lo bind-dynamic interface=virbr0 dhcp-range=172.27.0.2,172.27.255.254,255.255.0.0 dhcp-no-override dhcp-authoritative dhcp-lease-max=65533 dhcp-hostsfile=/var/lib/libvirt/dnsmasq/default.hostsfile addn-hosts=/var/lib/libvirt/dnsmasq/default.addnhosts Note 这里与 docker bridge network 不同点，因为 docker 中仅仅是 namespace 隔离，容器内网卡 IP 还是可以由 docker 进入 namespace 分配，所以是 docker 承担了 dhcp 服务器的职责。 但是虚拟机和宿主机是强隔离的，因此需要虚拟机启动后去作为 dhcpclient 申请地址，因此需要一个 dhcp 服务，这就是 dnsmasq 的作用。 在 xml 配置文件中设置 \u003cinterface type=‘network’\u003e 项，并设置 \u003csource network=‘default’/\u003e 使用 default network。 \u003cinferface type='network'\u003e \u003cmac address='50:54:00:87:bc:c3'/\u003e \u003csource network='default'/\u003e \u003cmodel type='virtio'/\u003e \u003cdriver name='vhost' txmode='iothread' ioeventfd='on' event_idx='off' queues='16'\u003e \u003chost csum='off' gso='off' tso4='off' tso6='off' ecn='off' ufo='off' mrg_rxbuf='off'/\u003e \u003cguest csum='off' tso4='off' tso6='off' ecn='off' ufo='off'/\u003e \u003c/driver\u003e \u003c/interface\u003e 启动虚拟机后，可以看到虚拟机内部存在对应的网卡，通过 dhclient -v eth0 命令申请一个 IP，广播的 dhcp request 会被宿主机 dnsmasp 进程响应，并返回 dhcp offer。 [root@localhost ~]# ip a ... 2: eth0: \u003cBROADCAST,MULTICAST\u003e mtu 1500 qdisc noop state DOWN group default qlen 1000 link/ether 50:54:00:87:bc:c3 brd ff:ff:ff:ff:ff:ff [root@localhost ~]# dhclient -v eth0 ... Listening on LPF/eth0/50:54:00:87:bc:c3 Sending on LPF/eth0/50:54:00:87:bc:c3 Sending on Socket/fallback DHCPDISCOVER on eth0 to 255.255.255.255 port 67 interval 4 (xid=0x57740476) DHCPREQUEST on eth0 to 255.255.255.255 port 67 (xid=0x57740476) DHCPOFFER from 172.27.0.1 DHCPACK from 172.27.0.1 (xid=0x57740476) bound to 172.27.163.138 -- renewal in 1653 seconds. [root@localhost ~]# ping www.baidu.com PING www.a.shifen.com (14.215.177.38) 56(84) bytes of data. 64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=1 ttl=48 time=7.93 ms ... 4.1.2 Routed Mode TODO ","date":"2020-11-28","objectID":"/posts/cloud_computing/vm/kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%BD%91%E7%BB%9C/:4:1","tags":["虚拟机","KVM","云计算"],"title":"KVM 虚拟机的存储与网络","uri":"/posts/cloud_computing/vm/kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%BD%91%E7%BB%9C/"},{"categories":["VM"],"content":"4.2 共享物理设备网络 4.2.1 Bridge TODO 4.2.2 Macvtap 在 docker 的网络中，存在着 macvlan 网络，其在宿主机的物理网卡上创建 macvlan 设备，使得在二层上构建多个接口，从而让多个容器处于与宿主机同一个局域网内。在虚拟机网络中，单单 macvlan 网卡无法连接虚拟机设备与宿主机网卡，还需要一个 tap 设备连接，将 macvlan + tap 组合就是 macvtap 设备。 与 macvlan 设备相同，macvtap 同样存在：private、vepa、bridge、passthru 四种模式，下面的示例中都以 bridge 模式为例。 在 libvirt 中，当 interface type 为 direct 时，表明设备是直接附加到物理网卡上，而就会使用 macvtap 构建网络。通过 \u003csource dev=xx mode=xx\u003e 指定附加的物理网卡，以及 macvtap 的模式。 ... \u003cinterface type='direct'\u003e \u003cmac address='50:54:00:87:bc:c3'/\u003e \u003csource dev='eth3' mode='bridge'/\u003e \u003cmodel type='virtio'/\u003e \u003cdriver name='vhost' txmode='iothread' ioeventfd='on' event_idx='off' queues='16'\u003e \u003chost csum='off' gso='off' tso4='off' tso6='off' ecn='off' ufo='off' mrg_rxbuf='off'/\u003e \u003cguest csum='off' tso4='off' tso6='off' ecn='off' ufo='off'/\u003e \u003c/driver\u003e \u003caddress type='pci' domain='0x0000' bus='0x00' slot='0x03' function='0x0'/\u003e \u003c/interface\u003e ... 启动虚拟机后，在宿主机上可以看到对应的 macvtap 设备被创建, 其 mac 地址也与配置中的一致。 $ ip a ... 5: eth3: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1500 qdisc mq state UP group default qlen 1000 link/ether a4:dc:be:0a:7d:37 brd ff:ff:ff:ff:ff:ff inet 192.168.1.107/24 brd 192.168.1.255 scope global eth3 valid_lft forever preferred_lft forever 10: macvtap0@eth3: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1500 qdisc pfifo_fast state UP group default qlen 500 link/ether 50:54:00:87:bc:c3 brd ff:ff:ff:ff:ff:ff 在虚拟机内部，可以看到对应的虚拟网卡，通过 dhcp 上层路由器获取 IP，可以发现，其网关就是宿主机的网关，其网段与宿主机一致。因此，使用 macvtap 相当于让虚拟机与宿主机处于同一个二层。 [root@localhost ~]# dhclient -v eth0 ... Listening on LPF/eth0/50:54:00:87:bc:c3 Sending on LPF/eth0/50:54:00:87:bc:c3 Sending on Socket/fallback DHCPREQUEST on eth0 to 255.255.255.255 port 67 (xid=0x4e586341) DHCPNAK from 192.168.1.1 (xid=0x4e586341) DHCPDISCOVER on eth0 to 255.255.255.255 port 67 interval 8 (xid=0x1d605c78) DHCPREQUEST on eth0 to 255.255.255.255 port 67 (xid=0x1d605c78) DHCPOFFER from 192.168.1.1 DHCPACK from 192.168.1.1 (xid=0x1d605c78) bound to 192.168.1.105 -- renewal in 3423 seconds. [root@localhost ~]# ip a 2: eth0: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1500 qdisc mq state UP group default qlen 1000 link/ether 52:54:00:87:bc:c1 brd ff:ff:ff:ff:ff:ff inet 192.168.1.105/24 brd 192.168.1.255 scope global dynamic eth0 valid_lft 7023sec preferred_lft 7023sec ","date":"2020-11-28","objectID":"/posts/cloud_computing/vm/kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%BD%91%E7%BB%9C/:4:2","tags":["虚拟机","KVM","云计算"],"title":"KVM 虚拟机的存储与网络","uri":"/posts/cloud_computing/vm/kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%BD%91%E7%BB%9C/"},{"categories":["VM"],"content":"4.3 设备直接分配 前面的各种网络模式，最后还是靠着全虚拟化或者半虚拟化将数据包传递给虚拟机，而如果你有着多个可用的网卡，那么可以考虑使用设备直接分配，这是性能最高的方式。 4.3.1 PCI 网卡 在设备 xml 配置文件中添加 \u003chostdev\u003e 项，指定对应的设备 PCI 地址，来直接分配设备（也可以使用 \u003cinterface type=‘hostdev’/\u003e，这是一种 libvirt 提供的较新的配置方式，但是不兼容所有设备）。 … \u003chostdev mode='subsystem' type='pci' managed='yes'\u003e \u003csource\u003e \u003caddress domain='0x0000' bus='0x01' slot='0x00' function='0x0'/\u003e \u003c/source\u003e \u003c/hostdev\u003e … 启动虚拟机后，在宿主机上就无法看到对应的网卡了，因为对应的驱动被 libvirt 解绑了。 关闭虚拟机后，libvirt 又会重新将网卡绑定驱动，在宿主机上有可见了。 4.3.1 SR-IOV TODO ","date":"2020-11-28","objectID":"/posts/cloud_computing/vm/kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%BD%91%E7%BB%9C/:4:3","tags":["虚拟机","KVM","云计算"],"title":"KVM 虚拟机的存储与网络","uri":"/posts/cloud_computing/vm/kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%BD%91%E7%BB%9C/"},{"categories":["VM"],"content":"参考 libvirt domain 配置官方文档 RedHat：Guest Virtual Machine Device Configuration virtio-scsi passthrough virtio-scsi 和 virtio-blk 的理解 libvirt: Networking libvirt: VirtualNetworking ","date":"2020-11-28","objectID":"/posts/cloud_computing/vm/kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%BD%91%E7%BB%9C/:5:0","tags":["虚拟机","KVM","云计算"],"title":"KVM 虚拟机的存储与网络","uri":"/posts/cloud_computing/vm/kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%BD%91%E7%BB%9C/"},{"categories":["Docker 原理总结"],"content":"容器启动背后的执行过程","date":"2020-11-13","objectID":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E5%90%AF%E5%81%9C%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/","tags":["docker","container"],"title":"容器启停原理总结","uri":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E5%90%AF%E5%81%9C%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/"},{"categories":["Docker 原理总结"],"content":"目的：描述容器启停背后的步骤，但是不涉及源码。 示例的基于 ubuntu 20.04.1 LTS 虚拟机运行，docker 版本如下： $ docker version Client: Version: 19.03.8 API version: 1.40 Go version: go1.13.8 Git commit: afacb8b7f0 Built: Wed Oct 14 19:43:43 2020 OS/Arch: linux/amd64 Experimental: false Server: Engine: Version: 19.03.8 API version: 1.40 (minimum version 1.12) Go version: go1.13.8 Git commit: afacb8b7f0 Built: Wed Oct 14 16:41:21 2020 OS/Arch: linux/amd64 Experimental: false containerd: Version: 1.3.3-0ubuntu2 GitCommit: runc: Version: spec: 1.0.1-dev GitCommit: docker-init: Version: 0.18.0 GitCommit: ","date":"2020-11-13","objectID":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E5%90%AF%E5%81%9C%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/:0:0","tags":["docker","container"],"title":"容器启停原理总结","uri":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E5%90%AF%E5%81%9C%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/"},{"categories":["Docker 原理总结"],"content":"1 启动 ","date":"2020-11-13","objectID":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E5%90%AF%E5%81%9C%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/:1:0","tags":["docker","container"],"title":"容器启停原理总结","uri":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E5%90%AF%E5%81%9C%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/"},{"categories":["Docker 原理总结"],"content":"1.1 Create 通过 docker create 命令可以创建一个容器，但是容器并不会真正的运行，其对应进程不会存在。 create 容器经过的具体流程为: 容器参数检查与调整； 容器对应的读写层（RWLayer）的创建； 容器元信息的记录（主要是配置信息）； (1) 容器参数检查与调整 检查容器运行参数是否合法，并调整一些参数的值，这一步不具体描述。 (2) 读写层的创建 容器的 “层” 可以分为： 读写层 ：保存容器对 rootfs 写、修改结果的层，并在容器退出后被 docker 删除； 例如，容器中对系统盘 root 目录中某个文件的修改，这个修改后的文件会被复制一份在系统盘上。 init 层 ：用于处理一些与镜像不绑定，但是与运行容器相关的文件修改，主要是 /etc/resolve.conf /etc/hosts 等； 为什么要有 init 层？我的理解是：镜像层（只读层）提供的是一个静态的环境，即所有容器看到的环境都是一样 而有些东西并不是想让所有容器看到的相同，例如 hostname、nameserver，这些 docker 都提供了参数配置，所docker 单独抽出了一个 “机器维度” 的只读层，init 层。 置于为什么不是在读写层修改，个人觉得是因为读写层是可以被 “导出” 的（docker save），而这些 /etresolve.conf 的内容又是不应该被导出的，所以放在了 init 层。 只读层 ：镜像包含的所有层，仅仅只读。对只读层任何修改都会以 COW 形式放在读写层。 具体读写层的概念这里不展开，可以阅读官方文档：storagedriver。 这里读写层的创建仅仅指的是创建了 init 层与读写层的目录，并没有做 union mount，毕竟容器没有运行嘛，没必要。 找个例子看一下： $ docker create --rm -t ubuntu 361c520da78f848d639d65f042fcf5d448c13cbc4ce8c251dcba2250162b48fe inspect 可以看到对应的读写层的目录： $ docker inspect 361c520da78f … \"GraphDriver\": { \"Data\": { \"LowerDir\": \"/var/lib/docker/overlay2/d063d1d9c81d0c72d7384ea999dbd77b33d04b942ef94a5aabc6fb6cf984194c-init/diff:/var/lib/docker/overlay2/0336c489d40e65588748265a95f18328ddb1f5bcb9ebf10909fbf3f5f35b9496/diff:/var/lib/docker/overlay2/77d3ac91877751678bfec0576dab39ccd4b73666f8040aef387ef47ff30b4cf1/diff:/var/lib/docker/overlay2/ec8326178c990b52970a65371fd375737fdf256db597aa821a2b0f7d79bcc6f3/diff:/var/lib/docker/overlay2/385038374d3d369e98724926d0e1c240dcb74e31b1663ec1cb434c43ca2826f1/diff\", \"MergedDir\": \"/var/lib/docker/overlay2/d063d1d9c81d0c72d7384ea999dbd77b33d04b942ef94a5aabc6fb6cf984194c/merged\", \"UpperDir\": \"/var/lib/docker/overlay2/d063d1d9c81d0c72d7384ea999dbd77b33d04b942ef94a5aabc6fb6cf984194c/diff\", \"WorkDir\": \"/var/lib/docker/overlay2/d063d1d9c81d0c72d7384ea999dbd77b33d04b942ef94a5aabc6fb6cf984194c/work\" }, \"Name\": \"overlay2\" }, … $ ls /var/lib/docker/overlay2/d063d1d9c81d0c72d7384ea999dbd77b33d04b942ef94a5aabc6fb6cf984194c/ diff link lower work 所有的层（包含容器、镜像）都位于 /var/lib/docker/[driver] 目录下，不过不同的 driver 有着不同的目录结构； 每个层的目录结构也和对应的 driver 有关，overlay2 中就会包含 diff、work 等子目录，而真正容器运行后看到的就是 diff 目录被挂载后的内容; 在 /var/lib/docker/overlay2/ 目录下，我们还可以看到一个同读写层类似名字的 “xxx-init” 目录，这就是 init 层目录，对应的 diff 子目录也是用于挂载的目录： $ ls /var/lib/docker/overlay2/d063d1d9c81d0c72d7384ea999dbd77b33d04b942ef94a5aabc6fb6cf984194c-init committed diff link lower work $ tree /var/lib/docker/overlay2/d063d1d9c81d0c72d7384ea999dbd77b33d04b942ef94a5aabc6fb6cf984194c-init/diff /var/lib/docker/overlay2/d063d1d9c81d0c72d7384ea999dbd77b33d04b942ef94a5aabc6fb6cf984194c-init/diff |-- dev | |-- console | |-- pts | `-- shm `-- etc |-- hostname |-- hosts |-- mtab -\u003e /proc/mounts `-- resolv.conf 但是这两个目录仅仅是被创建，如果执行 mount 命令可以看到，这些目录是没有被挂载的。 (3) 元信息的记录 执行 docker create 后，通过 docker ps -a 可以看到对应的容器，并且 inspect 可以看到对应的配置信息，因此，create 之后是有元信息的记录的。 而这个元信息就保存在 /var/lib/docker/containers 目录下，每个子目录的名字就是对应的容器 ID： $ cd /var/lib/docker/containers \u0026\u0026 ls 361c520da78f848d639d65f042fcf5d448c13cbc4ce8c251dcba2250162b48fe $ ls 361c520da78f848d639d65f042fcf5d448c13cbc4ce8c251dcba2250162b48fe checkpoints config.v2.json hostconfig.json config.v2.json 保存的就是对应的容器配置信息； 可以看到， /var/lib/docker/containers 目录就是所有容器信息的 “数据库”，这与层的概念是解耦的。 如果，你设置了 docker daemon 退出后不停止所有容器（默认情况 docker daemon 退出前会停止并删除所有容器，通过配置可以改变这个行为），那么 docker daemon 重新启动后，就会依靠这个目录进行 container 信息的恢复。 ","date":"2020-11-13","objectID":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E5%90%AF%E5%81%9C%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/:1:1","tags":["docker","container"],"title":"容器启停原理总结","uri":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E5%90%AF%E5%81%9C%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/"},{"categories":["Docker 原理总结"],"content":"1.2 Start 通过 docker start 命令运行一个容器，其主要的步骤如下： 状态检查，只有 Create 与 Stop 状态容器才可以被 Start； 进行容器 rootfs 的构建，这里会进行读写层、init 层、镜像层的 union mount； 容器网络构建； 调用 containerd 进行容器的启动； docker run 等同于 docker create + docker run，所以不需要特别说明。 (2) rootfs 的构建 rootfs 指定是容器最后看到的根文件系统，也就是 读写层 + init 层 + 镜像层经过 union mount 后的读写层。 我感觉，union mount 主要由两个特点： 统一视图 ：将各个层 “压扁”，最后得到一个层。而上下层之间相同的文件、目录，就会被上层的覆盖。 写时复制 ：对于整个视图的操作，只会影响最顶层（读写层），不会影响其他层，并且是写时复制的。 看一下具体示例： $ docker start 361c520da78f 361c520da78f 通过 mount 命令，可以看到对应容器的 union mount 已经出现： $ mount … overlay on /var/lib/docker/overlay2/d063d1d9c81d0c72d7384ea999dbd77b33d04b942ef94a5aabc6fb6cf984194c/merged type overlay (rw,relatime,lowerdir=/var/lib/docker/overlay2/l/O2TO66S3K4MTADSAAX6VXGTWSJ:/var/lib/docker/overlay2/l/UHTTQ5AJKPR23Y3V7J4ZLOIFDR:/var/lib/docker/overlay2/l/VWIFLRAQOPMH7LBAQQ5DDGIYVM:/var/lib/docker/overlay2/l/LQBRTVETGGWVU2OHWC42443K7X:/var/lib/docker/overlay2/l/5PDNI5HSOH6UMUDNWF4VMR46TS,upperdir=/var/lib/docker/overlay2/d063d1d9c81d0c72d7384ea999dbd77b33d04b942ef94a5aabc6fb6cf984194c/diff,workdir=/var/lib/docker/overlay2/d063d1d9c81d0c72d7384ea999dbd77b33d04b942ef94a5aabc6fb6cf984194c/work,xino=off) nsfs on /run/docker/netns/4500ea4f0025 type nsfs (rw) $ ls -lh /var/lib/docker/overlay2/l/O2TO66S3K4MTADSAAX6VXGTWSJ lrwxrwxrwx 1 root root 77 Nov 14 15:51 /var/lib/docker/overlay2/l/O2TO66S3K4MTADSAAX6VXGTWSJ -\u003e ../d063d1d9c81d0c72d7384ea999dbd77b33d04b942ef94a5aabc6fb6cf984194c-init/diff 第一个挂载信息看出，将 init 层与镜像层的目录挂载到了读写的 merged 目录； 后面执行的命令看待，使用的 /var/lib/docker/overlay2/l/O2TO66S3K4MTADSAAX6VXGTWSJ 这样的目录是软链，指向前面说的对应的各个层的目录，因为整个层的名字太长，所以使用软链别名让挂载属性短一些； (3) 容器网络构建 首先明确，先有网络环境，再有的容器运行。也就是说，是容器中的进程加入一个特定的 net namespace。所以，网络环境的构建的目标就是：得到一个配好网络的 net namespace。 所以网络构建可以分为三个大概的步骤： 创建一个新的 net namespace； 在这个 net namespace 里操作，构建好网络； 保留这个 net namesapce； 如何 “配好网络的 net namespace” 就和具体的网络模式有关了，具体见：容器网络总结。 默认下，当一个 namespace 中没有任何进程时，该 namespace 就自动被内核销毁了（垃圾回收），而要将一个 namespace 持久化，就需要将其挂载到一个具体文件，这样该 net namespace 就会保留。 因此，docker 会通过这种方式先保留 net namespace，并让容器运行后的进程可以加入。当容器停止是，docker 将其手动删除。 通过 mount 命令，你可以看到对应容器的 net namespace 的挂载会随着容器运行出现。 $ mount … nsfs on /run/docker/netns/4500ea4f0025 type nsfs (rw) … 当然，上面说的 “构建网络”，“挂载文件”，包括 “namespace 文件如何映射到对应的容器” 这些行为与信息，都是由 libnetwork 库中负责的。 Tip 看 libnetwork 源码时发现一点，当某个代码需要进入 namespace，一定需要将当前 goroutine 与 thread 绑定（runtime.LockOSThread()）接口。 Why ？举个例子，一段代码由 G1 groutine 绑定到了 T1 线程执行，创建了 N1 namespace，并且期望在 N1 namespace 下执行。但是代码运行中，可能由于 Go 的调度，变成了 G1 groutine 绑定到 T2 线程执行。这时，就切换了 namespace 了，代码也就不是在期望的 namespace 下执行，这可能带来很大的问题。 (4) 调用 containerd 启动容器 docker daemon 在设计到容器进程的运行时，都是交给 containerd，然后 containerd 调用 shim，shim 调用 runc 库执行。 真正容器内进程怎么运行还包括很多内容，特别是 runc 如何调整进程 namespace，如何启动进程这些内容，这里不再深入说。 如果有空，等后面出个文章详述（挖坑。 ","date":"2020-11-13","objectID":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E5%90%AF%E5%81%9C%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/:1:2","tags":["docker","container"],"title":"容器启停原理总结","uri":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E5%90%AF%E5%81%9C%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/"},{"categories":["Docker 原理总结"],"content":"2 停止 ","date":"2020-11-13","objectID":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E5%90%AF%E5%81%9C%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/:2:0","tags":["docker","container"],"title":"容器启停原理总结","uri":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E5%90%AF%E5%81%9C%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/"},{"categories":["Docker 原理总结"],"content":"2.1 Stop stop 的步骤就是对 run 操作的回滚，包括： 停止容器的运行； 销毁容器网络； 解除容器读写层的挂载； 其中第 2、3 步就是反着来操作，没啥好说的。 (1) 停止容器运行 停止容器运行，其实就是停止容器内所有进程的运行。 有趣的是停止容器运行的过程里，并没有使用 runc 库，而是在 shim 这一层中，对 shim 进程发送信号。这一块也是后面细说。 大致的停止流程就是下面两步： 发送 配置/默认(SIGTERM) 的停止信号； 上一步停止失败/超时，那么就发送 SIGKILL 信号； ","date":"2020-11-13","objectID":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E5%90%AF%E5%81%9C%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/:2:1","tags":["docker","container"],"title":"容器启停原理总结","uri":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E5%90%AF%E5%81%9C%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/"},{"categories":["Docker 原理总结"],"content":"2.2 Remove 老样子，操作的逆向，这也没啥好说的。 删除对应读写层目录与 init 层目录； 删除对应的容器元信息； ","date":"2020-11-13","objectID":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E5%90%AF%E5%81%9C%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/:2:2","tags":["docker","container"],"title":"容器启停原理总结","uri":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E5%90%AF%E5%81%9C%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/"},{"categories":["Docker 原理总结"],"content":"3 暂停与恢复 ","date":"2020-11-13","objectID":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E5%90%AF%E5%81%9C%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/:3:0","tags":["docker","container"],"title":"容器启停原理总结","uri":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E5%90%AF%E5%81%9C%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/"},{"categories":["Docker 原理总结"],"content":"3.1 Pause 与 Resume Pause 操作的原理很简单，通过 cgroup.freezer 冻结进程的运行，也就是不让进程被内核调度运行。 在容器运行状态，读取对应 cgroup 的 freezer.state 文件可以看到是 THAWED 状态。 $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES f4b92a61851a ubuntu \"/bin/bash\" 2 seconds ago Up 1 second host_container $ cat /sys/fs/cgroup/freezer/docker/f4b92a61851a7f5f85569318c830722c275796b36d34a506eae05b547b31cb7c/freezer.state THAWED 执行 docker pause 后，看到对应的 freezer.state 变为 FROZEN，表明被冻结了。 $ docker pause host_container host_container $ cat /sys/fs/cgroup/freezer/docker/f4b92a61851a7f5f85569318c830722c275796b36d34a506eae05b547b31cb7c/freezer.state FROZEN 执行 docker unpause 恢复运行后，对应状态又变为了 THAWED： $ docker unpause host_container $ cat /sys/fs/cgroup/freezer/docker/f4b92a61851a7f5f85569318c830722c275796b36d34a506eae05b547b31cb7c/freezer.state THAWED 而这个状态的变化，其实就是通过 echo \"\u003cstate\u003e\" \u003e freezer.state 实现的。 ","date":"2020-11-13","objectID":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E5%90%AF%E5%81%9C%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/:3:1","tags":["docker","container"],"title":"容器启停原理总结","uri":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E5%90%AF%E5%81%9C%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/"},{"categories":["Docker 原理总结"],"content":"描述 docker 下容器网络模型与实现","date":"2020-11-06","objectID":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/","tags":["docker","container"],"title":"容器网络总结","uri":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/"},{"categories":["Docker 原理总结"],"content":"1 概览 docker 容器网络目前包含 5 中模式，包括： bridge：默认的网络模式，使用 bridge 虚拟网卡 + iptables 实现一个内地内网，所有容器都处于该内网内，并且可以相互访问； host：与宿主机处于同一个 net namespace，使用宿主机网络环境； overlay：在多个 docker daemon 之间建立 overlay 网络，使得不同 docker daemon 的容器之间可以相互通信； macvlan：使用 macvlan 虚拟网卡，将容器物理地址暴露在宿主机局域网中，你可以认为就是一台同局域网的物理机； none：不进行任何网络配置，通常与自定义网络 driver 配合使用； 除了上述模式之外，每个容器也可以加入其它容器的网络中（通过加入对应的 net namespace）。 docker 还支持使用自定义的网络插件，这块不了解，具体见官方文档。 下面所有示例都在虚拟机 ubuntu 20.04 与内核 5.4.0-52-generic 中完成，docker 版本如下： $docker version Client: Version: 19.03.8 API version: 1.40 Go version: go1.13.8 Git commit: afacb8b7f0 Built: Wed Oct 14 19:43:43 2020 OS/Arch: linux/amd64 Experimental: false Server: Engine: Version: 19.03.8 API version: 1.40 (minimum version 1.12) Go version: go1.13.8 Git commit: afacb8b7f0 Built: Wed Oct 14 16:41:21 2020 OS/Arch: linux/amd64 Experimental: false containerd: Version: 1.3.3-0ubuntu2 GitCommit: runc: Version: spec: 1.0.1-dev GitCommit: docker-init: Version: 0.18.0 GitCommit: ","date":"2020-11-06","objectID":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/:1:0","tags":["docker","container"],"title":"容器网络总结","uri":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/"},{"categories":["Docker 原理总结"],"content":"2 背景知识 ","date":"2020-11-06","objectID":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/:2:0","tags":["docker","container"],"title":"容器网络总结","uri":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/"},{"categories":["Docker 原理总结"],"content":"2.1 cgroup 与 namespace 这部分网上知识很多，这里就不复制别人的了。 ","date":"2020-11-06","objectID":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/:2:1","tags":["docker","container"],"title":"容器网络总结","uri":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/"},{"categories":["Docker 原理总结"],"content":"2.2 docker 如何使用 net namespace namespace 用于各个进程间的环境的隔离，而容器运行（非 host 与 container 模式）的就是处于一个独立的 net namespace。 当处于一个 net namespace 时，可以认为，内核协议栈、iptables(net_filter)、网络设备等与其他 net namespace 都是隔离的。（这里只是说可以这么认为，但是真正还是只有一个内核，内核为 namespace 做了逻辑上的隔离） 在容器运行之间，docker 就会创建容器对应的 net namespace，并构建好对应的网络，然后将其 ‘持久化’（因为默认 namespace 是随着进程消失而消失的，如果想进程消失而 namespace 存在，那么需要将其 mount 到一个文件上）。 例如，当我们创建了一个容器后，可以看到这么一个挂载： $ mount … nsfs on /run/docker/netns/9779108cb6b0 type nsfs (rw) 该文件就是对应 net namespace 的挂载，通过对比容器进程的 netns inode 与 文件 inode 可以证明： $ docker top br0_container UID PID PPID C STIME TTY TIME CMD root 92658 92640 0 Nov06 pts/0 00:00:00 /bin/bash $ ls -lhi /proc/92658/ns/net 474863 lrwxrwxrwx 1 root root 0 Nov 7 12:42 /proc/92658/ns/net -\u003e 'net:[4026532287]' # 文件 inode 与进程 net 指向 inode 相同 $ ls -lhi /run/docker/netns/9779108cb6b0 4026532287 -r--r--r-- 1 root root 0 Nov 6 19:47 /run/docker/netns/9779108cb6b0 在容器被删除后，对应 net namespace 就会被销毁。 而各个网络模式最大的不同，就是在于 namespace 创建后，对应的 “构建网络” 的操作了。 ","date":"2020-11-06","objectID":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/:2:2","tags":["docker","container"],"title":"容器网络总结","uri":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/"},{"categories":["Docker 原理总结"],"content":"2.3 bridge 虚拟网络设备 bridge 网络设备 相当于一个 “交换机”，让任何其他网络设备链接上 bridge 时，所有包的都会无条件经过 bridge 转发，而链接的网络设备就变成了一根 “网线”。 不过与真实的交换机不同，brdige 网卡可以被赋值 IP，当 bridge 拥有 IP 后，它就与内核协议栈连接了，因此接收到的包可以到达内核协议栈的 IP 层处理，也就会经过 net_filter 处理。 推荐阅读 bridge 网卡推荐阅读：Linux虚拟网络设备之bridge(桥) ","date":"2020-11-06","objectID":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/:2:3","tags":["docker","container"],"title":"容器网络总结","uri":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/"},{"categories":["Docker 原理总结"],"content":"2.4 veth-pair 虚拟网络设备 veth-pair 设备 总是成对的出现，当数据包进入一端 veth 设备时，会从另一端 veth 设备出。veth-pair 两个设备可以处于不同的 net namespace，也就可以实现不同 net namespace 间数据传输。 默认下，veth 设备链接的两端是内核协议栈。不过 veth 设备链接上 bridge，这样另一端发送的数据都会由 bridge 处理。 推荐阅读 veth-pair 设备了解推荐文章：Linux虚拟网络设备之veth ","date":"2020-11-06","objectID":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/:2:4","tags":["docker","container"],"title":"容器网络总结","uri":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/"},{"categories":["Docker 原理总结"],"content":"2.5 macvlan 虚拟网络设备 macvlan 网络设备 可以有 mac 地址与 ip 地址，用于将 net namespace 连接到宿主机的物理网络中，相当于，容器直接连接着物理网络。 macvlan 网络设备有着多种的模式，包括：bridge、private 等，这影响着各个 macvlan 网络设备之间的通信。 更过 macvlan 网络设备推荐文章：Linux interfaces for virtual networking ","date":"2020-11-06","objectID":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/:2:5","tags":["docker","container"],"title":"容器网络总结","uri":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/"},{"categories":["Docker 原理总结"],"content":"3 Bridge 网络 ","date":"2020-11-06","objectID":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/:3:0","tags":["docker","container"],"title":"容器网络总结","uri":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/"},{"categories":["Docker 原理总结"],"content":"3.1 创建/删除 Bridge 网络 (1) 创建网络 先试着创建一个自定义的 bridge 网络，观察 docker 会对应创建哪些东西。 $ docker network create --driver=bridge \\ --subnet=192.168.100.0/24 \\ --ip-range=192.168.100.0/26 \\ --gateway=192.168.100.1 \\ --opt com.docker.network.bridge.name=mybr0 \\ mybridge0 2e61a7dc333c1bc61d9cb86503ce4cd5a7435977ea2f9b7cc97fc71ae0e2bb93 --driver=bridge 指定创建的网络 driver； --subnet=192.168.100.0/24 指定对应 bridge 网络的网段； --ip-range=192.168.100.0/26 指定运行分配给容器的 ip 范围，当然，这个是要在指定的网段内的； --gateway=192.168.100.1 指定该内网的网关 IP； --opt com.docker.network.bridge.name=mybr0 指定创建虚拟 bridge 网卡的命名； mybridge0 为创建的 docker network 的命名； 通过 ifconfig 可以看到，bridge 网络创建会对应创建一个 bridge 网络设备，作为整个内网的 ‘交换机’。其 IP 就是指定的 gateway IP。 $ ifconfig … mybr0: flags=4099\u003cUP,BROADCAST,MULTICAST\u003e mtu 1500 inet 192.168.100.1 netmask 255.255.255.0 broadcast 192.168.100.255 ether 02:42:46:8a:cf:34 txqueuelen 0 (Ethernet) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 … $ brctl show bridge name bridge id STP enabled interfaces mybr0 8000.0242efdb0984 no 但是与虚拟机网络中的 bridge 网卡不同，该 bridge 不会连接任何的物理网卡，仅仅是作为内网的 ‘交换机’ 使用。但是，毕竟内网是虚拟的，没有实际与物理网络连接，如何访问外网呢？ 答案是，通过内核 iptables 进行 NAT，然后将包从实际的物理网卡上发送与接受。因此还有一部分的改变在于 iptables，主要会建立的是 nat 与 filter 表的规则。 先看 nat 表的相关规则（下面输出中省略了不相关规则）： $ iptables -t nat -L -nv Chain PREROUTING (policy ACCEPT 2 packets, 88 bytes) target prot opt in out source destination DOCKER all -- * * 0.0.0.0/0 0.0.0.0/0 ADDRTYPE match dst-type LOCAL Chain INPUT (policy ACCEPT 2 packets, 88 bytes) target prot opt in out source destination Chain OUTPUT (policy ACCEPT 124 packets, 8797 bytes) target prot opt in out source destination DOCKER all -- * * 0.0.0.0/0 !127.0.0.0/8 ADDRTYPE match dst-type LOCAL Chain POSTROUTING (policy ACCEPT 124 packets, 8797 bytes) target prot opt in out source destination MASQUERADE all -- * !mybr0 192.168.100.0/24 0.0.0.0/0 Chain DOCKER (2 references) target prot opt in out source destination RETURN all -- mybr0 * 0.0.0.0/0 0.0.0.0/0 PREROUTING 与 OUTPUT 链中规则，使得所有入和出的包都会经过 DOCKER 链； POSTROUTING 链中，将 mybridge0 网络（192.168.100.0/24）的内网 ip 通过 MASQUERADE 行为进行伪装（可以简单认为内网 ip 会变为当前网卡的 ip）； 当然，如果包发往的是 mybr0 网卡，说明是 mybridge0 网络内部通信，就不需要进行 MASQUERADE 伪装（!mybr0）； 当容器发包时，会通过 mybr0 网卡转发进入内核栈，因此在 filter 表中，相关的规则都是针对于 “in=mybr0”。看一下 filter 表的规则： $ iptables -t filter -L -nv Chain INPUT (policy ACCEPT 61774 packets, 79M bytes) Chain FORWARD (policy ACCEPT 0 packets, 0 bytes) target prot opt in out source destination DOCKER-USER all -- * * 0.0.0.0/0 0.0.0.0/0 DOCKER-ISOLATION-STAGE-1 all -- * * 0.0.0.0/0 0.0.0.0/0 ACCEPT all -- * mybr0 0.0.0.0/0 0.0.0.0/0 ctstate RELATED,ESTABLISHED DOCKER all -- * mybr0 0.0.0.0/0 0.0.0.0/0 ACCEPT all -- mybr0 !mybr0 0.0.0.0/0 0.0.0.0/0 ACCEPT all -- mybr0 mybr0 0.0.0.0/0 0.0.0.0/0 Chain OUTPUT (policy ACCEPT 42290 packets, 55M bytes) target prot opt in out source destination Chain DOCKER (2 references) target prot opt in out source destination Chain DOCKER-ISOLATION-STAGE-1 (1 references) target prot opt in out source destination DOCKER-ISOLATION-STAGE-2 all -- mybr0 !mybr0 0.0.0.0/0 0.0.0.0/0 RETURN all -- * * 0.0.0.0/0 0.0.0.0/0 Chain DOCKER-ISOLATION-STAGE-2 (2 references) target prot opt in out source destination DROP all -- * mybr0 0.0.0.0/0 0.0.0.0/0 RETURN all -- * * 0.0.0.0/0 0.0.0.0/0 Chain DOCKER-USER (1 references) target prot opt in out source destination RETURN all -- * * 0.0.0.0/0 0.0.0.0/0 FORWARD -\u003e DOCKER-ISOLATION-STAGE-1 -\u003e DOCKER-ISOLATION-STAGE-2 表明允许包从 mybr0 进入并转发（即容器可以向外正常发包）； FORWARD 中对 mybr0 进入的包设置了 conntrack，使得能够收到连接建立后的正常的回包； (2) 删除网络 通过 docker network remove 删除网络时，会发现对应的 bridge 网卡与 iptables 规则都被删除。 $ docker network remove 5a17670afb6f 5a17670afb6f ","date":"2020-11-06","objectID":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/:3:1","tags":["docker","container"],"title":"容器网络总结","uri":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/"},{"categories":["Docker 原理总结"],"content":"3.2 启动容器后的网络 下面看下容器启停后，带来的网络变化。先启动最简单的一个容器，指定使用网络为上面创建的 mybridge0。 $ docker run -dt --rm --network=mybridge0 --name br0_container ubuntu 676f7f9eab12a20fb3a975fa99cc2c92433a9581b5774ea58e63d447d86aa5ad $ docker inspect 676f7f9eab12 … \"Networks\": { \"mybridge0\": { \"IPAMConfig\": null, \"Links\": null, \"Aliases\": [ \"882cac3e472f\" ], \"NetworkID\": \"af1dbf619ac62be1ad8a6b63696d3e6edff77cceab6cd0ee78de4b51e0d33683\", \"EndpointID\": \"56cd85c5121d7d14146fcacc75599f6c56034e758e81f405a51437276ac6ac9f\", \"Gateway\": \"192.168.100.1\", \"IPAddress\": \"192.168.100.2\", \"IPPrefixLen\": 24, \"IPv6Gateway\": \"\", \"GlobalIPv6Address\": \"\", \"GlobalIPv6PrefixLen\": 0, \"MacAddress\": \"02:42:c0:a8:64:02\", \"DriverOpts\": null } } … --network=mybridge0 表明以 mybridge0 网络启动容器； 观察容器具体参数，可以看到，容器被随机分配 mybridge0 设置的 ip-range 一个 ip，并且 gateway 就是 mybridge0 网络的网关地址； 观察网络设备，可以看到一个 veth-pair 设备 出现在宿主机上，并且连接到了 mybr0 网卡： $ ifconfig … vethef6b174: flags=4163\u003cUP,BROADCAST,RUNNING,MULTICAST\u003e mtu 1500 inet6 fe80::e8ad:86ff:fefe:14ca prefixlen 64 scopeid 0x20\u003clink\u003e ether ea:ad:86:fe:14:ca txqueuelen 0 (Ethernet) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 23 bytes 1882 (1.8 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 … $ brctl show bridge name bridge id STP enabled interfaces mybr0 8000.0242efdb0984 no vethef6b174 veth-pair 都是成对出现的，可以简单被看做一个通道，一端发入的包会从另一端发出，并进入内核协议栈。不过，在 bridge 网络环境下，veth5b480f8 连接到 mybr0，所以所有从 veth5b480f8 发出的包都会被 mybr0 接手转发（相当于就是一根网线插入了交换机）。 可以进入容器 namespace，看一下容器内的 veth 设备。 $ docker exec -it br0_container bash # 以下在容器 namesapce 环境执行 root@676f7f9eab12:/# ifconfig eth0: flags=4163\u003cUP,BROADCAST,RUNNING,MULTICAST\u003e mtu 1500 inet 192.168.100.2 netmask 255.255.255.0 broadcast 192.168.100.255 ether 02:42:c0:a8:64:02 txqueuelen 0 (Ethernet) RX packets 1928 bytes 21609413 (21.6 MB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 1817 bytes 102779 (102.7 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 root@676f7f9eab12:/sys/class/net/eth0# ethtool -i eth0 driver: veth version: 1.0 firmware-version: expansion-rom-version: bus-info: supports-statistics: yes supports-test: no supports-eeprom-access: no supports-register-dump: no supports-priv-flags: no root@676f7f9eab12:~# cat /sys/class/net/eth0/iflink 15 在容器内的仅仅有一个 eth0 网卡，ip 设置为了容器的 ip。但是其实这个网卡就是 veth 设备改了名字； 通过 ethtool -i eth0 命令看到，其对应 driver 是 veth，并且 /sys/class/net/eth0/iflink 文件表明了对端的 veth 网卡编号为 15（即宿主机看到的 veth 网卡设备）； 现在，我们试着启动容器并添加一个 tcp 端口映射。 $ docker run -dt --rm \\ --network=mybridge0 --publish 12211:8080 \\ --name br0_container ubuntu 2502f7397a37e2ab482f8a9152d1ed968dd2e2825c71eb2a6737e4900f7236c1 而这个端口映射，就是将宿主机的 12211 端口映射给容器的 8080，所以所有发往宿主机的 12211 端口的包，都会被修改端口并转发到容器内部。这也是通过 iptables 实现的： iptables -t nat -L -nv Chain PREROUTING (policy ACCEPT 0 packets, 0 bytes) target prot opt in out source destination DOCKER all -- * * 0.0.0.0/0 0.0.0.0/0 ADDRTYPE match dst-type LOCAL Chain INPUT (policy ACCEPT 0 packets, 0 bytes) target prot opt in out source destination Chain OUTPUT (policy ACCEPT 0 packets, 0 bytes) target prot opt in out source destination DOCKER all -- * * 0.0.0.0/0 !127.0.0.0/8 ADDRTYPE match dst-type LOCAL Chain POSTROUTING (policy ACCEPT 0 packets, 0 bytes) pkts bytes target prot opt in out source destination 10 617 MASQUERADE all -- * !mybr0 192.168.100.0/24 0.0.0.0/0 0 0 MASQUERADE tcp -- * * 192.168.100.2 192.168.100.2 tcp dpt:8080 Chain DOCKER (2 references) pkts bytes target prot opt in out source destination 0 0 RETURN all -- mybr0 * 0.0.0.0/0 0.0.0.0/0 0 0 DNAT tcp -- !mybr0 * 0.0.0.0/0 0.0.0.0/0 tcp dpt:12211 to:192.168.100.2:8080 PREROUTING -\u003e DOCKER 链中，所有不是从 mybr0 进入的包，并且发往 tcp 12211 端口的包，都会被 DNAT 为发往 192.168.100.2:8080。这样就实现了端口映射的功能。 ","date":"2020-11-06","objectID":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/:3:2","tags":["docker","container"],"title":"容器网络总结","uri":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/"},{"categories":["Docker 原理总结"],"content":"3.3 bridge 网络总结 中心思想：bridge 网络使用 bridge 网卡创建了一个本地的内网，而 bridge 网卡 + iptables 规则成为了这个内网的 ‘路由器'。其中: bridge 网卡作为二层的交换机，bridge 网卡 ip 作为路由器的网关 ip。 iptables 规则实现了 brdige 网卡与物理网络的连接 宿主机内核栈实现了这个 ‘路由器’ 的路由功能。 下图展示了整个 bridge 网络的模型（图片来自网络）： 其中比较关键的点： veth pair 设备将容器 net namespace 连接到 bridge 网卡（可以看做将 veth pair 作为网线插到了 bridge 这个 ‘路由器’ 上）。 iptables 实现了 bridge 网卡与物理网络的 ‘连接’。 bridge 网卡收到的包，经过 iptables 的 MASQUERADE 将包进行地址转换，并经过内核协议栈的路由通过物理网卡发送到物理网络。而回包通过 conntrack 机制正常接收与逆地址转换。 容器与宿主机的端口映射，也是通过 iptables 的 DNAT 实现的。 ","date":"2020-11-06","objectID":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/:3:3","tags":["docker","container"],"title":"容器网络总结","uri":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/"},{"categories":["Docker 原理总结"],"content":"4 Host 网络 Host 网络没啥好说的，启动容器不创建新的 namespace，依旧在宿主机的 net namespace 下。 $ docker run -dt --rm --network=host --name host_container ubuntu da1c426a7c7501b329258b12cb475ff42669837ca686d6e946511632461cc946 观察 mount，可以看到对应还是有 net namespace 的文件挂载，文件名为 default： $ mount … nsfs on /run/docker/netns/default type nsfs (rw) 文件 inode 对比当前宿主机 net namespace inode，是一致的： $ ls -lh /proc/self/ns/net lrwxrwxrwx 1 root root 0 Nov 7 14:47 /proc/self/ns/net -\u003e 'net:[4026531992]' $ ls -lhi /run/docker/netns/default 4026531992 -r--r--r-- 1 root root 0 Oct 30 16:50 /run/docker/netns/default ","date":"2020-11-06","objectID":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/:4:0","tags":["docker","container"],"title":"容器网络总结","uri":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/"},{"categories":["Docker 原理总结"],"content":"5 macvlan 网络 macvlan 网络使用 macvlan 虚拟网络设备，将容器 net namespace 网络暴露在与当前宿主机同级的局域网内，相当于容器就是当前网络内的一台 “主机”。 macvlan 网络设备也包括多种模式：bridge mode、802.1q trunk bridge mode。下面示例都是基于普通的 brdige mode。 因为 macvlan 网络在虚拟机网络下不太好验证，所以下面例子来自于一台物理机上。 ","date":"2020-11-06","objectID":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/:5:0","tags":["docker","container"],"title":"容器网络总结","uri":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/"},{"categories":["Docker 原理总结"],"content":"5.1 创建/删除 macvlan 网络 通过 docker network create 创建 macvlan 网络。 $ docker network create -d macvlan \\ --subnet=192.168.67.130/24 --gateway=192.168.67.1 \\ -o parent=eth0 mymacvlan0 633aae3d4f430352e5439e2650c02fe9c2092b99b5b8252f8141fa5d62ec7e70 -d macvlan，指定 macvlan 网络 -subnet=192.168.67.130/24，因为 macvlan 网络下的容器会直接连入物理网络，所以子网也是要在当前子网内； --gateway=192.168.67.1，同样，gateway 就是宿主机的网关地址； -o parent=eth0，指定 macvlan 设备链接的物理网卡，一定要是一个真正可联网的物理网卡； 不过与 bridge 网络不同的是，创建一个 macvlan 网络仅仅是记录其对应的配置，不会创建对应的 macvlan 网卡或者 iptables 规则。因为 macvlan 网卡是与 net namespace 绑定的，所以当创建 net namespace 时才会出现对应网络设备。 ","date":"2020-11-06","objectID":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/:5:1","tags":["docker","container"],"title":"容器网络总结","uri":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/"},{"categories":["Docker 原理总结"],"content":"5.2 启停容器后的网络 $ docker run --net=mymacvlan0 \\ -dt --rm --name macvlan_container \\ --ip=192.168.67.139 --privileged \\ centos_ctr bash 2eff4835733734b6819c7f97ae41585985d95c1ea4c66a6a478a43e71b60b6d6 启动容器，如果不指定 IP，Docker 会在配置的网段里分配一个。 tip 为了能够方便排查网络问题，使用的容器镜像 centos_ctr 是由 centos 镜像以 host 网络启动，预装一些命令后，才由容器导出的镜像。 但是发现进入容器后，发现静态配置 IP 无法 ping 通网关（宿主机是正常无法 ping 通，因为内核会丢弃 macvlan 网卡的包）。研究后不清楚具体原因，但是这台宿主机接的是交换机，不知道是不是不是路由器导致的。 $ docker exec -it macvlan_container bash # 以下是容器中命令 [root@2eff48357337 /]# ifconfig eth0: flags=4163\u003cUP,BROADCAST,RUNNING,MULTICAST\u003e mtu 1500 inet 192.168.67.139 netmask 255.255.255.0 broadcast 192.168.67.255 ether 02:42:c0:a8:43:8b txqueuelen 0 (Ethernet) RX packets 433282 bytes 27463954 (26.1 MiB) RX errors 0 dropped 26809 overruns 0 frame 0 TX packets 91342 bytes 6649728 (6.3 MiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 [root@2eff48357337 /]# ping 192.168.67.1 PING 192.168.67.1 (192.168.67.1) 56(84) bytes of data. From 192.168.67.139 icmp_seq=1 Destination Host Unreachable From 192.168.67.139 icmp_seq=2 Destination Host Unreachable 因此，换个思路，静态 IP 不行，就通过 DHCP 获取一个 IP 尝试是否能够连通网络。 在删除静态 IP 之后，调用 dhclient 从上层路由器获取一个 IP。 # 删除 eth0 网卡 IP [root@2eff48357337 /]# ip address del 192.168.67.139 dev eth0 Warning: Executing wildcard deletion to stay compatible with old scripts. Explicitly specify the prefix length (192.168.67.139/32) to avoid this warning. This special behaviour is likely to disappear in further releases, fix your scripts! [root@2eff48357337 /]# ifconfig eth0: flags=4163\u003cUP,BROADCAST,RUNNING,MULTICAST\u003e mtu 1500 ether 02:42:c0:a8:43:8b txqueuelen 0 (Ethernet) RX packets 435540 bytes 27608133 (26.3 MiB) RX errors 0 dropped 26983 overruns 0 frame 0 TX packets 91763 bytes 6678670 (6.3 MiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 # 调用 dhclient 获取新的 IP [root@2eff48357337 /]# dhclient -r \u0026\u0026 dhclient -v Removed stale PID file Internet Systems Consortium DHCP Client 4.3.6 Copyright 2004-2017 Internet Systems Consortium. All rights reserved. For info, please visit https://www.isc.org/software/dhcp/ Listening on LPF/eth0/02:42:c0:a8:43:8b Sending on LPF/eth0/02:42:c0:a8:43:8b Sending on Socket/fallback DHCPDISCOVER on eth0 to 255.255.255.255 port 67 interval 3 (xid=0xdf4e0e25) DHCPREQUEST on eth0 to 255.255.255.255 port 67 (xid=0xdf4e0e25) DHCPOFFER from 192.168.9.253 DHCPACK from 192.168.9.253 (xid=0xdf4e0e25) System has not been booted with systemd as init system (PID 1). Can't operate. Failed to create bus connection: Host is down bound to 192.168.9.235 -- renewal in 38783 seconds. [root@2eff48357337 /]# ifconfig eth0: flags=4163\u003cUP,BROADCAST,RUNNING,MULTICAST\u003e mtu 1500 inet 192.168.9.235 netmask 255.255.255.0 broadcast 192.168.9.255 ether 02:42:c0:a8:43:8b txqueuelen 0 (Ethernet) RX packets 435635 bytes 27614880 (26.3 MiB) RX errors 0 dropped 27001 overruns 0 frame 0 TX packets 91767 bytes 6679438 (6.3 MiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 [root@2eff48357337 /]# route -n Kernel IP routing table Destination Gateway Genmask Flags Metric Ref Use Iface 0.0.0.0 192.168.9.253 0.0.0.0 UG 0 0 0 eth0 192.168.9.0 0.0.0.0 255.255.255.0 U 0 0 0 eth0 可以看到，DHCP 获得的 IP 与宿主机都不是同一个网段的，并且网关地址也不是同一个，因此上层连着交换机有多个网段（这块不太理解了）。 但是，测试后是可以 ping 通网关，并且可以访问外网的： [root@2eff48357337 /]# ping 192.168.9.253 PING 192.168.9.253 (192.168.9.253) 56(84) bytes of data. 64 bytes from 192.168.9.253: icmp_seq=1 ttl=64 time=0.637 ms 64 bytes from 192.168.9.253: icmp_seq=2 ttl=64 time=0.250 ms ","date":"2020-11-06","objectID":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/:5:2","tags":["docker","container"],"title":"容器网络总结","uri":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/"},{"categories":["Docker 原理总结"],"content":"5.3 总结 中心思想：将 macvlan 网络启动容器看做一个与宿主机同级的网络，其获取 IP 方式都与正常的机器相同。 ","date":"2020-11-06","objectID":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/:5:3","tags":["docker","container"],"title":"容器网络总结","uri":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/"},{"categories":["Docker 原理总结"],"content":"参考 Docker 容器网络官方文档 Linux虚拟网络设备之bridge(桥) Linux interfaces for virtual networking ","date":"2020-11-06","objectID":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/:6:0","tags":["docker","container"],"title":"容器网络总结","uri":"/posts/cloud_computing/how_docker_work/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/"},{"categories":["VM"],"content":"制作虚拟机镜像","date":"2020-10-31","objectID":"/posts/cloud_computing/vm/%E5%88%B6%E4%BD%9C%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%95%9C%E5%83%8F/","tags":["虚拟机","KVM","云计算"],"title":"制作虚拟机镜像","uri":"/posts/cloud_computing/vm/%E5%88%B6%E4%BD%9C%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%95%9C%E5%83%8F/"},{"categories":["VM"],"content":"中心思想：通过 libvirt 运行一个虚拟机（domain），并保存其对应的 domain 的镜像文件与配置文件，然后就可以在其他机器通过 virsh define + start 或者 virt-install 启动。 说明：下面环境都是在 centos 上制作基于 KVM 的虚拟机镜像。 ","date":"2020-10-31","objectID":"/posts/cloud_computing/vm/%E5%88%B6%E4%BD%9C%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%95%9C%E5%83%8F/:0:0","tags":["虚拟机","KVM","云计算"],"title":"制作虚拟机镜像","uri":"/posts/cloud_computing/vm/%E5%88%B6%E4%BD%9C%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%95%9C%E5%83%8F/"},{"categories":["VM"],"content":"1 从 ISO 镜像安装 最基本的安装方式，通过安装并运行一个新的虚拟机，然后得到对应的配置文件与镜像文件。 ","date":"2020-10-31","objectID":"/posts/cloud_computing/vm/%E5%88%B6%E4%BD%9C%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%95%9C%E5%83%8F/:1:0","tags":["虚拟机","KVM","云计算"],"title":"制作虚拟机镜像","uri":"/posts/cloud_computing/vm/%E5%88%B6%E4%BD%9C%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%95%9C%E5%83%8F/"},{"categories":["VM"],"content":"1.1 手动安装 最基本的安装方式，通过 ISO 文件进行安装。 下载 ISO 镜像文件，镜像文件在各个镜像站中就可以找到。（因为不使用图形界面，所以下载的是非图形化的 ISO） 通过 virt-install 命令安装镜像（因为使用的是非图形化的安装，所以参数有一些不一样） virt-install --name guest1_fromiso --memory 2048 --vcpus 2 \\ --disk size=8 --location CentOS-7-x86_64-DVD-2003.iso \\ --os-type Linux --os-variant=centos7.0 --virt-type kvm \\ --boot menu=on --graphics none --console pty --extra-args 'console=ttyS0' 其中要注意几个参数： 因为我们是安装非图形化，所以需要 --location 参数指定 iso，并指定 --boot menu=on 打开安装菜单，最后还需要指定安装信息的输出 --console pty --extra-args 'console=ttyS0' 这样安装菜单才能正常展示出来 --graphics none 指定非图形化； --network bridge=virbr0，指定网络模式，这里指定 libvirt 默认创建的 bridge 网卡，可以认为这是一个 libvirt 维护内网，安装时选择 dhcp 就可以获得一个可用的内网地址； 具体 libvirt 的网络模型，后面在单独研究下。 -- disk size=8，disk 参数用于指定系统盘，这里指定自动创建一个 8G 的 qcow2 文件，作为系统盘（默认镜像文件保存在 /var/lib/libvirt/images/）目录下； 这时就会进入虚拟机的安装步骤，具体安装步骤就不赘述了。 安装成功后，可以看到 domain 就被创建了，这就可以得到它的配置文件与镜像文件了。 $ virsh list Id Name State ---------------------------------------------------- 18 guest1_fromiso running ","date":"2020-10-31","objectID":"/posts/cloud_computing/vm/%E5%88%B6%E4%BD%9C%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%95%9C%E5%83%8F/:1:1","tags":["虚拟机","KVM","云计算"],"title":"制作虚拟机镜像","uri":"/posts/cloud_computing/vm/%E5%88%B6%E4%BD%9C%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%95%9C%E5%83%8F/"},{"categories":["VM"],"content":"1.2 自动安装 可以看到，手动安装需要人为在菜单中选择、配置，这不适用于多个虚拟机的安装。而 RedHat 创建了 kickstart 安装方法，使得整个虚拟机安装流程变得自动化。 这块不了解，具体见红帽官方文档：KICKSTART INSTALLATIONS ","date":"2020-10-31","objectID":"/posts/cloud_computing/vm/%E5%88%B6%E4%BD%9C%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%95%9C%E5%83%8F/:1:2","tags":["虚拟机","KVM","云计算"],"title":"制作虚拟机镜像","uri":"/posts/cloud_computing/vm/%E5%88%B6%E4%BD%9C%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%95%9C%E5%83%8F/"},{"categories":["VM"],"content":"2 使用 Cloud Image 当然，上面制作过程中耗时都在安装系统上了，而各个云厂商的虚拟机数量那么多，肯定不会一台台去安装操作系统了。所以，目前最常见的都是直接下载已经安装过系统的虚拟机镜像文件。 但是这样的虚拟机是没有特殊配置的，例如密码、hostname 都是一致的，所以 cloud-init 出现，用于在第一次启动虚拟机时进行系统的配置。 所以，最快速的制作方法就是：虚拟机镜像文件 + cloud-init 配置。 ","date":"2020-10-31","objectID":"/posts/cloud_computing/vm/%E5%88%B6%E4%BD%9C%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%95%9C%E5%83%8F/:2:0","tags":["虚拟机","KVM","云计算"],"title":"制作虚拟机镜像","uri":"/posts/cloud_computing/vm/%E5%88%B6%E4%BD%9C%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%95%9C%E5%83%8F/"},{"categories":["VM"],"content":"2.1 cloud-init 下面内容都来自于文档，这里仅为自己做个记录。 首先明确 cloud init 的功能：系统第一次启动时，cloud init 相关的进程会根据配置信息去进行系统的配置，包括：设置 hostname、ssh key、password 等； (1) 基本概念 metadata：包含服务器信息，用于 cloud-init 配置； userdata：包含 cloud-init 系统配置信息，可以是 文件，脚本，yaml 文件等； datasource：cloud-init 读取配置数据的来源，包含大部分云厂商，当然，也可以来自本地的文件(NoCloud datasource)； (2) 运行过程 cloud init 设置包括五个阶段： Generator 机器启动阶段，systemd 的一个 generator 将会决定是否将 cloud-init.target（target 可以简单认为特定事件下触发的一组 unit）包含在启动过程中。这就表示启动 cloud-init。 默认情况下，generator 会启动 cloud-init，除非以下情况： /etc/cloud/cloud-init.disabled 文件存在； 内核启动命令行 /proc/cmdline 中包含 “cloud-init=disabled”。如果是容器中运行，会读取环境变量 KERNEL_CMDLINE； 而下面的步骤，就是由 target 包含的各个 unit 执行的。 Local 由 cloud-init-local.service 执行，主要目的：找到 “local” 的 datasource，根据配置网络。 配置网络有三种情况： 首先，根据传入配置 “metadata” 配置网络； 当上面情况失败，直接配置 “dhcp on eth0”； 如果 /etc/cloud/cloud.cfg 配置文件中禁用了网络：network: {config: disabled}，那么就不进行网络配置； Init、Config、Final 阶段 对应 service 为 cloud-init.service、cloud-config.service、 cloud-final.service。 通过 local 阶段，网络已经配置好了，并且已经得到了 metadata。而 /etc/cloud/cloud.cfg 配置定义了剩下三个阶段对应的任务，也就是 module。 cloud init 通过一些缓存信息来判断机器是否经过初始化，通过 cloud-init clean 也可以手动清理缓存信息。 /var/log/cloud-init.log 记录了 cloud-init 运行的完整过程。 ","date":"2020-10-31","objectID":"/posts/cloud_computing/vm/%E5%88%B6%E4%BD%9C%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%95%9C%E5%83%8F/:2:1","tags":["虚拟机","KVM","云计算"],"title":"制作虚拟机镜像","uri":"/posts/cloud_computing/vm/%E5%88%B6%E4%BD%9C%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%95%9C%E5%83%8F/"},{"categories":["VM"],"content":"2.2 制作镜像 下面就开始进行镜像制作： 下载 cloud image，这里使用中科大提供的： $ wget https://mirrors.ustc.edu.cn/centos-cloud/centos/7/images/CentOS-7-x86_64-GenericCloud-2003.qcow2 修改密码 当然，该镜像其实就可以直接进行 virt-install 来启动（因为我们没有配置文件，所以通过 virt-install 来启动并生成配置文件），但是不知道密码，也搜不到，无法登陆进入。不过你也可以使用下面命令来设置密码后进行登陆： $ virt-customize -a CentOS-7-x86_64-GenericCloud-2003.qcow2 --root-password password:yourpassword 2. 因为 cloud-init 需要一个 datasource，而我们没有使用云厂商，所以使用 NoCloud 形式，按照官方的s示例创建一个 disk 文件。 # 创建 user-data 与 meta-date 配置文件 $ cat meta-data instance-id: guest1 local-hostname: guest1 $ cat user-data #cloud-config chpasswd: expire: false list: | root: password1 ssh_pwauth: True # 生成 disk 文件，包含 userdata 与 metadata 配置数据 $ genisoimage -output seed.iso -volid cidata -joliet -rock user-data meta-data 创建并运行虚拟机。 $ virt-install --memory 2048 --vcpus 2 --name guest2 \\ --disk CentOS-7-x86_64-GenericCloud-2003.qcow2 --disk seed.iso \\ --os-type Linux --os-variant centos7.0 --virt-type kvm \\ --graphics none --network default \\ --import 几个比较重要的参数： --disk CentOS-7-x86_64-GenericCloud-2003.qcow2：制定系统盘； --import：跳过安装过程，因为已经安装好操作系统，不需要进行安装过程； --disk seed.iso：传递 cloud-init datasource 信息； 虚拟机启动过程中，可以看到 cloud-init 配置信息的一些打印： 最后根据配置的密码成功进入： 而 CentOS-7-x86_64-GenericCloud-2003.qcow2 就是虚拟机经过配置的镜像文件，而 libvirt 启动所需的配置文件就是 /etc/libvirt/qemu/guest1.xml。 ","date":"2020-10-31","objectID":"/posts/cloud_computing/vm/%E5%88%B6%E4%BD%9C%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%95%9C%E5%83%8F/:2:2","tags":["虚拟机","KVM","云计算"],"title":"制作虚拟机镜像","uri":"/posts/cloud_computing/vm/%E5%88%B6%E4%BD%9C%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%95%9C%E5%83%8F/"},{"categories":["VM"],"content":"参考 CREATING GUESTS WITH VIRT-INSTALL KICKSTART INSTALLATIONS cloud-init Documentation ","date":"2020-10-31","objectID":"/posts/cloud_computing/vm/%E5%88%B6%E4%BD%9C%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%95%9C%E5%83%8F/:3:0","tags":["虚拟机","KVM","云计算"],"title":"制作虚拟机镜像","uri":"/posts/cloud_computing/vm/%E5%88%B6%E4%BD%9C%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%95%9C%E5%83%8F/"},{"categories":["k8s 实践"],"content":"使用 PV 与 PVC 为 Pod 提供存储","date":"2020-10-30","objectID":"/posts/cloud_computing/k8s_practice/pv-pvc-%E4%B8%8E-storageclass/","tags":["k8s","云计算"],"title":"PV PVC 与 StorageClass","uri":"/posts/cloud_computing/k8s_practice/pv-pvc-%E4%B8%8E-storageclass/"},{"categories":["k8s 实践"],"content":"1 PV 与 PVC 目的：使用 NFS 做 PV，创建 Pod 使用该 PV Node-1 构建 nfs 服务，位于 “/nfs” 目录。 创建 PV，使用 nfs 类型。 声明、创建 PVC，使用上述指定的 StorageClass，形成指定的绑定关系。 pvc 状态为 Bound，表明已经成功绑定到了 pvc。查询 pv，可以看到 pv 也是被绑定了。(注意：一个 PV 只能绑定一个 PV) 创建 Pod Deployment，在 Pod 的 Volume 使用 PVC。 其中两个 Pod 分别调度到了 Node-2 Node-3，在 Node-2 Node-3 中可以看到对应的 nfs mount： 对应容器配置也可以看到指定的挂载： 在 Node-3 节点的容器环境内写入挂载路径文件，可以看到同步到了主节点的 /nfs 目录上，因此，存储配置成功。 ","date":"2020-10-30","objectID":"/posts/cloud_computing/k8s_practice/pv-pvc-%E4%B8%8E-storageclass/:1:0","tags":["k8s","云计算"],"title":"PV PVC 与 StorageClass","uri":"/posts/cloud_computing/k8s_practice/pv-pvc-%E4%B8%8E-storageclass/"},{"categories":["k8s 实践"],"content":"使用 RBAC 进行访问控制与授权","date":"2020-10-30","objectID":"/posts/cloud_computing/k8s_practice/rbac-%E5%AE%9E%E8%B7%B5/","tags":["k8s","云计算"],"title":"RBAC 实践","uri":"/posts/cloud_computing/k8s_practice/rbac-%E5%AE%9E%E8%B7%B5/"},{"categories":["k8s 实践"],"content":"Kubernetes 中，通过 RBAC 机制来实现集群 Pod 中对 APIServer 的访问权限控制与授权。 RBAC 机制有三个最基本的概念： Role：一组规则，定义了对 API 对象的操作权限； Subject：被作用者，集群内部常常使用的是 ServiceAccount； RoleBinding：绑定 Role 与 Subject； ","date":"2020-10-30","objectID":"/posts/cloud_computing/k8s_practice/rbac-%E5%AE%9E%E8%B7%B5/:0:0","tags":["k8s","云计算"],"title":"RBAC 实践","uri":"/posts/cloud_computing/k8s_practice/rbac-%E5%AE%9E%E8%B7%B5/"},{"categories":["k8s 实践"],"content":"1 Role 与 ServiceAccount 实践 目的：通过 Role 与 RoleBinding 限制一类 ServiceAccount，并在 Pod 中使用该 ServiceAccount 观察权限控制。 创建需要使用的自定义 namespace [mynamespace] 创建需要限制访问权限的 ServiceAccount [example-sa] 可以看到，每个 namespace 有个默认的 ServiceAccount default，提供完整的 APIServer 访问权限。 每个 ServiceAccount 在容器维度看到就是 Secret 对象，包含证书内容。 创建 Role，定义允许的权限规则。 可以看到，rules 指定了该 Role 为：允许对 mynamespace 下的 pod 进行 get、watch、list 操作。 创建 RoleBinding，关联刚刚创建的 Role 与 ServiceAccount。 创建 Pod，指定使用的 ServiceAccount，在 Pod 内观察权限是否被限制了 进入容器中，可以看到，k8s 将 ServiceAccount 对应的 Serects 对象挂载到了 /run/secrets/kubernetes.io/serviceaccount 目录下，包含 client 需要使用的【证书 ca.crt】、【token】: ","date":"2020-10-30","objectID":"/posts/cloud_computing/k8s_practice/rbac-%E5%AE%9E%E8%B7%B5/:1:0","tags":["k8s","云计算"],"title":"RBAC 实践","uri":"/posts/cloud_computing/k8s_practice/rbac-%E5%AE%9E%E8%B7%B5/"},{"categories":["k8s 实践"],"content":"使用 CRD 自定义资源，通过 Kubernetes 编排","date":"2020-10-30","objectID":"/posts/cloud_computing/k8s_practice/crd-%E5%AE%9E%E8%B7%B5/","tags":["k8s","云计算"],"title":"CRD 实践","uri":"/posts/cloud_computing/k8s_practice/crd-%E5%AE%9E%E8%B7%B5/"},{"categories":["k8s 实践"],"content":"CRD 是 Kubernetes 可扩展性的第一个体现，因为 Kubernetes 提供的是一个编排的框架，因此不止可以对 Pod 进行编排，也支持通过 CRD 对你自定义的类型的编排。 ","date":"2020-10-30","objectID":"/posts/cloud_computing/k8s_practice/crd-%E5%AE%9E%E8%B7%B5/:0:0","tags":["k8s","云计算"],"title":"CRD 实践","uri":"/posts/cloud_computing/k8s_practice/crd-%E5%AE%9E%E8%B7%B5/"},{"categories":["k8s 实践"],"content":"1 CRD 构建 目的：通过 CRD 构建一个自定义资源。 编写 CRD manifest，完成自定义资源的定义。 可以看到，CRD 中只有类型的简单定义，没有该 CR 的元属性的定义，因为这些需要通过代码中定义。 通过 kubectl apply 创建 CR 对应 CRD 对象，让 Kubernetes “认识” 这个自定义资源。 调用 kubectl apply 创建自定义资源： 这里其实 Kubernetes 不知道该资源具体的代码类型，它只是知道有 CRNetwork 这个资源，并支持创建删除，将其保存下来了。 编写 CR 相关定义代码。其实这里编写代码是为生成 kubectl 的 Client，使其在编写 Controller 时候能够正确的解析你的 CR 对象。 整个的目录结构如下： 具体代码见仓库：k8s_practice 通过 k8s 生成代码，最终生成的目录结构如下： ","date":"2020-10-30","objectID":"/posts/cloud_computing/k8s_practice/crd-%E5%AE%9E%E8%B7%B5/:1:0","tags":["k8s","云计算"],"title":"CRD 实践","uri":"/posts/cloud_computing/k8s_practice/crd-%E5%AE%9E%E8%B7%B5/"},{"categories":["k8s 实践"],"content":"2 编写自定义控制器 因为 Kubernetes 中是基于声明式 API 的业务实现，所以需要控制器来“监控”对象变化，执行对应的操作。 编写自动以控制器主要有三个过程：编写 main 函数、编写自定义控制器定义，编写控制器业务逻辑。 整个实践代码见：k8s_practice Controller 代码编写。主要逻辑：处理 Informer 通知的 Event，执行 CR Sync 操作。 Controller 主要包含三个部分： Informer：包含从 APIServer 同步的 CR 对象的 Cache，并且处理 CR Event，调用 Event Handler。 Event Handler：Informer 的各个 Event 调用的事件回调，一般都是放入 workQueue，延后处理。 Workers：根据各个 Event 进行真正的业务处理，例如真实资源的创建、删除、更新等。 main 函数代码编写。主要逻辑：创建 Informer、Controller，执行 Controller 的启动。 编译后运行 Controller。 第一同步后，所有的 CR 对象都可以被任务是“新添加的”，因此会一个个调用 HandleAdd 接口。上图可以看到，因为集群中已经有了一个 CR 对象，因此 Controller 会进行该对象的 Sync。 创建一个新的 CR 对象 example-crnetwork-2，观察 Controller。 可以看到 Controller 处理完成。 删除刚创建的 example-crnetwork-2，观察 Controller。 可以看到 Controller 正确的执行删除的逻辑。 ","date":"2020-10-30","objectID":"/posts/cloud_computing/k8s_practice/crd-%E5%AE%9E%E8%B7%B5/:2:0","tags":["k8s","云计算"],"title":"CRD 实践","uri":"/posts/cloud_computing/k8s_practice/crd-%E5%AE%9E%E8%B7%B5/"},{"categories":["k8s 实践"],"content":"3 将自定义资源控制封装为 Pod TODO ","date":"2020-10-30","objectID":"/posts/cloud_computing/k8s_practice/crd-%E5%AE%9E%E8%B7%B5/:3:0","tags":["k8s","云计算"],"title":"CRD 实践","uri":"/posts/cloud_computing/k8s_practice/crd-%E5%AE%9E%E8%B7%B5/"},{"categories":["k8s 实践"],"content":"使用 Job 或者 CronJob 部署一次性任务","date":"2020-10-30","objectID":"/posts/cloud_computing/k8s_practice/job-cronjob-%E5%AE%9E%E8%B7%B5/","tags":["k8s","云计算"],"title":"Job CronJob 实践","uri":"/posts/cloud_computing/k8s_practice/job-cronjob-%E5%AE%9E%E8%B7%B5/"},{"categories":["k8s 实践"],"content":"Job 用于运行一次性的任务，即“离线任务”。CronJob 在 Job 之上提供了周期性任务支持。 ","date":"2020-10-30","objectID":"/posts/cloud_computing/k8s_practice/job-cronjob-%E5%AE%9E%E8%B7%B5/:0:0","tags":["k8s","云计算"],"title":"Job CronJob 实践","uri":"/posts/cloud_computing/k8s_practice/job-cronjob-%E5%AE%9E%E8%B7%B5/"},{"categories":["k8s 实践"],"content":"1 Job 目的：部署 Job 任务，使用并行运行（Batch）的功能。 创建部署 Job 任务。 可以看到，并行的两个 Pod 正在运行。 经过一段时间可以看到，因为设置 deadline 为 100，所以 pod 异常被退出。而 restartPolicy: Never 使得不会再次运行。 去除 deadline 设置，重新部署，可以看到，本次 4 次成功完成。 ","date":"2020-10-30","objectID":"/posts/cloud_computing/k8s_practice/job-cronjob-%E5%AE%9E%E8%B7%B5/:1:0","tags":["k8s","云计算"],"title":"Job CronJob 实践","uri":"/posts/cloud_computing/k8s_practice/job-cronjob-%E5%AE%9E%E8%B7%B5/"},{"categories":["k8s 实践"],"content":"2 CronJob 目的：体验 CronJob 的周期性任务功能，明确 CronJob 是基于 Job 管理实现的。 创建部署 CronJob 。可以看到，CronJob 中需要指定 JobTemplate，因此 CronJob 完全是基于 Job 管理的。 部署后可以看到，CronJob 创建了一个 Job： 经过一分钟，新 Job 被创建，并运行成功： ","date":"2020-10-30","objectID":"/posts/cloud_computing/k8s_practice/job-cronjob-%E5%AE%9E%E8%B7%B5/:2:0","tags":["k8s","云计算"],"title":"Job CronJob 实践","uri":"/posts/cloud_computing/k8s_practice/job-cronjob-%E5%AE%9E%E8%B7%B5/"},{"categories":["k8s 实践"],"content":"使用 DaemonSet 部署常驻容器","date":"2020-10-30","objectID":"/posts/cloud_computing/k8s_practice/daemonset-%E5%AE%9E%E8%B7%B5/","tags":["k8s","云计算"],"title":"DaemonSet 实践","uri":"/posts/cloud_computing/k8s_practice/daemonset-%E5%AE%9E%E8%B7%B5/"},{"categories":["k8s 实践"],"content":"DaemonSet 会为匹配的 Node 运行一个 Daemon Pod，与 Deployment 类最大不同，DaemonSet 没有副本的概念。 目的：部署 DaemonSet，试用 toleration 与 nodeAffinity，观察滚动升级流程。 部署 DaemonSet。其中，是用 nodeAffinity 指定选择调度的节点，使用 toleration 容器 Node 的 taint: 创建后，可以看到，只选择调度到了 node-1 node-2 节点，和配置的 Affinity 匹配： 改变 DaemonSet 使用的镜像版本，观察滚动升级流程: 通过 kubectl rollout status 可以看到，滚动升级流程与 Deployment 过程一致： 观察 Event，可以看到也是按照 delete -\u003e create 的流程进行升级的。 ","date":"2020-10-30","objectID":"/posts/cloud_computing/k8s_practice/daemonset-%E5%AE%9E%E8%B7%B5/:0:0","tags":["k8s","云计算"],"title":"DaemonSet 实践","uri":"/posts/cloud_computing/k8s_practice/daemonset-%E5%AE%9E%E8%B7%B5/"},{"categories":["k8s 实践"],"content":"使用 StatefulSet 进行副本控制","date":"2020-10-30","objectID":"/posts/cloud_computing/k8s_practice/statefulset-%E5%AE%9E%E8%B7%B5/","tags":["k8s","云计算"],"title":"StatefulSet 实践","uri":"/posts/cloud_computing/k8s_practice/statefulset-%E5%AE%9E%E8%B7%B5/"},{"categories":["k8s 实践"],"content":"Deployment 对于“无状态”的任务，已经能够做到副本控制，滚动升级功能了。但是 Deployment 无法适用于“有状态”的任务，因为其中 Pod 都是相同的，没有任何的对应关系。 而 StatefulSet 通过“固定命名、域名的 Pod，以及固定的创建顺序”作为基础，加上与命名对应的网络、存储，搭建一个“有状态”Pod 管理。 ","date":"2020-10-30","objectID":"/posts/cloud_computing/k8s_practice/statefulset-%E5%AE%9E%E8%B7%B5/:0:0","tags":["k8s","云计算"],"title":"StatefulSet 实践","uri":"/posts/cloud_computing/k8s_practice/statefulset-%E5%AE%9E%E8%B7%B5/"},{"categories":["k8s 实践"],"content":"1 HeadlessService StatefulSet 会使用 HeadlessService 的概念，首先来部署 HeadlessService。 创建描述文件 headless_service 可以看到，Headless 与普通 Service 最大区别是 clusterIP 为 None。 通过 kubectl create 部署 HeadlessService，成功后可以看到： 查看 Endpoint，可对应的 Endpoint 包含了 Node-1 Node-2 的 Pod 的地址了。并且 Endpoint 命名和Service 名字一样。 你按照这样的方式创建了一个 Headless Service 之后，它所代理的所有 Pod 的 IP 地址，都会被绑定一个这样格式的 DNS 记录： \u003cpod-name\u003e.\u003csvc-name\u003e.\u003cnamespace\u003e.svc.cluster.local 但是好像单独使用 Headless Service 是无法访问这些域名的。 ","date":"2020-10-30","objectID":"/posts/cloud_computing/k8s_practice/statefulset-%E5%AE%9E%E8%B7%B5/:1:0","tags":["k8s","云计算"],"title":"StatefulSet 实践","uri":"/posts/cloud_computing/k8s_practice/statefulset-%E5%AE%9E%E8%B7%B5/"},{"categories":["k8s 实践"],"content":"2 StatfulSet ","date":"2020-10-30","objectID":"/posts/cloud_computing/k8s_practice/statefulset-%E5%AE%9E%E8%B7%B5/:2:0","tags":["k8s","云计算"],"title":"StatefulSet 实践","uri":"/posts/cloud_computing/k8s_practice/statefulset-%E5%AE%9E%E8%B7%B5/"},{"categories":["k8s 实践"],"content":"2.1 StaefulSet 的固定域名 下面开始部署 StatefulSet： 先要创建对应的 Headless Service，如前面一样。 创建对应的 StatefulSet 描述文件： 可以看到，StatefulSet 与 Deployment 最大的区别就是指定了 serviceName 字段，指定了使用的 HeadlessService。 创建 StatefulSet 对象，类似于 Deployment，开始创建 Pod 了 但是 StatefulSet 并没有创建任何的 ReplicaSet，所以实现上与 Deployment 不一样： 观察创建出的 Pod，可以看到，其 Pod 命名不是加上随机字符串了，而是有序的数字： 并且，其创建顺序也是有序的，先创建 web-0 ，web-0 运行后并 Ready 后，创建 web-1。 运行一个 busybox 测试容器，执行 nslookup 访问 HeadlessService 为其绑定的域名，可以看到正常返回了。 删除 web-0 Pod，可以看到 StatefulSet 会重新立刻创建同名的 Pod。所以，Pod 名字是固定的 再次通过 web-0.nginx.default.svc.cluster.local 进行域名解析，还是能够正确的解析： 注意：虽然域名可以正确解析，但是其域名对应的 IP 不是保证固定的，所以不能保存 Pod 的 IP ","date":"2020-10-30","objectID":"/posts/cloud_computing/k8s_practice/statefulset-%E5%AE%9E%E8%B7%B5/:2:1","tags":["k8s","云计算"],"title":"StatefulSet 实践","uri":"/posts/cloud_computing/k8s_practice/statefulset-%E5%AE%9E%E8%B7%B5/"},{"categories":["k8s 实践"],"content":"2.2 StatefulSet 的固定存储 目的：使用 StatefulSet 中的 Template PVC 自动构建持久化存储，并观察其 PVC 是否与 PodName 绑定。 构建 nfs 的 2 个 PV，给 2 个 Pod 准备。（构建过程见\u003cPV、PVC 与 StorageClass\u003e一节） 创建 StatefulSet，其指定 PVC 模板，使得能够为每个 Pod 自动创建其对应的 PVC。 创建后可以看到，StatefulSet 为 2 个 Pod 创建了对应的 PVC： 可以看到，PVC 是和名字对应的，格式为 [volume name]-[pod name]，因此，PVC 与 Pod 名字的映射关系是固定的。 所以这就实现了，当旧 Pod 删除，新 Pod 被创建后，因为其 Pod Name 没有变，所以就找到了旧 Pod 使用 PVC。 ","date":"2020-10-30","objectID":"/posts/cloud_computing/k8s_practice/statefulset-%E5%AE%9E%E8%B7%B5/:2:2","tags":["k8s","云计算"],"title":"StatefulSet 实践","uri":"/posts/cloud_computing/k8s_practice/statefulset-%E5%AE%9E%E8%B7%B5/"},{"categories":["k8s 实践"],"content":"使用 Deployment 进行部署","date":"2020-10-16","objectID":"/posts/cloud_computing/k8s_practice/deployment-%E5%AE%9E%E8%B7%B5/","tags":["k8s","云计算"],"title":"Deployment 实践","uri":"/posts/cloud_computing/k8s_practice/deployment-%E5%AE%9E%E8%B7%B5/"},{"categories":["k8s 实践"],"content":"1 ReplicaSet Deploment 管理的是 ReplicaSet，所以先运行 ReplicaSet 观察。 ReplicaSet 只包含副本控制功能，没有滚动升级等高级的功能。 ","date":"2020-10-16","objectID":"/posts/cloud_computing/k8s_practice/deployment-%E5%AE%9E%E8%B7%B5/:1:0","tags":["k8s","云计算"],"title":"Deployment 实践","uri":"/posts/cloud_computing/k8s_practice/deployment-%E5%AE%9E%E8%B7%B5/"},{"categories":["k8s 实践"],"content":"1.1 部署 ReplicaSet 创建 manifest 文件。 调用 kubectl create 创建资源。 观察下 ReplicaSet 的事件，可以看到各个 Pod 的创建流程。 ","date":"2020-10-16","objectID":"/posts/cloud_computing/k8s_practice/deployment-%E5%AE%9E%E8%B7%B5/:1:1","tags":["k8s","云计算"],"title":"Deployment 实践","uri":"/posts/cloud_computing/k8s_practice/deployment-%E5%AE%9E%E8%B7%B5/"},{"categories":["k8s 实践"],"content":"1.2 副本保证 目前，3 个 Pod 都运行在了 Node-3 上： 下线 Node-3 ，可以看到 node-3 变为 NotReady: 过了一段时间后，原来三个 Pod 变为 Terminating 状态，而新的 Pod 被创建被调度。 可以看到，新创建 3 个 Pod 被调度到了 Node-2 上: 恢复 Node-3 上线，kubelet 会同步任务，因此不会再次运行旧的三个 Pod。Pod 的状态也从 Terminating 变为被删除。 ","date":"2020-10-16","objectID":"/posts/cloud_computing/k8s_practice/deployment-%E5%AE%9E%E8%B7%B5/:1:2","tags":["k8s","云计算"],"title":"Deployment 实践","uri":"/posts/cloud_computing/k8s_practice/deployment-%E5%AE%9E%E8%B7%B5/"},{"categories":["k8s 实践"],"content":"1.3 水平缩扩 通过 kubectl scale 进行副本扩展: 可以看到，新的 Pod 在 Node-3 被运行： 依旧 kubectl scale 进行副本缩容，可以看到，两个 Pod 被停止: 可以看到，ReplicaSet 启动和停止任务都是由 Scheduler 选择的，而不能认为的控制选择指定的 Pod，也就是说，所有的 Pod 应该被认为是“无状态的”，随时可能被停止。 ","date":"2020-10-16","objectID":"/posts/cloud_computing/k8s_practice/deployment-%E5%AE%9E%E8%B7%B5/:1:3","tags":["k8s","云计算"],"title":"Deployment 实践","uri":"/posts/cloud_computing/k8s_practice/deployment-%E5%AE%9E%E8%B7%B5/"},{"categories":["k8s 实践"],"content":"2 Deployment Deployment 操作与管理的是 ReplicaSet，而不是 Pod。 ","date":"2020-10-16","objectID":"/posts/cloud_computing/k8s_practice/deployment-%E5%AE%9E%E8%B7%B5/:2:0","tags":["k8s","云计算"],"title":"Deployment 实践","uri":"/posts/cloud_computing/k8s_practice/deployment-%E5%AE%9E%E8%B7%B5/"},{"categories":["k8s 实践"],"content":"2.1 部署 构建 manfiest 文件: 通过 kubectl create 创建 Deployment。 可以看到，Event 中打印的是对应的ReplicaSet 的自动被创建，所以Deployment 是创建 ReplicaSet 的。 ","date":"2020-10-16","objectID":"/posts/cloud_computing/k8s_practice/deployment-%E5%AE%9E%E8%B7%B5/:2:1","tags":["k8s","云计算"],"title":"Deployment 实践","uri":"/posts/cloud_computing/k8s_practice/deployment-%E5%AE%9E%E8%B7%B5/"},{"categories":["k8s 实践"],"content":"2.2 水平扩展 Deployment 水平扩展方式与 ReplicaSet 一致，并且就是操作 ReplicaSet 的 replica 的值来实现，跳过。 ","date":"2020-10-16","objectID":"/posts/cloud_computing/k8s_practice/deployment-%E5%AE%9E%E8%B7%B5/:2:2","tags":["k8s","云计算"],"title":"Deployment 实践","uri":"/posts/cloud_computing/k8s_practice/deployment-%E5%AE%9E%E8%B7%B5/"},{"categories":["k8s 实践"],"content":"2.3 滚动升级 (1) 正常流程 Deployment 在 ReplicaSet 基础上添加了“滚动升级”的功能。 依旧创建 Deployment，并直接扩展到副本数为 3。 修改 Deployment 的配置文件，将 image 版本升级。 可以看到，Deployment 新建了一个 ReplicaSet （部署新版本 Pod），而旧的 ReplicaSet 副本变为了 0。 通过 Deployment 的 Event 可以看到，旧版 ReplicaSet 的副本数逐渐减少，而新版本 ReplicaSet 副本数逐渐增加。这样使得集群中 Pod 会维持在一个最低数量（示例中为 3） (2) 错误流程 观察下当升级出现错误时，Deployment 会处于怎样的状态。 通过 kubectl set image 将 Deployment 使用镜像变为一个不存在的镜像。 通过 Event 看到，滚动升级停止在了最新版本的 Replicaset 的第一个副本部署。 因为新旧版本是交替部署的，所以当第一个副本部署失败时，也就不会继续进行旧版本 Pod 的停止了。 ","date":"2020-10-16","objectID":"/posts/cloud_computing/k8s_practice/deployment-%E5%AE%9E%E8%B7%B5/:2:3","tags":["k8s","云计算"],"title":"Deployment 实践","uri":"/posts/cloud_computing/k8s_practice/deployment-%E5%AE%9E%E8%B7%B5/"},{"categories":["k8s 实践"],"content":"2.4 回滚 在错误流程看到，当发布错误的版本后，Deployment 会停止新版本的发布，而这时，就需要通过 kubectl rollout 进行 Deployment 的回滚。 执行 kubectl rollout history，查看每次 Deployment 变更对应的版本。（因为 -record，所有的 kubectl 命令都会被记录）。 可以看到，两次的版本变更都被记录了下来。 通过 –revision 参数，查看对应的命令细节。 通过 kubectl rollout undo 进行版本的回退，默认为上一次版本，通过 –to-revision 可以执行回退的版本。 事实上，回退也是一次“升级”，通过 history 可以看到一个新的部署记录： 这个 4，就是最新的一次回滚执行的命令了。 ","date":"2020-10-16","objectID":"/posts/cloud_computing/k8s_practice/deployment-%E5%AE%9E%E8%B7%B5/:2:4","tags":["k8s","云计算"],"title":"Deployment 实践","uri":"/posts/cloud_computing/k8s_practice/deployment-%E5%AE%9E%E8%B7%B5/"},{"categories":["k8s 实践"],"content":"单机使用虚拟机搭建 k8s 集群","date":"2020-10-15","objectID":"/posts/cloud_computing/k8s_practice/%E8%99%9A%E6%8B%9F%E6%9C%BA-k8s-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/","tags":["k8s","云计算"],"title":"虚拟机 k8s 集群搭建","uri":"/posts/cloud_computing/k8s_practice/%E8%99%9A%E6%8B%9F%E6%9C%BA-k8s-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"},{"categories":["k8s 实践"],"content":"1 虚拟机集群搭建 目标：创建 3 个虚拟机，用作一个 Master Node，两个 Work Node；当然，三个节点处于同一个网段。 具体步骤如下: 构建节点 构建三个虚拟机，基于 centos 7、内存 2 GB，并通过虚拟机复制功能（其实就是 copy 系统盘），完全复制出 Node 1，Node 2，Node 3。 搭建网络 三个节点需要互相访问，所以将其位于 VirtualBox 创建的 Nat网络下，给予每个 Node 静态的 IP（10.0.2.10 - 10.0.2.12），为了方便访问，并设置 ssh 的 DNAT。 设置每个虚拟机网卡加入其创建的 “NodeNatNetwork”。例如： 启动每个虚拟机，设置其 hostname，与网卡静态 IP。例如： 至此，三个虚拟机位于同一个网段，并且能够相互访问；对外，则通过 VirtualBox 的 Nat 网络能够访问。 ","date":"2020-10-15","objectID":"/posts/cloud_computing/k8s_practice/%E8%99%9A%E6%8B%9F%E6%9C%BA-k8s-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/:1:0","tags":["k8s","云计算"],"title":"虚拟机 k8s 集群搭建","uri":"/posts/cloud_computing/k8s_practice/%E8%99%9A%E6%8B%9F%E6%9C%BA-k8s-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"},{"categories":["k8s 实践"],"content":"2 部署 K8s 目标：通过 kubeadm 部署整个 k8s，用 Node-1 为 Master 节点，其他为工作节点。 ","date":"2020-10-15","objectID":"/posts/cloud_computing/k8s_practice/%E8%99%9A%E6%8B%9F%E6%9C%BA-k8s-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/:2:0","tags":["k8s","云计算"],"title":"虚拟机 k8s 集群搭建","uri":"/posts/cloud_computing/k8s_practice/%E8%99%9A%E6%8B%9F%E6%9C%BA-k8s-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"},{"categories":["k8s 实践"],"content":"2.1 安装 kubeadm、kubelet、kubectl 安装 kubeadm、kubelet、kubectl。这个官方文档写的很详细，见 Installing kubeadm 。 ","date":"2020-10-15","objectID":"/posts/cloud_computing/k8s_practice/%E8%99%9A%E6%8B%9F%E6%9C%BA-k8s-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/:2:1","tags":["k8s","云计算"],"title":"虚拟机 k8s 集群搭建","uri":"/posts/cloud_computing/k8s_practice/%E8%99%9A%E6%8B%9F%E6%9C%BA-k8s-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"},{"categories":["k8s 实践"],"content":"2.2 kubeadm init 初始化 Master 节点 Node-1 节点执行 kubeadm init，将其作为 Master 节点初始化。执行成功后，kubeadm 生成了 Kubernetes 组件的各个配置，以及提供服务的各类证书，位于 /etc/kubernetes 目录下: 并且已经以 static pod 的形式启动了：apiserver、controller-manager、etcd、scheduler。 还有最重要的，kubeadm 为集群生成一个【bootstrap token】，需要加入集群的节点都需要通过这个 token 加入。 * 问题 kubeadm 检查 swap 打开着，kubeadm 推荐不使用 swap，通过 swapoff -a 关闭交换区。 kubectl 默认通过 8080 端口访问，无法执行。 设置 kubectl 的配置文件为 kubeadm 生成的 /etc/kubernetes/admin.conf。（其实就是配置公钥，或者将 admin.conf 移动到 ~/.kube/config 文件，作为默认配置。 ","date":"2020-10-15","objectID":"/posts/cloud_computing/k8s_practice/%E8%99%9A%E6%8B%9F%E6%9C%BA-k8s-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/:2:2","tags":["k8s","云计算"],"title":"虚拟机 k8s 集群搭建","uri":"/posts/cloud_computing/k8s_practice/%E8%99%9A%E6%8B%9F%E6%9C%BA-k8s-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"},{"categories":["k8s 实践"],"content":"2.3 kubeadm join [token] 设置工作节点 通过 kubead init 最后返回的提示信息，执行对应 kubeadm join 将 Node-1 Node-2 加入到集群中，作为工作节点。 [root@Node-2 kubeadm join 10.0.2.10:6443 --token mahrou.d3uodof21i3d6yxk --discovery-token-ca-cert-hash sha256:21dfe4ef6b3bbd89f803bf44ff6eda587874336d103d0e4a3b --v 5 可以看到，kubelet 启动后就通过 pod 方式启动了本节点上 kube-proxy 容器： * 问题 无法访问到 Node-1 节点，nc ip 失败，但是可以 ping 通。通过在 Node-1 tcpdump 可以抓取到来自 Node-3 的包，因此应该是防火墙的问题，通过 iptables 对 Node-2 Node-3 IP 开放。 kubectl 无法访问问题，与上述问题一致。 ","date":"2020-10-15","objectID":"/posts/cloud_computing/k8s_practice/%E8%99%9A%E6%8B%9F%E6%9C%BA-k8s-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/:2:3","tags":["k8s","云计算"],"title":"虚拟机 k8s 集群搭建","uri":"/posts/cloud_computing/k8s_practice/%E8%99%9A%E6%8B%9F%E6%9C%BA-k8s-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"},{"categories":["k8s 实践"],"content":"2.4 结果 目前为止，就完成了集群的搭建，但是 通过 kubectl get nodes，可以看到所有节点都是 NotReady： kubectl describe node node-1 可以看到，原因是因为没有设置正确的 Network Plugin： ","date":"2020-10-15","objectID":"/posts/cloud_computing/k8s_practice/%E8%99%9A%E6%8B%9F%E6%9C%BA-k8s-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/:2:4","tags":["k8s","云计算"],"title":"虚拟机 k8s 集群搭建","uri":"/posts/cloud_computing/k8s_practice/%E8%99%9A%E6%8B%9F%E6%9C%BA-k8s-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"},{"categories":["k8s 实践"],"content":"3 部署网络插件 目的：部署网络插件，使各个节点为 Ready 状态，并其内部 Pod 能够相互通信。 以 Weave 部署为例，部署网络插件： kubectl apply -f \"https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d '\\n')\" 其描述文件中定义所有 Weave 需要的 BAAC 权限组件，以及最重要的网络插件 Pod 对应的 DaemonSet: 应用成功后，可以看到对应的 DaemonSet 就运行起来，并开始给三个 Node 部署 Pod: 在节点上，可以看到 weave-net 对应的 pod ，包括两个容器： ","date":"2020-10-15","objectID":"/posts/cloud_computing/k8s_practice/%E8%99%9A%E6%8B%9F%E6%9C%BA-k8s-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/:3:0","tags":["k8s","云计算"],"title":"虚拟机 k8s 集群搭建","uri":"/posts/cloud_computing/k8s_practice/%E8%99%9A%E6%8B%9F%E6%9C%BA-k8s-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"},{"categories":["k8s 实践"],"content":"4 部署容器存储插件 目的：为了能够让容器使用网络存储，使得容器数据持久化，需要部署存储插件。 以 Rook 项目为例，部署存储插件： $ kubectl apply -f https://raw.githubusercontent.com/rook/rook/master/cluster/exampleskubernetes/ceph/common.yaml $ kubectl apply -f https://raw.githubusercontent.com/rook/rook/master/cluster/exampleskubernetes/ceph/operator.yaml $ kubectl apply -f https://raw.githubusercontent.com/rook/rook/master/cluster/examples/kubernetes/ceph/cluster.yaml 安装成功后，可以看到，rook 有着自己的 namespace，并且已经部署了 DaemonSet： 可以看到，Pod 也部署成功了： ","date":"2020-10-15","objectID":"/posts/cloud_computing/k8s_practice/%E8%99%9A%E6%8B%9F%E6%9C%BA-k8s-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/:4:0","tags":["k8s","云计算"],"title":"虚拟机 k8s 集群搭建","uri":"/posts/cloud_computing/k8s_practice/%E8%99%9A%E6%8B%9F%E6%9C%BA-k8s-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"},{"categories":null,"content":"博客使用 Hugo 框架进行搭建, 主题使用 LoveIt. Logo 由 gopherize.me 生成, 并使用 realfavicongenerator.net 转化. ","date":"2020-10-15","objectID":"/about/:0:0","tags":null,"title":"关于","uri":"/about/"}]