<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <title>Kubernetes - 网络设计 - Shiori&#39;s Blog</title><meta name="Description" content="Shiori&#39;s Blog"><meta property="og:title" content="Kubernetes - 网络设计" />
<meta property="og:description" content="1 网络模型 Kubernetes 集群中的网络是虚拟扁平的大网络，Service 与 Pod 的网络有着各自独立的一个网段，每个 Service 与 Pod 占用网段中的一个 IP。Pod 之间可以通" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://KanShiori.github.io/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/" /><meta property="og:image" content="https://KanShiori.github.io/icons/favicon-16x16.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-31T20:22:14+08:00" />
<meta property="article:modified_time" content="2022-09-18T21:19:38+08:00" /><meta property="og:site_name" content="My cool site" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://KanShiori.github.io/icons/favicon-16x16.png"/>

<meta name="twitter:title" content="Kubernetes - 网络设计"/>
<meta name="twitter:description" content="1 网络模型 Kubernetes 集群中的网络是虚拟扁平的大网络，Service 与 Pod 的网络有着各自独立的一个网段，每个 Service 与 Pod 占用网段中的一个 IP。Pod 之间可以通"/>
<meta name="application-name" content="Shiori&#39;s Blog">
<meta name="apple-mobile-web-app-title" content="Shiori&#39;s Blog"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="icon" href="/icons/favicon.ico"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://KanShiori.github.io/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/" /><link rel="prev" href="https://KanShiori.github.io/posts/cloud/cloud_practice/kubebuilder/" /><link rel="next" href="https://KanShiori.github.io/posts/cloud/cloud_native/kubernetes/k8s_programming/thinking-in-opeator/" /><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css"></noscript><link rel="preload" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css"></noscript><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Kubernetes - 网络设计",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/KanShiori.github.io\/posts\/cloud\/cloud_native\/kubernetes\/k8s_learning\/container-network\/"
        },"image": ["https:\/\/KanShiori.github.io\/images\/Apple-Devices-Preview.png"],"genre": "posts","keywords": "k8s, 云计算","wordcount":  3592 ,
        "url": "https:\/\/KanShiori.github.io\/posts\/cloud\/cloud_native\/kubernetes\/k8s_learning\/container-network\/","datePublished": "2022-08-31T20:22:14+08:00","dateModified": "2022-09-18T21:19:38+08:00","license": "This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher": {
            "@type": "Organization",
            "name": "xxxx","logo": "https:\/\/KanShiori.github.io\/images\/avatar.png"},"author": {
                "@type": "Person",
                "name": "Shiori"
            },"description": ""
    }
    </script></head>
    <body data-header-desktop="fixed" data-header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="Shiori&#39;s Blog"><img
        class="lazyload logo"
        src="/svg/loading.min.svg"
        data-src="/icons/favicon-32x32.png"
        data-srcset="/icons/favicon-32x32.png, /icons/favicon-32x32.png 1.5x, /icons/favicon-32x32.png 2x"
        data-sizes="auto"
        alt="/icons/favicon-32x32.png"
        title="/icons/favicon-32x32.png" />Shiori&#39;s Blog</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="http://kanshiori.cn" rel="noopener noreffer" target="_blank"> 主页 </a><a class="menu-item" href="/posts/"> 所有文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><a class="menu-item" href="/about/"> 关于 </a><a class="menu-item" href="https://github.com/KanShiori/KanShiori.github.io" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i>  </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="Shiori&#39;s Blog"><img
        class="lazyload logo"
        src="/svg/loading.min.svg"
        data-src="/icons/favicon-32x32.png"
        data-srcset="/icons/favicon-32x32.png, /icons/favicon-32x32.png 1.5x, /icons/favicon-32x32.png 2x"
        data-sizes="auto"
        alt="/icons/favicon-32x32.png"
        title="/icons/favicon-32x32.png" />Shiori&#39;s Blog</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="http://kanshiori.cn" title="" rel="noopener noreffer" target="_blank">主页</a><a class="menu-item" href="/posts/" title="">所有文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a class="menu-item" href="/about/" title="">关于</a><a class="menu-item" href="https://github.com/KanShiori/KanShiori.github.io" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i></a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a></div>
    </div>
</header><div class="search-dropdown desktop">
        <div id="search-dropdown-desktop"></div>
    </div>
    <div class="search-dropdown mobile">
        <div id="search-dropdown-mobile"></div>
    </div><main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Kubernetes - 网络设计</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>Shiori</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/kubernetes-%E5%AD%A6%E4%B9%A0/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>Kubernetes 学习</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw" aria-hidden="true"></i>&nbsp;<time datetime="2022-08-31">2022-08-31</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden="true"></i>&nbsp;约 3592 字&nbsp;
                <i class="far fa-clock fa-fw" aria-hidden="true"></i>&nbsp;预计阅读 8 分钟&nbsp;</div>
        </div><div class="details toc" id="toc-static"  data-kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right" aria-hidden="true"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#1-网络模型">1 网络模型</a></li>
    <li><a href="#2-container-之间的通信">2 Container 之间的通信</a></li>
    <li><a href="#3-pod-之间的通信">3 Pod 之间的通信</a>
      <ul>
        <li><a href="#31-核心思想">3.1 核心思想</a></li>
        <li><a href="#32-基于代理的实现">3.2 基于代理的实现</a></li>
        <li><a href="#33-基于三层网络的实现">3.3 基于三层网络的实现</a></li>
        <li><a href="#34-跨三层网络的实现">3.4 跨三层网络的实现</a></li>
      </ul>
    </li>
    <li><a href="#4-pod-与-service-之间通信">4 Pod 与 Service 之间通信</a>
      <ul>
        <li><a href="#41-userspace-模式">4.1 userspace 模式</a></li>
        <li><a href="#42-iptables-模式">4.2 iptables 模式</a></li>
        <li><a href="#43-ipvs-模式">4.3 IPVS 模式</a></li>
      </ul>
    </li>
    <li><a href="#5-networkpolicy-实现">5 NetworkPolicy 实现</a>
      <ul>
        <li><a href="#51-firewall-插件">5.1 firewall 插件</a></li>
      </ul>
    </li>
    <li><a href="#参考">参考</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h2 id="1-网络模型">1 网络模型</h2>
<p>Kubernetes 集群中的网络是虚拟扁平的大网络，Service 与 Pod 的网络有着各自独立的一个网段，每个 Service 与 Pod 占用网段中的一个 IP。Pod 之间可以通过 IP 相互访问，不需要任何的 NAT。</p>
<p>网络作为基础设施有着多种多样的实现，为了适配各种网络访问，Kubernetes 集群不会负责网络的构建，只是定义 CNI 协议，由不同的 CNI Plugin 去构建网络。</p>
<p>为了满足基本的网络模型，Kubernetes 强制要求所有网络设施要满足：</p>
<ul>
<li><important>Pod 能够与其他 Node 上的 Pod 通信，并且不需要 NAT</important>；</li>
<li><important>Node 上的 Agent（例如 System Daemon 或 kubelet）可以和该 Node 上的所有 Pod 通信</important>；</li>
</ul>
<div class="details admonition note open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-pencil-alt fa-fw" aria-hidden="true"></i>Note<i class="details-icon fas fa-angle-right fa-fw" aria-hidden="true"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">这意味着，即使 Pod 使用的 Host Network，也不允许通过 NAT 才能和 Pod 通信。</div>
        </div>
    </div>
<h2 id="2-container-之间的通信">2 Container 之间的通信</h2>
<p>Container 之间的通信指的是：<strong>一个 Pod 内的不同 Container 之间的通信</strong>。</p>
<p>Pod 内所有的 Container 都同属于一个 Network Namespace，Container 共享着网络设备、网络协议栈等等，可以认为 Container 处于同一个 Host 上。</p>
<p>因此，<important>Container 之间的通信是基于 <code>localhost</code> 网络设备的通信</important>。</p>
<h2 id="3-pod-之间的通信">3 Pod 之间的通信</h2>
<p>Pod 之间的通信指的是：<strong>Pod 中的 Container 通过 IP 直接访问另一个 Pod 中的 Container</strong>。</p>
<h3 id="31-核心思想">3.1 核心思想</h3>
<p>在 <a href="../../../docker/how_docker_work/container-network-summary/#23-bridge-%e8%99%9a%e6%8b%9f%e7%bd%91%e7%bb%9c%e8%ae%be%e5%a4%87" rel=""><strong>Docker Bridge 网络</strong></a> 中介绍过 Bridge 网络设备可以作为同 Host 的 Container 之间的网桥，即使 Container 有着独立的 Net Namespace 也可以相互通信。</p>
<p>Pod 之间的网络的核心思想类似：<important>每个 Node 上有着集群级别的 “网桥”，Node 上的所有 Container 都 Veth Pair 连接到这个 “网桥” 上。</important></p>
<a class="lightgallery" href="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img1.png" title="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img1.png" data-thumbnail="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img1.png">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img1.png"
            data-srcset="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img1.png, /posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img1.png 1.5x, /posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img1.png 2x"
            data-sizes="auto"
            alt="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img1.png" width="884" height="250" />
    </a>
<ul>
<li>当同 Node 的 Pod 之间通信时，“网桥” 将数据包直接转发到对应的 Pod 对应的 Container 的 Veth 设备上。</li>
<li>当跨 Node 的 Pod 之间通信时，“网桥” 根据目标地址的网段，将数据包转发到另一个 Node 上的 “网桥”，再由 “网桥” 转发到对应 Container 的 Veth 设备上。</li>
</ul>
<p>通过这种方式在 Node 宿主机网络上，构建出了 Kubernetes 集群的虚拟网络，称之为 <strong>Overlay Network</strong>。</p>
<div class="details admonition note open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-pencil-alt fa-fw" aria-hidden="true"></i>Note<i class="details-icon fas fa-angle-right fa-fw" aria-hidden="true"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">这个特殊的 “网桥” 可以使用软件实现，也能使用硬件实现，总之核心作用就是作为一个网桥。</div>
        </div>
    </div>
<h3 id="32-基于代理的实现">3.2 基于代理的实现</h3>
<p>我们来看最简单的容器网络实现：使用软件实现 “网桥”，来处理数据包的转发。下面以 Flannel UDP 模式为例：</p>
<a class="lightgallery" href="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img3.png" title="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img3.png" data-thumbnail="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img3.png">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img3.png"
            data-srcset="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img3.png, /posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img3.png 1.5x, /posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img3.png 2x"
            data-sizes="auto"
            alt="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img3.png" width="938" height="330" />
    </a>
<p>整体流程如下：</p>
<ol>
<li>
<p>container-1 发送数据包（src:100.96.1.2 dst:100.96.2.3），因为是跨 Node 网段通信，因此根据默认路由交给 Node1 的 docker0 网桥。</p>
</li>
<li>
<p>docker0 是 Node 宿主机的一个网络设备，根据宿主机路由规则，将数据包转发给了 flanneld 网络设备处理。</p>
<p>该路由规则由 flanneld 启动后负责配置。</p>
</li>
<li>
<p>flannel0 是一个 TUN 设备，因此数据包会由 Node 上的一个程序处理，也就是 flanneld。</p>
</li>
<li>
<p>flanneld 收到 container-1 的数据包，根据包的目的地址，搜索 flanneld 记录的所有容器的 IP 网段与 Node 的路由信息，知晓其需要发送给 Node2。</p>
<p>flanneld 会将 IP -&gt; Node 的映射信息保存在你 ETCD 中，因此能够根据 IP 网段知晓对应的 Node。</p>
</li>
<li>
<p>flanneld 将数据包再次封装，以 UDP 方式发送给 Node2 的 flanneld。</p>
</li>
<li>
<p>Node2 的 flanneld 收到数据包后，将其发送给 container-2 容器。根据路由规则，会从 Node2 的 docker0 网桥转发给 container-2。</p>
</li>
</ol>
<p>可以看到，Flannel 负责的有：</p>
<ul>
<li>容器网桥的管理。负责管理 docker0 与 flannel0 的管理。</li>
<li>宿主机路由规则的管理。使得数据包能正确的被转发到 flanneld 上。</li>
<li>维护网络拓步图。记录 IP 网段与 Node 的映射信息，使得能够正确的转发。</li>
<li>跨 Node 传输数据包。通过进一步的封包解包，使得容器数据包能够正确的跨 Node 传输。</li>
</ul>
<p>但是显而易见地，这种多了一次的内核态与用户态的转换，并且 flanneld 的封包解包也会消耗很多的资源。目前 UDP 模式已经废弃。</p>
<h3 id="33-基于三层网络的实现">3.3 基于三层网络的实现</h3>
<p>在 <a href="#32-%e5%9f%ba%e4%ba%8e%e4%bb%a3%e7%90%86%e7%9a%84%e5%ae%9e%e7%8e%b0" rel=""><strong>3.2 基于代理的实现</strong></a> 中，由于使用软件实现网桥，因此从根本上方案性能就很差。</p>
<p>为此，目前主流的方案是直接在 Node 网络中就打通 Container 之间的网络。也就是 Node 网络能够支持转发 Container 网络的数据包。</p>
<p>在这个思路上，有着许多的方案：</p>
<ul>
<li>
<p><strong>VXLAN</strong> - 使用 VXLAN 在 Node 之间构建 “隧道”，当 Container 之间通信时，数据包由 “隧道” 处理传输到另一端。</p>
<p>例如 Flannel 的 VXLAN 模式。</p>
</li>
<li>
<p><strong>Host Route</strong> - 通过配置宿主机上的 Route Table，根据 Node 负责的网段来转发到对应的 Node。</p>
<p>因此，这里的关键点在于：如何配置每个 Node 的 Route Table，使得能够支持转发给所有其他的 Node。</p>
<p>例如 Flannel 的 host-gw 模式，Calico 的 BGP 模式。</p>
</li>
<li>
<p><strong>eBPF</strong> - 通过 eBPF 使得运行在内核态的应用程序来处理转发。</p>
<p>例如 Calico 的 eBPF 模式，Cilium 的 eBPF 模式。</p>
</li>
</ul>
<p>以 Calico 的 BGP 模式为例：</p>
<a class="lightgallery" href="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img4.png" title="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img4.png" data-thumbnail="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img4.png">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img4.png"
            data-srcset="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img4.png, /posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img4.png 1.5x, /posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img4.png 2x"
            data-sizes="auto"
            alt="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img4.png" width="705" height="280" />
    </a>
<p>在 Node 宿主机上，Calico CNI Plugin 为每个 Container 设置一个 Veth Pair 设备：一端在宿主机上（命名为 calixxx），一端作为容器中的 eth0。</p>
<ul>
<li>
<p>Inbound Rule</p>
<p>calixxx 设备为设置一条 Route Rule，用于接收数据包。这样发送给 Container 的数据包到达 Node 时，能够正确地被转发给 Veth Pair 设备，从而发送到 Container 中。</p>
</li>
<li>
<p>Outbound Rule</p>
<p>每个 Node 运行的 Felix 会负责维护 Node 的 Route Rule，将每个 Node 都会被设置一跳 Route Rule。当跨 Node 通信时，基于 Route Table 就能够将数据包转发到对应的 Node 上。</p>
</li>
</ul>
<p>可以看到，Calico 将每个 Node 做当做边界路由器处理，互相之间通过 BGP 协议交换路由信息。每个 Node 也被称为 BGP Peer。</p>
<p>基于学习路由的方式不同，又分为：</p>
<ul>
<li>
<p>Node-to-Node Mesh 模式</p>
<p>每个 Node 的 BGP Client 会和所有 Node 的 BGP Client 通信。也就是说，学习路由的方式是 P2P 的。</p>
<p>但是随着 Node 的增加，Node 之间的连接也会指数的增长。因此该模式一般在 100 节点的集群里使用。</p>
</li>
<li>
<p>Route Reflector 模式</p>
<p>该模式下，Calico 会指定一个或者一部分 Node，来和所有 Node 建立 BGP 连接。其他 Node 只要和专门的 Node 交换路由信息，就可以学习到整个集群的路由了。</p>
</li>
</ul>
<h3 id="34-跨三层网络的实现">3.4 跨三层网络的实现</h3>
<p><a href="#32-%e5%9f%ba%e4%ba%8e%e4%bb%a3%e7%90%86%e7%9a%84%e5%ae%9e%e7%8e%b0" rel=""><strong>3.2 基于代理的实现</strong></a> 与 <a href="#33-%e5%9f%ba%e4%ba%8e%e4%b8%89%e5%b1%82%e7%bd%91%e7%bb%9c%e7%9a%84%e5%ae%9e%e7%8e%b0" rel=""><strong>3.3 基于三层网络的实现</strong></a> 都要求 Node 之间是可以直接访问的。当集群中 Node 不在同一个局域网时，就需要更多的配置了。</p>
<h2 id="4-pod-与-service-之间通信">4 Pod 与 Service 之间通信</h2>
<p>Pod 之间的通信类似于 P2P 的通信模式，Pod 与 Service 之间的通信类似于 C/S 的通信。<strong>Pod 直接访问 Service，数据路由到 Service 背后的 Pod 处理后，通过源 IP 返回数据包</strong>。</p>
<a class="lightgallery" href="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img2.png" title="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img2.png" data-thumbnail="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img2.png">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img2.png"
            data-srcset="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img2.png, /posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img2.png 1.5x, /posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img2.png 2x"
            data-sizes="auto"
            alt="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img2.png" width="560" height="150" />
    </a>
<div class="details admonition note open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-pencil-alt fa-fw" aria-hidden="true"></i>Note<i class="details-icon fas fa-angle-right fa-fw" aria-hidden="true"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><p>通常，Pod 都是通过 Service Domain 来访问 Service 的，因此在向 Service IP 发送请求之前，Pod 先需要访问 DNS Server 进行一次域名解析（DNS Server 地址配置在容器环境中的 <code>/etc/resolv.conf</code> 文件。</p>
<p>下文中不会提到 DNS 解析，其就是一次 Pod 向 Service IP 发送请求的过程。</p>
</div>
        </div>
    </div>
<p>Service 资源的相关概念见 <a href="../service-and-endpoint" rel=""><strong>Kubernetes - Service 与 Endpoint</strong></a>，下面主要介绍 Service 的实现。</p>
<p>Service 是一个虚拟的概念，<important>Service IP 到 Pod IP 的转换是是由每个 Node 上运行的 kube-proxy 组件实现的</important>。</p>
<p>目前，kube-proxy 支持使用三种方式实现 Service：</p>
<ul>
<li>
<p><strong>userspace (deprecated)</strong></p>
<p>Pod 发出的所有数据包都由 kube-proxy 进程接收，kube-proxy 解析包后将其进行转发到 Service 后端的 Pod。</p>
</li>
<li>
<p><strong>iptables (default)</strong></p>
<p>kube-proxy 进程仅仅负责配置 iptables，数据包经过 iptables 时被转发到 Service 后端的 Pod。</p>
</li>
<li>
<p><strong>ipvs</strong></p>
<p>kube-proxy 进程负责配置 IPVS 规则，数据包经过 IPVS 时被赚翻到 Service 后端的 Pod。</p>
</li>
</ul>
<div class="details admonition note open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-pencil-alt fa-fw" aria-hidden="true"></i>Note<i class="details-icon fas fa-angle-right fa-fw" aria-hidden="true"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">目前也有些 CNI Plugin 使用其他的方式实现 Service 机制，而不需要使用 kube-proxy 的实现。</div>
        </div>
    </div>
<h3 id="41-userspace-模式">4.1 userspace 模式</h3>
<p>在 userspace 模式下，kube-proxy 负责：</p>
<ul>
<li>
<p><strong>数据包转发</strong></p>
<p>对于每个 Service，kube-proxy 会在 Node 打开对应的一个端口（随机选择）。任何发送到该端口的请求，都会被 kube-proxy 接收，并转发到 Service 后端的某个 Pod（通过 Endpoints 查询后端 Pod）。</p>
</li>
<li>
<p><strong>配置 iptables</strong></p>
<p>为了能捕获让 Pod 发送给 Service 的请求，kube-proxy 会配置 iptables，使得任何发送给 Service IP/Port 请求会被转发到 kube-proxy 打开的端口。</p>
</li>
</ul>
<p>当 Pod 向 Service IP + Port 发送请求时，iptables 将其转发到同 Node 的 kube-proxy 进程处理，kube-proxy 解析并将其转发给 Service 后端的 Pod。</p>
<a class="lightgallery" href="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img5.png" title="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img5.png" data-thumbnail="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img5.png">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img5.png"
            data-srcset="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img5.png, /posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img5.png 1.5x, /posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img5.png 2x"
            data-sizes="auto"
            alt="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img5.png" width="692" height="350" />
    </a>
<p>可以看到，数据包需要经过 iptables 的转发以及 kube-proxy 进程的处理。也就是说，需要进行一次额外的内核态与用户态的转换来处理数据包。这也就导致了 userspace 模式的性能低下，使得其被废弃。</p>
<h3 id="42-iptables-模式">4.2 iptables 模式</h3>
<p>在 iptables 模式下，kube-proxy 负责：</p>
<ul>
<li>
<p><strong>配置 iptables</strong></p>
<p>为了让发送给 Service 的请求转发后后端的 Pod，kube-proxy 会配置 iptables。</p>
<p>kube-proxy 会 Watch Service 与 Endpoints 对象，同步地更新 iptables。</p>
</li>
</ul>
<p>当 Pod 向 Service IP + Port 发送请求时，由于 kube-proxy 的配置，iptables 会直接将数据包转发到 Service 后端的 Pod。</p>
<a class="lightgallery" href="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img6.png" title="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img6.png" data-thumbnail="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img6.png">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img6.png"
            data-srcset="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img6.png, /posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img6.png 1.5x, /posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img6.png 2x"
            data-sizes="auto"
            alt="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img6.png" width="688" height="350" />
    </a>
<p>可以看到，由于 iptables 负责处理数据包，就不需要额外的内核态与用户态的切换了。</p>
<p>不过，在大量 Service 的情况下，iptables 会有着许多的转发规则，导致转发性能的下降。并且 iptables 的每一次配置都是全量的更新，也会有性能的消耗。这也是 iptables 自身实现的问题。</p>
<h3 id="43-ipvs-模式">4.3 IPVS 模式</h3>
<p>在 IPVS 模式下，kube-proxy 负责：</p>
<ul>
<li>
<p><strong>创建虚拟网卡</strong></p>
<p>对于每一个 Service，kube-proxy 会在 Node 上创建对应的虚拟网卡，并分配 Service IP 作为 IP 地址。</p>
<a class="lightgallery" href="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img7.png" title="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img7.png" data-thumbnail="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img7.png">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img7.png"
            data-srcset="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img7.png, /posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img7.png 1.5x, /posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img7.png 2x"
            data-sizes="auto"
            alt="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img7.png" width="605" height="90" />
    </a>
</li>
<li>
<p><strong>配置 IPVS</strong></p>
<p>对于 Service 后端的所有 Pod，kube-proxy 会在虚拟网卡上配置 IPVS 规则，使得所有后端的 Pod IP 作为 IPVS 虚拟主机。同时设置转发策略。</p>
<a class="lightgallery" href="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img8.png" title="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img8.png" data-thumbnail="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img8.png">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img8.png"
            data-srcset="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img8.png, /posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img8.png 1.5x, /posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img8.png 2x"
            data-sizes="auto"
            alt="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img8.png" width="605" height="120" />
    </a>
</li>
</ul>
<p>当 Pod 向 Service IP + Port 发送请求时，数据包会由 Node 上的虚拟网卡处理，而 IPVS 的配置使得数据包会被转发到 Service 后端的 Pod。</p>
<a class="lightgallery" href="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img9.png" title="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img9.png" data-thumbnail="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img9.png">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img9.png"
            data-srcset="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img9.png, /posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img9.png 1.5x, /posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img9.png 2x"
            data-sizes="auto"
            alt="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/img9.png" width="688" height="350" />
    </a>
<p>IPVS 也是使用的 Linux netfilter 模块实现的。但是对比 iptables 的链式调用，IPVS 底层使用 hash map 来进行数据包的路由，因此性能更高。</p>
<h2 id="5-networkpolicy-实现">5 NetworkPolicy 实现</h2>
<p>Kubernetes 中 Pod 之间的网络默认是完全连通的，每个 Pod 可以向任何 Pod 发送请求，也可以接收任何 Pod 的请求。</p>
<p>如果要对 Pod 之间的网络进行隔离，可以使用 NetworkPolicy 对象。NetworkPolicy 的说明见<a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/network-policies/" target="_blank" rel="noopener noreffer"><strong>官方文档</strong></a>。</p>
<p>NetworkPolicy 功能的实现是由 CNI Plugin 实现的，因此不同的 CNI Plugin 可能有着不同的实现。</p>
<h3 id="51-firewall-插件">5.1 firewall 插件</h3>
<p>Kubernetes 提供了一个通用的 CNI Chained Plugin <a href="https://www.cni.dev/plugins/current/meta/firewall/" target="_blank" rel="noopener noreffer"><strong>firewall</strong></a>，支持配置 iptables 与 firewalld 来限制 Container 的出入流量。因此 CNI Plugin 可以使用该 Plugin 来实现 NetworkPolicy 功能。</p>
<p>以 iptables 为例，其实现就是通过配置 iptables 来允许或拒绝数据包。</p>
<h2 id="参考">参考</h2>
<ul>
<li>Doc：<a href="https://kubernetes.io/docs/concepts/services-networking/" target="_blank" rel="noopener noreffer"><strong>Kubernetes network model</strong></a></li>
<li>Doc：<a href="https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies" target="_blank" rel="noopener noreffer"><strong>Virtual IPs and service proxies</strong></a></li>
<li>Blog: <a href="https://cloud.tencent.com/developer/article/1470033" target="_blank" rel="noopener noreffer"><strong>kube-proxy 模式对比</strong></a></li>
</ul>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2022-09-18&nbsp;<a class="git-hash" href="https://github.com/KanShiori/KanShiori.github.io/commit/01b5e027c390286911febc234984142d39f55b9f" target="_blank" title="commit by Shiori(yshshihaoren@qq.com) 01b5e027c390286911febc234984142d39f55b9f: Post(Operator): new post (#16)">
                                    <i class="fas fa-hashtag fa-fw" aria-hidden="true"></i>01b5e02</a></span>
            </div></div>
        <div class="post-info-line">
            <div class="post-info-md"><span>
                            <a class="link-to-markdown" href="/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/index.md" target="_blank">阅读原始文档</a>
                        </span></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="分享到 Twitter" data-sharer="twitter" data-url="https://KanShiori.github.io/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/" data-title="Kubernetes - 网络设计" data-hashtags="k8s,云计算"><i class="fab fa-twitter fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 Facebook" data-sharer="facebook" data-url="https://KanShiori.github.io/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/" data-hashtag="k8s"><i class="fab fa-facebook-square fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 Hacker News" data-sharer="hackernews" data-url="https://KanShiori.github.io/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/" data-title="Kubernetes - 网络设计"><i class="fab fa-hacker-news fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 Line" data-sharer="line" data-url="https://KanShiori.github.io/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/" data-title="Kubernetes - 网络设计"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@6.20.0/icons/line.svg" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="https://KanShiori.github.io/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/" data-title="Kubernetes - 网络设计"><i class="fab fa-weibo fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 百度" data-sharer="baidu" data-url="https://KanShiori.github.io/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/" data-title="Kubernetes - 网络设计"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@6.20.0/icons/baidu.svg" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 Evernote" data-sharer="evernote" data-url="https://KanShiori.github.io/posts/cloud/cloud_native/kubernetes/k8s_learning/container-network/" data-title="Kubernetes - 网络设计"><i class="fab fa-evernote fa-fw" aria-hidden="true"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;<a href="/tags/k8s/">k8s</a>,&nbsp;<a href="/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/">云计算</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/cloud/cloud_practice/kubebuilder/" class="prev" rel="prev" title="使用 KubeBuilder 编写 Controller"><i class="fas fa-angle-left fa-fw" aria-hidden="true"></i>使用 KubeBuilder 编写 Controller</a>
            <a href="/posts/cloud/cloud_native/kubernetes/k8s_programming/thinking-in-opeator/" class="next" rel="next" title="Thinking in Operator">Thinking in Operator<i class="fas fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
</article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><i class="far fa-copyright fa-fw" aria-hidden="true"></i><span itemprop="copyrightYear">2020 - 2022</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank">Shiori</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw" aria-hidden="true"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw" aria-hidden="true"></i>
            </a>
        </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@2.4.0/css/lightgallery-bundle.min.css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/algoliasearch@4.13.0/dist/algoliasearch-lite.umd.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.1/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lightgallery@2.4.0/lightgallery.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lightgallery@2.4.0/plugins/thumbnail/lg-thumbnail.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lightgallery@2.4.0/plugins/zoom/lg-zoom.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":35},"comment":{},"lightgallery":true,"search":{"algoliaAppID":"9NJS0VQU0I","algoliaIndex":"blog","algoliaSearchKey":"85d62ea65a7f7445fbfb413bdca088f2","highlightTag":"em","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"algolia"}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
