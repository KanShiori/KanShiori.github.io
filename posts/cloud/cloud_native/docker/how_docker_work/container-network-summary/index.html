<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <title>容器网络总结 - Shiori&#39;s Blog</title><meta name="Description" content="描述 docker 下容器网络模型与实现"><meta property="og:title" content="容器网络总结" />
<meta property="og:description" content="描述 docker 下容器网络模型与实现" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://KanShiori.github.io/posts/cloud/cloud_native/docker/how_docker_work/container-network-summary/" /><meta property="og:image" content="https://KanShiori.github.io/icons/favicon-16x16.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-11-06T20:40:51+08:00" />
<meta property="article:modified_time" content="2022-11-01T22:18:28+08:00" /><meta property="og:site_name" content="My cool site" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://KanShiori.github.io/icons/favicon-16x16.png"/>

<meta name="twitter:title" content="容器网络总结"/>
<meta name="twitter:description" content="描述 docker 下容器网络模型与实现"/>
<meta name="application-name" content="Shiori&#39;s Blog">
<meta name="apple-mobile-web-app-title" content="Shiori&#39;s Blog"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="icon" href="/icons/favicon.ico"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://KanShiori.github.io/posts/cloud/cloud_native/docker/how_docker_work/container-network-summary/" /><link rel="prev" href="https://KanShiori.github.io/posts/cloud/vm/%E5%88%B6%E4%BD%9C%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%95%9C%E5%83%8F/" /><link rel="next" href="https://KanShiori.github.io/posts/cloud/cloud_native/docker/how_docker_work/container-start-stop-summary/" /><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css"></noscript><link rel="preload" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css"></noscript><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "容器网络总结",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/KanShiori.github.io\/posts\/cloud\/cloud_native\/docker\/how_docker_work\/container-network-summary\/"
        },"image": ["https:\/\/KanShiori.github.io\/images\/Apple-Devices-Preview.png"],"genre": "posts","keywords": "docker, container","wordcount":  5486 ,
        "url": "https:\/\/KanShiori.github.io\/posts\/cloud\/cloud_native\/docker\/how_docker_work\/container-network-summary\/","datePublished": "2020-11-06T20:40:51+08:00","dateModified": "2022-11-01T22:18:28+08:00","license": "This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher": {
            "@type": "Organization",
            "name": "xxxx","logo": "https:\/\/KanShiori.github.io\/images\/avatar.png"},"author": {
                "@type": "Person",
                "name": "Shiori"
            },"description": "描述 docker 下容器网络模型与实现"
    }
    </script></head>
    <body data-header-desktop="fixed" data-header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="Shiori&#39;s Blog"><img
        class="lazyload logo"
        src="/svg/loading.min.svg"
        data-src="/icons/favicon-32x32.png"
        data-srcset="/icons/favicon-32x32.png, /icons/favicon-32x32.png 1.5x, /icons/favicon-32x32.png 2x"
        data-sizes="auto"
        alt="/icons/favicon-32x32.png"
        title="/icons/favicon-32x32.png" />Shiori&#39;s Blog</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="http://kanshiori.cn" rel="noopener noreffer" target="_blank"> 主页 </a><a class="menu-item" href="/posts/"> 所有文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><a class="menu-item" href="/about/"> 关于 </a><a class="menu-item" href="https://github.com/KanShiori/KanShiori.github.io" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i>  </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="Shiori&#39;s Blog"><img
        class="lazyload logo"
        src="/svg/loading.min.svg"
        data-src="/icons/favicon-32x32.png"
        data-srcset="/icons/favicon-32x32.png, /icons/favicon-32x32.png 1.5x, /icons/favicon-32x32.png 2x"
        data-sizes="auto"
        alt="/icons/favicon-32x32.png"
        title="/icons/favicon-32x32.png" />Shiori&#39;s Blog</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="http://kanshiori.cn" title="" rel="noopener noreffer" target="_blank">主页</a><a class="menu-item" href="/posts/" title="">所有文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a class="menu-item" href="/about/" title="">关于</a><a class="menu-item" href="https://github.com/KanShiori/KanShiori.github.io" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i></a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a></div>
    </div>
</header><div class="search-dropdown desktop">
        <div id="search-dropdown-desktop"></div>
    </div>
    <div class="search-dropdown mobile">
        <div id="search-dropdown-mobile"></div>
    </div><main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">容器网络总结</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>Shiori</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/docker-%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>Docker 原理总结</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw" aria-hidden="true"></i>&nbsp;<time datetime="2020-11-06">2020-11-06</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden="true"></i>&nbsp;约 5486 字&nbsp;
                <i class="far fa-clock fa-fw" aria-hidden="true"></i>&nbsp;预计阅读 11 分钟&nbsp;</div>
        </div><div class="details toc" id="toc-static"  data-kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right" aria-hidden="true"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#1-概览">1 概览</a></li>
    <li><a href="#2-背景知识">2 背景知识</a>
      <ul>
        <li><a href="#21-cgroup-与-namespace">2.1 cgroup 与 namespace</a></li>
        <li><a href="#22-docker-如何使用-net-namespace">2.2 docker 如何使用 net namespace</a></li>
        <li><a href="#23-bridge-虚拟网络设备">2.3 bridge 虚拟网络设备</a></li>
        <li><a href="#24-veth-pair-虚拟网络设备">2.4 veth-pair 虚拟网络设备</a></li>
        <li><a href="#25-macvlan-虚拟网络设备">2.5 macvlan 虚拟网络设备</a></li>
      </ul>
    </li>
    <li><a href="#3-bridge-网络">3 Bridge 网络</a>
      <ul>
        <li><a href="#31-创建删除-bridge-网络">3.1 创建/删除 Bridge 网络</a>
          <ul>
            <li><a href="#1-创建网络">(1) 创建网络</a></li>
            <li><a href="#2-删除网络">(2) 删除网络</a></li>
          </ul>
        </li>
        <li><a href="#32-启动容器后的网络">3.2 启动容器后的网络</a></li>
        <li><a href="#33-bridge-网络总结">3.3 bridge 网络总结</a></li>
      </ul>
    </li>
    <li><a href="#4-host-网络">4 Host 网络</a></li>
    <li><a href="#5-macvlan-网络">5 macvlan 网络</a>
      <ul>
        <li><a href="#51--创建删除-macvlan-网络">5.1  创建/删除 macvlan 网络</a></li>
        <li><a href="#52-启停容器后的网络">5.2 启停容器后的网络</a></li>
        <li><a href="#53-总结">5.3 总结</a></li>
      </ul>
    </li>
    <li><a href="#参考">参考</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><blockquote>
<p><strong>总结系列的文章</strong>是自己的学习或使用后，对相关知识的一个总结，用于后续可以快速复习与回顾。</p>
</blockquote>
<p>本文是对自己使用过的 docker 使用的网络模式的原理的总结。</p>
<h2 id="1-概览">1 概览</h2>
<p>docker 容器网络目前包含 5 中模式，包括：</p>
<ul>
<li><strong><code>bridge</code></strong>：默认的网络模式，使用 bridge 虚拟网卡 + iptables 实现一个内地内网，所有容器都处于该内网内，并且可以相互访问；</li>
<li><strong><code>host</code></strong>：与宿主机处于同一个 net namespace，使用宿主机网络环境；</li>
<li><strong><code>overlay</code></strong>：在多个 docker daemon 之间建立 overlay 网络，使得不同 docker daemon 的容器之间可以相互通信；</li>
<li><strong><code>macvlan</code></strong>：使用 macvlan 虚拟网卡，将容器物理地址暴露在宿主机局域网中，你可以认为就是一台同局域网的物理机；</li>
<li><strong><code>none</code></strong>：不进行任何网络配置，通常与自定义网络 driver 配合使用；</li>
</ul>
<p>除了上述模式之外，每个容器也可以加入其它容器的网络中（通过加入对应的 net namespace）。</p>
<p>docker 还支持使用自定义的网络插件，这块不了解，具体见官方文档。</p>
<p>下面所有示例都在虚拟机 ubuntu 20.04 与内核 5.4.0-52-generic 中完成，docker 版本如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="nv">$docker</span> version
Client:
 Version:           19.03.8
 API version:       1.40
 Go version:        go1.13.8
 Git commit:        afacb8b7f0
 Built:             Wed Oct <span class="m">14</span> 19:43:43 <span class="m">2020</span>
 OS/Arch:           linux/amd64
 Experimental:      <span class="nb">false</span>

Server:
 Engine:
  Version:          19.03.8
  API version:      1.40 <span class="o">(</span>minimum version 1.12<span class="o">)</span>
  Go version:       go1.13.8
  Git commit:       afacb8b7f0
  Built:            Wed Oct <span class="m">14</span> 16:41:21 <span class="m">2020</span>
  OS/Arch:          linux/amd64
  Experimental:     <span class="nb">false</span>
 containerd:
  Version:          1.3.3-0ubuntu2
  GitCommit:
 runc:
  Version:          spec: 1.0.1-dev
  GitCommit:
 docker-init:
  Version:          0.18.0
  GitCommit:
</code></pre></td></tr></table>
</div>
</div><h2 id="2-背景知识">2 背景知识</h2>
<h3 id="21-cgroup-与-namespace">2.1 cgroup 与 namespace</h3>
<p>这部分网上知识很多，这里就不复制别人的了。</p>
<h3 id="22-docker-如何使用-net-namespace">2.2 docker 如何使用 net namespace</h3>
<p><strong><code>namespace</code></strong> 用于各个进程间的环境的隔离，而容器运行（非 host 与 container 模式）的就是处于一个独立的 net namespace。</p>
<p>当处于一个 net namespace 时，可以认为，内核协议栈、iptables(net_filter)、网络设备等与其他 net namespace 都是隔离的。（这里只是说可以这么认为，但是真正还是只有一个内核，内核为 namespace 做了逻辑上的隔离）</p>
<p>在容器运行之间，docker 就会创建容器对应的 net namespace，并构建好对应的网络，然后将其 &lsquo;持久化&rsquo;（因为默认 namespace 是随着进程消失而消失的，如果想进程消失而 namespace 存在，那么需要将其 mount 到一个文件上）。</p>
<p>例如，当我们创建了一个容器后，可以看到这么一个挂载：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ mount
…
nsfs on /run/docker/netns/9779108cb6b0 <span class="nb">type</span> nsfs <span class="o">(</span>rw<span class="o">)</span>
</code></pre></td></tr></table>
</div>
</div><p>该文件就是对应 net namespace 的挂载，通过对比容器进程的 netns inode 与 文件 inode 可以证明：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ docker top br0_container
UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD
root                <span class="m">92658</span>               <span class="m">92640</span>               <span class="m">0</span>                   Nov06               pts/0               00:00:00            /bin/bash

$ ls -lhi  /proc/92658/ns/net
<span class="m">474863</span> lrwxrwxrwx <span class="m">1</span> root root <span class="m">0</span> Nov  <span class="m">7</span> 12:42 /proc/92658/ns/net -&gt; <span class="s1">&#39;net:[4026532287]&#39;</span>

<span class="c1"># 文件 inode 与进程 net 指向 inode 相同</span>
$ ls -lhi /run/docker/netns/9779108cb6b0
<span class="m">4026532287</span> -r--r--r-- <span class="m">1</span> root root <span class="m">0</span> Nov  <span class="m">6</span> 19:47 /run/docker/netns/9779108cb6b0
</code></pre></td></tr></table>
</div>
</div><p>在容器被删除后，对应  net namespace 就会被销毁。</p>
<p>而各个网络模式最大的不同，就是在于 namespace 创建后，对应的 &ldquo;构建网络&rdquo; 的操作了。</p>
<h3 id="23-bridge-虚拟网络设备">2.3 bridge 虚拟网络设备</h3>
<p><strong><code>bridge 网络设备</code></strong> 相当于一个 &ldquo;交换机&rdquo;，让任何其他网络设备链接上 bridge 时，所有包的都会无条件经过 bridge 转发，而链接的网络设备就变成了一根 &ldquo;网线&rdquo;。</p>
<p>不过与真实的交换机不同，brdige 网卡可以被赋值 IP，当 bridge 拥有 IP 后，它就与内核协议栈连接了，因此接收到的包可以到达内核协议栈的 IP 层处理，也就会经过 net_filter 处理。
<div class="details admonition tip open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-lightbulb fa-fw" aria-hidden="true"></i>推荐阅读<i class="details-icon fas fa-angle-right fa-fw" aria-hidden="true"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">bridge 网卡推荐阅读：<a href="https://segmentfault.com/a/1190000009491002" target="_blank" rel="noopener noreffer">Linux 虚拟网络设备之 bridge（桥）</a></div>
        </div>
    </div></p>
<h3 id="24-veth-pair-虚拟网络设备">2.4 veth-pair 虚拟网络设备</h3>
<p><strong><code>veth-pair 设备</code></strong> 总是成对的出现，当数据包进入一端 veth 设备时，会从另一端 veth 设备出。veth-pair 两个设备可以处于不同的 net namespace，也就可以实现不同 net namespace 间数据传输。</p>
<p>默认下，veth 设备链接的两端是内核协议栈。不过 veth 设备链接上 bridge，这样另一端发送的数据都会由 bridge 处理。</p>
<div class="details admonition tip open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-lightbulb fa-fw" aria-hidden="true"></i>推荐阅读<i class="details-icon fas fa-angle-right fa-fw" aria-hidden="true"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">veth-pair 设备了解推荐文章：<a href="https://segmentfault.com/a/1190000009251098" target="_blank" rel="noopener noreffer">Linux 虚拟网络设备之 veth</a></div>
        </div>
    </div>
<h3 id="25-macvlan-虚拟网络设备">2.5 macvlan 虚拟网络设备</h3>
<p><strong><code>macvlan 网络设备</code></strong> 可以有 mac 地址与 ip 地址，用于将 net namespace 连接到宿主机的物理网络中，相当于，容器直接连接着物理网络。</p>
<p>macvlan 网络设备有着多种的模式，包括：bridge、private 等，这影响着各个 macvlan 网络设备之间的通信。</p>
<p>更多 macvlan 网络设备推荐文章：<a href="https://developers.redhat.com/blog/2018/10/22/introduction-to-linux-interfaces-for-virtual-networking/" target="_blank" rel="noopener noreffer">Linux interfaces for virtual networking</a></p>
<h2 id="3-bridge-网络">3 Bridge 网络</h2>
<h3 id="31-创建删除-bridge-网络">3.1 创建/删除 Bridge 网络</h3>
<h4 id="1-创建网络">(1) 创建网络</h4>
<p>先试着创建一个自定义的 bridge 网络，观察 docker 会对应创建哪些东西。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ docker network create --driver<span class="o">=</span>bridge <span class="se">\
</span><span class="se"></span>	--subnet<span class="o">=</span>192.168.100.0/24 <span class="se">\
</span><span class="se"></span>	--ip-range<span class="o">=</span>192.168.100.0/26 <span class="se">\
</span><span class="se"></span>	--gateway<span class="o">=</span>192.168.100.1 <span class="se">\
</span><span class="se"></span>	--opt com.docker.network.bridge.name<span class="o">=</span>mybr0 <span class="se">\
</span><span class="se"></span>	mybridge0
2e61a7dc333c1bc61d9cb86503ce4cd5a7435977ea2f9b7cc97fc71ae0e2bb93
</code></pre></td></tr></table>
</div>
</div><ul>
<li><code>--driver=bridge</code> 指定创建的网络 driver；</li>
<li><code>--subnet=192.168.100.0/24</code> 指定对应 bridge 网络的网段；</li>
<li><code>--ip-range=192.168.100.0/26</code> 指定运行分配给容器的 ip 范围，当然，这个是要在指定的网段内的；</li>
<li><code>--gateway=192.168.100.1</code> 指定该内网的网关 IP；</li>
<li><code>--opt com.docker.network.bridge.name=mybr0</code> 指定创建虚拟 bridge 网卡的命名；</li>
<li><code>mybridge0</code> 为创建的 docker network 的命名；</li>
</ul>
<p>通过 <code>ifconfig</code> 可以看到，bridge 网络创建会对应创建一个 <strong>bridge 网络设备</strong>，作为整个内网的 &lsquo;交换机&rsquo;。其 IP 就是指定的 gateway IP。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ ifconfig
…
mybr0: <span class="nv">flags</span><span class="o">=</span>4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu <span class="m">1500</span>
        inet 192.168.100.1  netmask 255.255.255.0  broadcast 192.168.100.255
        ether 02:42:46:8a:cf:34  txqueuelen <span class="m">0</span>  <span class="o">(</span>Ethernet<span class="o">)</span>
        RX packets <span class="m">0</span>  bytes <span class="m">0</span> <span class="o">(</span>0.0 B<span class="o">)</span>
        RX errors <span class="m">0</span>  dropped <span class="m">0</span>  overruns <span class="m">0</span>  frame <span class="m">0</span>
        TX packets <span class="m">0</span>  bytes <span class="m">0</span> <span class="o">(</span>0.0 B<span class="o">)</span>
        TX errors <span class="m">0</span>  dropped <span class="m">0</span> overruns <span class="m">0</span>  carrier <span class="m">0</span>  collisions <span class="m">0</span>
…

$ brctl show
bridge name     bridge id               STP enabled     interfaces
mybr0           8000.0242efdb0984       no
</code></pre></td></tr></table>
</div>
</div><p>但是与虚拟机网络中的 bridge 网卡不同，该 bridge 不会连接任何的物理网卡，仅仅是作为内网的 &lsquo;交换机&rsquo; 使用。但是，毕竟内网是虚拟的，没有实际与物理网络连接，如何访问外网呢？</p>
<p>答案是，<strong>通过内核 iptables 进行 NAT，然后将包从实际的物理网卡上发送与接受</strong>。因此还有一部分的改变在于 iptables，主要会建立的是 nat 与 filter 表的规则。</p>
<p>先看 nat 表的相关规则（下面输出中省略了不相关规则）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$  iptables -t nat -L  -nv
Chain PREROUTING <span class="o">(</span>policy ACCEPT <span class="m">2</span> packets, <span class="m">88</span> bytes<span class="o">)</span>
target     prot opt in     out     <span class="nb">source</span>               destination
DOCKER     all  --  *      *       0.0.0.0/0            0.0.0.0/0            ADDRTYPE match dst-type LOCAL

Chain INPUT <span class="o">(</span>policy ACCEPT <span class="m">2</span> packets, <span class="m">88</span> bytes<span class="o">)</span>
target     prot opt in     out     <span class="nb">source</span>               destination

Chain OUTPUT <span class="o">(</span>policy ACCEPT <span class="m">124</span> packets, <span class="m">8797</span> bytes<span class="o">)</span>
target     prot opt in     out     <span class="nb">source</span>               destination
DOCKER     all  --  *      *       0.0.0.0/0           !127.0.0.0/8          ADDRTYPE match dst-type LOCAL

Chain POSTROUTING <span class="o">(</span>policy ACCEPT <span class="m">124</span> packets, <span class="m">8797</span> bytes<span class="o">)</span>
target                prot opt in     out     <span class="nb">source</span>               destination
MASQUERADE  all     --   *      !mybr0  192.168.100.0/24     0.0.0.0/0

Chain DOCKER <span class="o">(</span><span class="m">2</span> references<span class="o">)</span>
target       prot opt in     out     <span class="nb">source</span>               destination
RETURN     all  --  mybr0  *       0.0.0.0/0            0.0.0.0/0
</code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>PREROUTING 与 OUTPUT 链中规则，使得所有入和出的包都会经过 <strong>DOCKER</strong> 链；</p>
</li>
<li>
<p>POSTROUTING 链中，将 mybridge0 网络（192.168.100.0/24）的内网 ip 通过 <strong>MASQUERADE</strong> 行为进行伪装（可以简单认为内网 ip 会变为当前网卡的 ip）；</p>
<p>当然，如果包发往的是 mybr0 网卡，说明是 mybridge0 网络内部通信，就不需要进行 MASQUERADE 伪装（!mybr0）；</p>
</li>
</ul>
<p>当容器发包时，会通过 mybr0 网卡转发进入内核栈，因此在 filter 表中，相关的规则都是针对于 &ldquo;in=mybr0&rdquo;。看一下 filter 表的规则：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ iptables -t filter -L  -nv
Chain INPUT <span class="o">(</span>policy ACCEPT <span class="m">61774</span> packets, 79M bytes<span class="o">)</span>

Chain FORWARD <span class="o">(</span>policy ACCEPT <span class="m">0</span> packets, <span class="m">0</span> bytes<span class="o">)</span>
target     prot opt in     out     <span class="nb">source</span>               destination
DOCKER-USER  all  --  *      *       0.0.0.0/0            0.0.0.0/0
DOCKER-ISOLATION-STAGE-1  all  --  *      *       0.0.0.0/0            0.0.0.0/0
ACCEPT     all  --  *      mybr0   0.0.0.0/0            0.0.0.0/0            ctstate RELATED,ESTABLISHED
DOCKER     all  --  *      mybr0   0.0.0.0/0            0.0.0.0/0
ACCEPT     all  --  mybr0  !mybr0  0.0.0.0/0            0.0.0.0/0
ACCEPT     all  --  mybr0  mybr0   0.0.0.0/0            0.0.0.0/0

Chain OUTPUT <span class="o">(</span>policy ACCEPT <span class="m">42290</span> packets, 55M bytes<span class="o">)</span>
target     prot opt in     out     <span class="nb">source</span>               destination

Chain DOCKER <span class="o">(</span><span class="m">2</span> references<span class="o">)</span>
target     prot opt in     out     <span class="nb">source</span>               destination

Chain DOCKER-ISOLATION-STAGE-1 <span class="o">(</span><span class="m">1</span> references<span class="o">)</span>
target     prot opt in     out     <span class="nb">source</span>               destination
DOCKER-ISOLATION-STAGE-2  all  --  mybr0  !mybr0  0.0.0.0/0            0.0.0.0/0
RETURN     all  --  *      *       0.0.0.0/0            0.0.0.0/0

Chain DOCKER-ISOLATION-STAGE-2 <span class="o">(</span><span class="m">2</span> references<span class="o">)</span>
target     prot opt in     out     <span class="nb">source</span>               destination
DROP       all  --  *      mybr0   0.0.0.0/0            0.0.0.0/0
RETURN     all  --  *      *       0.0.0.0/0            0.0.0.0/0

Chain DOCKER-USER <span class="o">(</span><span class="m">1</span> references<span class="o">)</span>
target     prot opt in     out     <span class="nb">source</span>               destination
RETURN     all  --  *      *       0.0.0.0/0            0.0.0.0/0
</code></pre></td></tr></table>
</div>
</div><ul>
<li>FORWARD -&gt; DOCKER-ISOLATION-STAGE-1 -&gt; DOCKER-ISOLATION-STAGE-2 表明允许包从 mybr0 进入并转发（即容器可以向外正常发包）；</li>
<li>FORWARD 中对 mybr0 进入的包设置了 <strong>conntrack</strong>，使得能够收到连接建立后的正常的回包；</li>
</ul>
<h4 id="2-删除网络">(2) 删除网络</h4>
<p>通过 <code>docker network remove</code> 删除网络时，会发现对应的 bridge 网卡与 iptables 规则都被删除。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ docker network remove 5a17670afb6f
5a17670afb6f
</code></pre></td></tr></table>
</div>
</div><h3 id="32-启动容器后的网络">3.2 启动容器后的网络</h3>
<p>下面看下容器启停后，带来的网络变化。先启动最简单的一个容器，指定使用网络为上面创建的 mybridge0。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ docker run -dt --rm --network<span class="o">=</span>mybridge0 --name br0_container ubuntu
676f7f9eab12a20fb3a975fa99cc2c92433a9581b5774ea58e63d447d86aa5ad
$ docker inspect 676f7f9eab12
…
        <span class="s2">&#34;Networks&#34;</span>: <span class="o">{</span>
                <span class="s2">&#34;mybridge0&#34;</span>: <span class="o">{</span>
                    <span class="s2">&#34;IPAMConfig&#34;</span>: null,
                    <span class="s2">&#34;Links&#34;</span>: null,
                    <span class="s2">&#34;Aliases&#34;</span>: <span class="o">[</span>
                        <span class="s2">&#34;882cac3e472f&#34;</span>
                    <span class="o">]</span>,
                    <span class="s2">&#34;NetworkID&#34;</span>: <span class="s2">&#34;af1dbf619ac62be1ad8a6b63696d3e6edff77cceab6cd0ee78de4b51e0d33683&#34;</span>,
                    <span class="s2">&#34;EndpointID&#34;</span>: <span class="s2">&#34;56cd85c5121d7d14146fcacc75599f6c56034e758e81f405a51437276ac6ac9f&#34;</span>,
                    <span class="s2">&#34;Gateway&#34;</span>: <span class="s2">&#34;192.168.100.1&#34;</span>,
                    <span class="s2">&#34;IPAddress&#34;</span>: <span class="s2">&#34;192.168.100.2&#34;</span>,
                    <span class="s2">&#34;IPPrefixLen&#34;</span>: 24,
                    <span class="s2">&#34;IPv6Gateway&#34;</span>: <span class="s2">&#34;&#34;</span>,
                    <span class="s2">&#34;GlobalIPv6Address&#34;</span>: <span class="s2">&#34;&#34;</span>,
                    <span class="s2">&#34;GlobalIPv6PrefixLen&#34;</span>: 0,
                    <span class="s2">&#34;MacAddress&#34;</span>: <span class="s2">&#34;02:42:c0:a8:64:02&#34;</span>,
                    <span class="s2">&#34;DriverOpts&#34;</span>: null
                <span class="o">}</span>
            <span class="o">}</span>
…
</code></pre></td></tr></table>
</div>
</div><ul>
<li><code>--network=mybridge0</code> 表明以 mybridge0 网络启动容器；</li>
<li>观察容器具体参数，可以看到，容器被随机分配 mybridge0 设置的 ip-range 一个 ip，并且 gateway 就是 mybridge0 网络的网关地址；</li>
</ul>
<p>观察网络设备，可以看到一个 <strong>veth-pair 设备</strong> 出现在宿主机上，并且连接到了 mybr0 网卡：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ ifconfig
…
vethef6b174: <span class="nv">flags</span><span class="o">=</span>4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu <span class="m">1500</span>
        inet6 fe80::e8ad:86ff:fefe:14ca  prefixlen <span class="m">64</span>  scopeid 0x20&lt;link&gt;
        ether ea:ad:86:fe:14:ca  txqueuelen <span class="m">0</span>  <span class="o">(</span>Ethernet<span class="o">)</span>
        RX packets <span class="m">0</span>  bytes <span class="m">0</span> <span class="o">(</span>0.0 B<span class="o">)</span>
        RX errors <span class="m">0</span>  dropped <span class="m">0</span>  overruns <span class="m">0</span>  frame <span class="m">0</span>
        TX packets <span class="m">23</span>  bytes <span class="m">1882</span> <span class="o">(</span>1.8 KB<span class="o">)</span>
        TX errors <span class="m">0</span>  dropped <span class="m">0</span> overruns <span class="m">0</span>  carrier <span class="m">0</span>  collisions <span class="m">0</span>
…

$ brctl show
bridge name     bridge id               STP enabled     interfaces
mybr0           8000.0242efdb0984       no              vethef6b174
</code></pre></td></tr></table>
</div>
</div><p>veth-pair 都是成对出现的，可以简单被看做一个通道，一端发入的包会从另一端发出，并进入内核协议栈。不过，在 bridge 网络环境下，veth5b480f8 连接到 mybr0，所以所有从 veth5b480f8 发出的包都会被 mybr0 接手转发（相当于就是一根网线插入了交换机）。</p>
<p>可以进入容器 namespace，看一下容器内的 veth 设备。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ docker <span class="nb">exec</span> -it br0_container bash

<span class="c1"># 以下在容器 namesapce 环境执行</span>
root@676f7f9eab12:/# ifconfig
eth0: <span class="nv">flags</span><span class="o">=</span>4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu <span class="m">1500</span>
        inet 192.168.100.2  netmask 255.255.255.0  broadcast 192.168.100.255
        ether 02:42:c0:a8:64:02  txqueuelen <span class="m">0</span>  <span class="o">(</span>Ethernet<span class="o">)</span>
        RX packets <span class="m">1928</span>  bytes <span class="m">21609413</span> <span class="o">(</span>21.6 MB<span class="o">)</span>
        RX errors <span class="m">0</span>  dropped <span class="m">0</span>  overruns <span class="m">0</span>  frame <span class="m">0</span>
        TX packets <span class="m">1817</span>  bytes <span class="m">102779</span> <span class="o">(</span>102.7 KB<span class="o">)</span>
        TX errors <span class="m">0</span>  dropped <span class="m">0</span> overruns <span class="m">0</span>  carrier <span class="m">0</span>  collisions <span class="m">0</span>
root@676f7f9eab12:/sys/class/net/eth0# ethtool -i eth0
driver: veth
version: 1.0
firmware-version:
expansion-rom-version:
bus-info:
supports-statistics: yes
supports-test: no
supports-eeprom-access: no
supports-register-dump: no
supports-priv-flags: no
root@676f7f9eab12:~# cat /sys/class/net/eth0/iflink
<span class="m">15</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>在容器内的仅仅有一个 eth0 网卡，ip 设置为了容器的 ip。但是其实这个网卡就是 veth 设备改了名字；</li>
<li>通过 <code>ethtool -i eth0</code> 命令看到，其对应 driver 是 veth，并且 <em>/sys/class/net/eth0/iflink</em> 文件表明了对端的 veth 网卡编号为 15（即宿主机看到的 veth 网卡设备）；</li>
</ul>
<p>现在，我们试着启动容器并添加一个 tcp 端口映射。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ docker run -dt --rm <span class="se">\ </span>
    --network<span class="o">=</span>mybridge0 --publish 12211:8080 <span class="se">\
</span><span class="se"></span>    --name br0_container ubuntu
2502f7397a37e2ab482f8a9152d1ed968dd2e2825c71eb2a6737e4900f7236c1
</code></pre></td></tr></table>
</div>
</div><p>而这个端口映射，就是将宿主机的 12211 端口映射给容器的 8080，所以所有发往宿主机的 12211 端口的包，都会被修改端口并转发到容器内部。这也是通过 iptables 实现的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">iptables -t nat -L  -nv
Chain PREROUTING <span class="o">(</span>policy ACCEPT <span class="m">0</span> packets, <span class="m">0</span> bytes<span class="o">)</span>
target     prot opt in     out     <span class="nb">source</span>               destination
DOCKER     all  --  *      *       0.0.0.0/0            0.0.0.0/0            ADDRTYPE match dst-type LOCAL

Chain INPUT <span class="o">(</span>policy ACCEPT <span class="m">0</span> packets, <span class="m">0</span> bytes<span class="o">)</span>
target     prot opt in     out     <span class="nb">source</span>               destination

Chain OUTPUT <span class="o">(</span>policy ACCEPT <span class="m">0</span> packets, <span class="m">0</span> bytes<span class="o">)</span>
target     prot opt in     out     <span class="nb">source</span>               destination
DOCKER     all  --  *      *       0.0.0.0/0           !127.0.0.0/8          ADDRTYPE match dst-type LOCAL

Chain POSTROUTING <span class="o">(</span>policy ACCEPT <span class="m">0</span> packets, <span class="m">0</span> bytes<span class="o">)</span>
 pkts bytes target     prot opt in     out     <span class="nb">source</span>               destination
   <span class="m">10</span>   <span class="m">617</span> MASQUERADE  all  --  *      !mybr0  192.168.100.0/24     0.0.0.0/0
    <span class="m">0</span>     <span class="m">0</span> MASQUERADE  tcp  --  *      *       192.168.100.2        192.168.100.2        tcp dpt:8080

Chain DOCKER <span class="o">(</span><span class="m">2</span> references<span class="o">)</span>
 pkts bytes target     prot opt in     out     <span class="nb">source</span>               destination
    <span class="m">0</span>     <span class="m">0</span> RETURN     all  --  mybr0  *       0.0.0.0/0            0.0.0.0/0
    <span class="m">0</span>     <span class="m">0</span> DNAT       tcp  --  !mybr0 *       0.0.0.0/0            0.0.0.0/0            tcp dpt:12211 to:192.168.100.2:8080
</code></pre></td></tr></table>
</div>
</div><ul>
<li>PREROUTING  -&gt; DOCKER 链中，所有不是从 mybr0 进入的包，并且发往 tcp 12211 端口的包，都会被 <strong>DNAT</strong> 为发往 192.168.100.2:8080。这样就实现了端口映射的功能。</li>
</ul>
<h3 id="33-bridge-网络总结">3.3 bridge 网络总结</h3>
<p>中心思想：bridge 网络使用 bridge 网卡创建了一个本地的内网，而 bridge 网卡 + iptables 规则成为了这个内网的 &lsquo;<strong>路由器</strong>'。其中：</p>
<ul>
<li>bridge 网卡作为二层的交换机，bridge 网卡 ip 作为路由器的网关 ip。</li>
<li>iptables 规则实现了 brdige 网卡与物理网络的连接</li>
<li>宿主机内核栈实现了这个 &lsquo;路由器&rsquo; 的路由功能。</li>
</ul>
<p>下图展示了整个 bridge 网络的模型（图片来自网络）：








    <br><img src="/posts/cloud/cloud_native/docker/how_docker_work/container-network-summary/img1.png"/>


</p>
<p>其中比较关键的点：</p>
<ol>
<li>veth pair 设备将容器 net namespace 连接到 bridge 网卡（可以看做将 veth pair 作为网线插到了 bridge 这个 &lsquo;路由器&rsquo; 上）。</li>
<li>iptables 实现了 bridge 网卡与物理网络的 &lsquo;连接&rsquo;。
bridge 网卡收到的包，经过 iptables 的 MASQUERADE 将包进行地址转换，并经过内核协议栈的路由通过物理网卡发送到物理网络。而回包通过 conntrack 机制正常接收与逆地址转换。</li>
<li>容器与宿主机的端口映射，也是通过 iptables 的 DNAT 实现的。</li>
</ol>
<h2 id="4-host-网络">4 Host 网络</h2>
<p>Host 网络没啥好说的，启动容器不创建新的 namespace，依旧在宿主机的 net namespace 下。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ docker run -dt --rm --network<span class="o">=</span>host  --name host_container ubuntu
da1c426a7c7501b329258b12cb475ff42669837ca686d6e946511632461cc946
</code></pre></td></tr></table>
</div>
</div><p>观察 mount，可以看到对应还是有 net namespace 的文件挂载，文件名为 default：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ mount
…
nsfs on /run/docker/netns/default <span class="nb">type</span> nsfs <span class="o">(</span>rw<span class="o">)</span>
</code></pre></td></tr></table>
</div>
</div><p>文件 inode 对比当前宿主机 net namespace inode，是一致的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ ls -lh /proc/self/ns/net
lrwxrwxrwx <span class="m">1</span> root root <span class="m">0</span> Nov  <span class="m">7</span> 14:47 /proc/self/ns/net -&gt; <span class="s1">&#39;net:[4026531992]&#39;</span>
$ ls -lhi  /run/docker/netns/default
<span class="m">4026531992</span> -r--r--r-- <span class="m">1</span> root root <span class="m">0</span> Oct <span class="m">30</span> 16:50 /run/docker/netns/default
</code></pre></td></tr></table>
</div>
</div><h2 id="5-macvlan-网络">5 macvlan 网络</h2>
<p>macvlan 网络使用 macvlan 虚拟网络设备，将容器 net namespace 网络暴露在与当前宿主机同级的局域网内，相当于容器就是当前网络内的一台 &ldquo;主机&rdquo;。</p>
<p>macvlan 网络设备也包括多种模式：bridge mode、802.1q trunk bridge mode。下面示例都是基于普通的 brdige mode。</p>
<p>因为 macvlan 网络在虚拟机网络下不太好验证，所以下面例子来自于一台物理机上。</p>
<h3 id="51--创建删除-macvlan-网络">5.1  创建/删除 macvlan 网络</h3>
<p>通过 <code>docker network create</code> 创建 macvlan 网络。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ docker network create -d macvlan <span class="se">\
</span><span class="se"></span>    --subnet<span class="o">=</span>192.168.67.130/24 --gateway<span class="o">=</span>192.168.67.1 <span class="se">\
</span><span class="se"></span>    -o <span class="nv">parent</span><span class="o">=</span>eth0 mymacvlan0
633aae3d4f430352e5439e2650c02fe9c2092b99b5b8252f8141fa5d62ec7e70
</code></pre></td></tr></table>
</div>
</div><ul>
<li><code>-d macvlan</code>，指定 macvlan 网络</li>
<li><code>-subnet=192.168.67.130/24</code>，因为 macvlan 网络下的容器会直接连入物理网络，所以子网也是要在当前子网内；</li>
<li><code>--gateway=192.168.67.1</code>，同样，gateway 就是宿主机的网关地址；</li>
<li><code>-o parent=eth0</code>，指定 macvlan 设备链接的物理网卡，一定要是一个真正可联网的物理网卡；</li>
</ul>
<p>不过与 bridge 网络不同的是，创建一个 macvlan 网络仅仅是记录其对应的配置，不会创建对应的 macvlan 网卡或者 iptables 规则。因为 macvlan 网卡是与 net namespace 绑定的，所以当创建 net namespace 时才会出现对应网络设备。</p>
<h3 id="52-启停容器后的网络">5.2 启停容器后的网络</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ docker run --net<span class="o">=</span>mymacvlan0 <span class="se">\
</span><span class="se"></span>    -dt --rm --name macvlan_container <span class="se">\
</span><span class="se"></span>    --ip<span class="o">=</span>192.168.67.139  --privileged  <span class="se">\
</span><span class="se"></span>    centos_ctr  bash
2eff4835733734b6819c7f97ae41585985d95c1ea4c66a6a478a43e71b60b6d6
</code></pre></td></tr></table>
</div>
</div><p>启动容器，如果不指定 IP，Docker 会在配置的网段里分配一个。
<div class="details admonition tip open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-lightbulb fa-fw" aria-hidden="true"></i>tip<i class="details-icon fas fa-angle-right fa-fw" aria-hidden="true"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">为了能够方便排查网络问题，使用的容器镜像 <strong>centos_ctr</strong> 是由 centos 镜像以 host 网络启动，预装一些命令后，才由容器导出的镜像。</div>
        </div>
    </div>
但是发现进入容器后，发现静态配置 IP 无法 ping 通网关（宿主机是正常无法 ping 通，因为内核会丢弃 macvlan 网卡的包）。研究后不清楚具体原因，但是这台宿主机接的是交换机，不知道是不是不是路由器导致的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ docker <span class="nb">exec</span> -it  macvlan_container bash

<span class="c1"># 以下是容器中命令</span>
<span class="o">[</span>root@2eff48357337 /<span class="o">]</span><span class="c1"># ifconfig</span>
eth0: <span class="nv">flags</span><span class="o">=</span>4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu <span class="m">1500</span>
        inet 192.168.67.139  netmask 255.255.255.0  broadcast 192.168.67.255
        ether 02:42:c0:a8:43:8b  txqueuelen <span class="m">0</span>  <span class="o">(</span>Ethernet<span class="o">)</span>
        RX packets <span class="m">433282</span>  bytes <span class="m">27463954</span> <span class="o">(</span>26.1 MiB<span class="o">)</span>
        RX errors <span class="m">0</span>  dropped <span class="m">26809</span>  overruns <span class="m">0</span>  frame <span class="m">0</span>
        TX packets <span class="m">91342</span>  bytes <span class="m">6649728</span> <span class="o">(</span>6.3 MiB<span class="o">)</span>
        TX errors <span class="m">0</span>  dropped <span class="m">0</span> overruns <span class="m">0</span>  carrier <span class="m">0</span>  collisions <span class="m">0</span>

<span class="o">[</span>root@2eff48357337 /<span class="o">]</span><span class="c1"># ping 192.168.67.1</span>
PING 192.168.67.1 <span class="o">(</span>192.168.67.1<span class="o">)</span> 56<span class="o">(</span>84<span class="o">)</span> bytes of data.
From 192.168.67.139 <span class="nv">icmp_seq</span><span class="o">=</span><span class="m">1</span> Destination Host Unreachable
From 192.168.67.139 <span class="nv">icmp_seq</span><span class="o">=</span><span class="m">2</span> Destination Host Unreachable
</code></pre></td></tr></table>
</div>
</div><p>因此，换个思路，静态 IP 不行，就通过 DHCP 获取一个 IP 尝试是否能够连通网络。</p>
<p>在删除静态 IP 之后，调用 <code>dhclient</code> 从上层路由器获取一个 IP。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># 删除 eth0 网卡 IP</span>
<span class="o">[</span>root@2eff48357337 /<span class="o">]</span><span class="c1"># ip address del 192.168.67.139 dev eth0</span>
Warning: Executing wildcard deletion to stay compatible with old scripts.
         Explicitly specify the prefix length <span class="o">(</span>192.168.67.139/32<span class="o">)</span> to avoid this warning.
         This special behaviour is likely to disappear in further releases,
         fix your scripts!
<span class="o">[</span>root@2eff48357337 /<span class="o">]</span><span class="c1"># ifconfig</span>
eth0: <span class="nv">flags</span><span class="o">=</span>4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu <span class="m">1500</span>
        ether 02:42:c0:a8:43:8b  txqueuelen <span class="m">0</span>  <span class="o">(</span>Ethernet<span class="o">)</span>
        RX packets <span class="m">435540</span>  bytes <span class="m">27608133</span> <span class="o">(</span>26.3 MiB<span class="o">)</span>
        RX errors <span class="m">0</span>  dropped <span class="m">26983</span>  overruns <span class="m">0</span>  frame <span class="m">0</span>
        TX packets <span class="m">91763</span>  bytes <span class="m">6678670</span> <span class="o">(</span>6.3 MiB<span class="o">)</span>
        TX errors <span class="m">0</span>  dropped <span class="m">0</span> overruns <span class="m">0</span>  carrier <span class="m">0</span>  collisions <span class="m">0</span>

<span class="c1"># 调用 dhclient 获取新的 IP</span>
<span class="o">[</span>root@2eff48357337 /<span class="o">]</span><span class="c1"># dhclient -r &amp;&amp; dhclient -v</span>
Removed stale PID file
Internet Systems Consortium DHCP Client 4.3.6
Copyright 2004-2017 Internet Systems Consortium.
All rights reserved.
For info, please visit https://www.isc.org/software/dhcp/

Listening on LPF/eth0/02:42:c0:a8:43:8b
Sending on   LPF/eth0/02:42:c0:a8:43:8b
Sending on   Socket/fallback
DHCPDISCOVER on eth0 to 255.255.255.255 port <span class="m">67</span> interval <span class="m">3</span> <span class="o">(</span><span class="nv">xid</span><span class="o">=</span>0xdf4e0e25<span class="o">)</span>
DHCPREQUEST on eth0 to 255.255.255.255 port <span class="m">67</span> <span class="o">(</span><span class="nv">xid</span><span class="o">=</span>0xdf4e0e25<span class="o">)</span>
DHCPOFFER from 192.168.9.253
DHCPACK from 192.168.9.253 <span class="o">(</span><span class="nv">xid</span><span class="o">=</span>0xdf4e0e25<span class="o">)</span>
System has not been booted with systemd as init system <span class="o">(</span>PID 1<span class="o">)</span>. Can<span class="err">&#39;</span>t operate.
Failed to create bus connection: Host is down
bound to 192.168.9.235 -- renewal in <span class="m">38783</span> seconds.
<span class="o">[</span>root@2eff48357337 /<span class="o">]</span><span class="c1"># ifconfig</span>
eth0: <span class="nv">flags</span><span class="o">=</span>4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu <span class="m">1500</span>
        inet 192.168.9.235  netmask 255.255.255.0  broadcast 192.168.9.255
        ether 02:42:c0:a8:43:8b  txqueuelen <span class="m">0</span>  <span class="o">(</span>Ethernet<span class="o">)</span>
        RX packets <span class="m">435635</span>  bytes <span class="m">27614880</span> <span class="o">(</span>26.3 MiB<span class="o">)</span>
        RX errors <span class="m">0</span>  dropped <span class="m">27001</span>  overruns <span class="m">0</span>  frame <span class="m">0</span>
        TX packets <span class="m">91767</span>  bytes <span class="m">6679438</span> <span class="o">(</span>6.3 MiB<span class="o">)</span>
        TX errors <span class="m">0</span>  dropped <span class="m">0</span> overruns <span class="m">0</span>  carrier <span class="m">0</span>  collisions <span class="m">0</span>
<span class="o">[</span>root@2eff48357337 /<span class="o">]</span><span class="c1"># route -n</span>
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         192.168.9.253   0.0.0.0         UG    <span class="m">0</span>      <span class="m">0</span>        <span class="m">0</span> eth0
192.168.9.0     0.0.0.0         255.255.255.0   U     <span class="m">0</span>      <span class="m">0</span>        <span class="m">0</span> eth0
</code></pre></td></tr></table>
</div>
</div><p>可以看到，DHCP 获得的 IP 与宿主机都不是同一个网段的，并且网关地址也不是同一个，因此上层连着交换机有多个网段（这块不太理解了）。</p>
<p>但是，测试后是可以 ping 通网关，并且可以访问外网的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span>root@2eff48357337 /<span class="o">]</span><span class="c1"># ping 192.168.9.253</span>
PING 192.168.9.253 <span class="o">(</span>192.168.9.253<span class="o">)</span> 56<span class="o">(</span>84<span class="o">)</span> bytes of data.
<span class="m">64</span> bytes from 192.168.9.253: <span class="nv">icmp_seq</span><span class="o">=</span><span class="m">1</span> <span class="nv">ttl</span><span class="o">=</span><span class="m">64</span> <span class="nv">time</span><span class="o">=</span>0.637 ms
<span class="m">64</span> bytes from 192.168.9.253: <span class="nv">icmp_seq</span><span class="o">=</span><span class="m">2</span> <span class="nv">ttl</span><span class="o">=</span><span class="m">64</span> <span class="nv">time</span><span class="o">=</span>0.250 ms
</code></pre></td></tr></table>
</div>
</div><h3 id="53-总结">5.3 总结</h3>
<p>中心思想：将 macvlan 网络启动容器看做一个与宿主机同级的网络，其获取 IP 方式都与正常的机器相同。</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://docs.docker.com/network/" target="_blank" rel="noopener noreffer">Docker 容器网络官方文档</a></li>
<li><a href="https://segmentfault.com/a/1190000009491002" target="_blank" rel="noopener noreffer">Linux 虚拟网络设备之 bridge（桥）</a></li>
<li><a href="https://developers.redhat.com/blog/2018/10/22/introduction-to-linux-interfaces-for-virtual-networking/" target="_blank" rel="noopener noreffer">Linux interfaces for virtual networking</a></li>
</ul>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2022-11-01&nbsp;<a class="git-hash" href="https://github.com/KanShiori/KanShiori.github.io/commit/e32723a8c2c99a43774fad6e71a63a944c3b08ba" target="_blank" title="commit by Shiori(yshshihaoren@qq.com) e32723a8c2c99a43774fad6e71a63a944c3b08ba: Post(Access Resource across Clouds) (#17)">
                                    <i class="fas fa-hashtag fa-fw" aria-hidden="true"></i>e32723a</a></span>
            </div></div>
        <div class="post-info-line">
            <div class="post-info-md"><span>
                            <a class="link-to-markdown" href="/posts/cloud/cloud_native/docker/how_docker_work/container-network-summary/index.md" target="_blank">阅读原始文档</a>
                        </span></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="分享到 Twitter" data-sharer="twitter" data-url="https://KanShiori.github.io/posts/cloud/cloud_native/docker/how_docker_work/container-network-summary/" data-title="容器网络总结" data-hashtags="docker,container"><i class="fab fa-twitter fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 Facebook" data-sharer="facebook" data-url="https://KanShiori.github.io/posts/cloud/cloud_native/docker/how_docker_work/container-network-summary/" data-hashtag="docker"><i class="fab fa-facebook-square fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 Hacker News" data-sharer="hackernews" data-url="https://KanShiori.github.io/posts/cloud/cloud_native/docker/how_docker_work/container-network-summary/" data-title="容器网络总结"><i class="fab fa-hacker-news fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 Line" data-sharer="line" data-url="https://KanShiori.github.io/posts/cloud/cloud_native/docker/how_docker_work/container-network-summary/" data-title="容器网络总结"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@6.20.0/icons/line.svg" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="https://KanShiori.github.io/posts/cloud/cloud_native/docker/how_docker_work/container-network-summary/" data-title="容器网络总结"><i class="fab fa-weibo fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 百度" data-sharer="baidu" data-url="https://KanShiori.github.io/posts/cloud/cloud_native/docker/how_docker_work/container-network-summary/" data-title="容器网络总结"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@6.20.0/icons/baidu.svg" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 Evernote" data-sharer="evernote" data-url="https://KanShiori.github.io/posts/cloud/cloud_native/docker/how_docker_work/container-network-summary/" data-title="容器网络总结"><i class="fab fa-evernote fa-fw" aria-hidden="true"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;<a href="/tags/docker/">docker</a>,&nbsp;<a href="/tags/container/">container</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/cloud/vm/%E5%88%B6%E4%BD%9C%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%95%9C%E5%83%8F/" class="prev" rel="prev" title="制作虚拟机镜像"><i class="fas fa-angle-left fa-fw" aria-hidden="true"></i>制作虚拟机镜像</a>
            <a href="/posts/cloud/cloud_native/docker/how_docker_work/container-start-stop-summary/" class="next" rel="next" title="容器启停原理总结">容器启停原理总结<i class="fas fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
</article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><i class="far fa-copyright fa-fw" aria-hidden="true"></i><span itemprop="copyrightYear">2020 - 2022</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank">Shiori</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw" aria-hidden="true"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw" aria-hidden="true"></i>
            </a>
        </div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/algoliasearch@4.13.0/dist/algoliasearch-lite.umd.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.1/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":35},"comment":{},"search":{"algoliaAppID":"9NJS0VQU0I","algoliaIndex":"blog","algoliaSearchKey":"85d62ea65a7f7445fbfb413bdca088f2","highlightTag":"em","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"algolia"}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
