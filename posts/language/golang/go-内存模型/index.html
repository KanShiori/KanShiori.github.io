<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>Go 内存模型 - Shiori&#39;s Blog</title><meta name="Description" content="Shiori&#39;s Blog"><meta property="og:title" content="Go 内存模型" />
<meta property="og:description" content="本文是对 Golang 内存模型与内存管理的一个总结，基本内容来源于《Go 学习笔记》。 下面代码都是基于 go 1.15.6。 1 Linux 内存模型 所有语言的内存管理，在 Linux" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://KanShiori.github.io/posts/language/golang/go-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" />
<meta property="og:image" content="https://KanShiori.github.io/icons/favicon-16x16.png"/>
<meta property="article:published_time" content="2021-01-05T18:28:41+08:00" />
<meta property="article:modified_time" content="2021-01-05T18:28:41+08:00" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://KanShiori.github.io/icons/favicon-16x16.png"/>

<meta name="twitter:title" content="Go 内存模型"/>
<meta name="twitter:description" content="本文是对 Golang 内存模型与内存管理的一个总结，基本内容来源于《Go 学习笔记》。 下面代码都是基于 go 1.15.6。 1 Linux 内存模型 所有语言的内存管理，在 Linux"/>
<meta name="application-name" content="Shiori&#39;s Blog">
<meta name="apple-mobile-web-app-title" content="Shiori&#39;s Blog"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="icon" href="/icons/favicon.ico"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://KanShiori.github.io/posts/language/golang/go-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" /><link rel="prev" href="https://KanShiori.github.io/posts/cloud_computing/vm/kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%BD%91%E7%BB%9C/" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Go 内存模型",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/KanShiori.github.io\/posts\/language\/golang\/go-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B\/"
        },"image": ["https:\/\/KanShiori.github.io\/images\/Apple-Devices-Preview.png"],"genre": "posts","keywords": "Golang, Golang 原理","wordcount":  8831 ,
        "url": "https:\/\/KanShiori.github.io\/posts\/language\/golang\/go-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B\/","datePublished": "2021-01-05T18:28:41+08:00","dateModified": "2021-01-05T18:28:41+08:00","license": "This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher": {
            "@type": "Organization",
            "name": "xxxx","logo": "https:\/\/KanShiori.github.io\/images\/avatar.png"},"author": {
                "@type": "Person",
                "name": "Shiori"
            },"description": ""
    }
    </script></head>
    <body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="Shiori&#39;s Blog"><img
        class="lazyload logo"
        src="/svg/loading.min.svg"
        data-src="/icons/favicon-32x32.png"
        data-srcset="/icons/favicon-32x32.png, /icons/favicon-32x32.png 1.5x, /icons/favicon-32x32.png 2x"
        data-sizes="auto"
        alt="/icons/favicon-32x32.png"
        title="/icons/favicon-32x32.png" />Shiori&#39;s Blog</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/"> 主页 </a><a class="menu-item" href="/posts/"> 所有文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><a class="menu-item" href="/about/"> 关于 </a><a class="menu-item" href="https://github.com/KanShiori/KanShiori.github.io" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i>  </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="Shiori&#39;s Blog"><img
        class="lazyload logo"
        src="/svg/loading.min.svg"
        data-src="/icons/favicon-32x32.png"
        data-srcset="/icons/favicon-32x32.png, /icons/favicon-32x32.png 1.5x, /icons/favicon-32x32.png 2x"
        data-sizes="auto"
        alt="/icons/favicon-32x32.png"
        title="/icons/favicon-32x32.png" />Shiori&#39;s Blog</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/" title="">主页</a><a class="menu-item" href="/posts/" title="">所有文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a class="menu-item" href="/about/" title="">关于</a><a class="menu-item" href="https://github.com/KanShiori/KanShiori.github.io" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i></a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">Go 内存模型</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>Shiori</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/golang/"><i class="far fa-folder fa-fw"></i>Golang</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2021-01-05">2021-01-05</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 8831 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 18 分钟&nbsp;<span id="/posts/language/golang/go-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" class="leancloud_visitors" data-flag-title="Go 内存模型">
                        <i class="far fa-eye fa-fw"></i>&nbsp;<span class=leancloud-visitors-count></span>&nbsp;次阅读
                    </span>&nbsp;</div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#1-linux-内存模型">1 Linux 内存模型</a></li>
    <li><a href="#2-pc-与-sp">2 PC 与 SP</a>
      <ul>
        <li><a href="#21-pc">2.1 PC</a></li>
        <li><a href="#22-sp">2.2 SP</a></li>
      </ul>
    </li>
    <li><a href="#3-goroutine-栈">3 Goroutine 栈</a>
      <ul>
        <li><a href="#31-新-g-的栈">3.1 新 G 的栈</a></li>
        <li><a href="#32-栈的分配">3.2 栈的分配</a></li>
        <li><a href="#33-栈的扩容">3.3 栈的扩容</a>
          <ul>
            <li><a href="#331-扩容判断">3.3.1 扩容判断</a></li>
            <li><a href="#332-扩容">3.3.2 扩容</a></li>
          </ul>
        </li>
        <li><a href="#34-栈的释放">3.4 栈的释放</a></li>
        <li><a href="#35-栈的切换">3.5 栈的切换</a></li>
        <li><a href="#36-g0-的栈">3.6 g0 的栈</a></li>
      </ul>
    </li>
    <li><a href="#4-内存模型">4 内存模型</a>
      <ul>
        <li><a href="#41-概览">4.1 概览</a></li>
        <li><a href="#42-mspan">4.2 mspan</a>
          <ul>
            <li><a href="#421-object-分配">4.2.1 object 分配</a></li>
            <li><a href="#422-object-的释放">4.2.2 object 的释放</a></li>
          </ul>
        </li>
        <li><a href="#43-mcache">4.3 mcache</a>
          <ul>
            <li><a href="#431-mspan-的分配">4.3.1 mspan 的分配</a></li>
            <li><a href="#432-mspan-的获取">4.3.2 mspan 的获取</a></li>
          </ul>
        </li>
        <li><a href="#44-mcentral">4.4 mcentral</a>
          <ul>
            <li><a href="#441-从-mcentral-申请-mspan">4.4.1 从 mcentral 申请 mspan</a></li>
            <li><a href="#442-mcentral-扩容">4.4.2 mcentral 扩容</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><p>本文是对 Golang 内存模型与内存管理的一个总结，基本内容来源于《Go 学习笔记》。
下面代码都是基于 go 1.15.6。</p>
<h2 id="1-linux-内存模型">1 Linux 内存模型</h2>
<p>所有语言的内存管理，在 Linux 上都是在以基本的进程内存模型基础上实现的，首先需要知道 Linux 进程内存布局。</p>
<p>在进程角度，看到的所有内存就是 <strong><ruby>虚拟地址空间<rt>virtual address space</rt></ruby></strong> ，整个是一个线性的存储地址。其中一部分高地址区域用户态无法访问，是内核地址空间。而另一部分就是由栈、mmap、堆等内存区域组成的用户地址空间。








    <br><img src="/posts/language/golang/go-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/img1.png"/><br>



上面进程可以自己分配与管理的进程，就是 mmap 与 堆，对应的系统调用为 <strong><code>mmap()</code></strong> 与 <strong><code>brk()</code></strong>，因此所有语言的内存管理都是基于这两个内存区域在进一步实现的（包括 glibc 的 malloc() 与 free()）。</p>
<p>mmap 最基本有两个用途：</p>
<ul>
<li><code>文件映射</code> ：申请一块内存区域，映射到文件系统上一个文件（这也是 page_cache 的基本原理，所以他们在内核中都使用 address_space 实现）</li>
<li><code>匿名映射</code> ：申请一块内存区域，但是没有映射到具体文件，相当于分配了一块内存区域（可以用于父子进程共享、或者自己管理内存的分配等功能）</li>
</ul>
<p>而所有在内存上所说的地址，包括代码指令地址、变量地址都是上面地址空间的一个地址。</p>
<h2 id="2-pc-与-sp">2 PC 与 SP</h2>
<p>Goroutine 将进程的切换变为了协程间的切换，那么就需要<strong>在用户空间负责执行代码与协程上下文的保留与切换</strong>。因此，有两个关键的寄存器：PC 与 SP。</p>
<h3 id="21-pc">2.1 PC</h3>
<p><strong><ruby>程序计数器 PC<rt>Program Counter</rt></ruby></strong> 是 CPU 中的一个寄存器，<strong>保存着下一个 CPU 执行的指令的位置</strong>。顺序执行指令时，PC = PC + 1（一个指令）。而调用函数或者条件跳转时，会将跳到的指令地址设置到 PC 中。</p>
<p>所以，可以想到，当需要切换执行的 goroutine，调用 JMP 指令跳转到 G 对应的代码。</p>
<h3 id="22-sp">2.2 SP</h3>
<p><strong><ruby>栈顶指针 SP<rt>stack pointer</rt></ruby></strong> 是<strong>保存栈顶地址的寄存器</strong>，我们平时所说的临时变量在栈上，就是将临时变量的值写入 SP 保存的内存地址，然后 SP 保存的地址减小（栈是从高地址向低地址变化），然后临时变量销毁时，SP 地址又变为高地址。</p>
<p>不过，因为 goroutine 切换时，必须要保存当前 goroutine 的上下文，也就是栈里的变量。因此，goroutine 栈肯定是不能使用 Linux 进程栈了（因为进程栈有上限，也无法实现“保存”这种功能）。所以所说的<strong>协程栈，都是基于 mmap 申请内存空间</strong>（基于 Go 内存管理，内存管理基于 mmap），然后<strong>切换时修改 SP 寄存器地址实现的</strong>。</p>
<p>这也是为什么 goroutine 栈可以“无限大”的原因了。</p>
<h2 id="3-goroutine-栈">3 Goroutine 栈</h2>
<p>整体的一个 G 的栈如下图所示：








    <br><img src="/posts/language/golang/go-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/img2.png"/><br>


</p>
<ul>
<li><code>stack.lo</code>： G 栈的最大低地址（也就是上限）；</li>
<li><code>stack.hi</code>：G 栈的初始地址；</li>
<li><code>stackguard0</code>：阈值地址，用于判断 G 栈是否需要扩容；</li>
<li>StackGuard：常量，栈的保护区，也就是预留的地址；</li>
<li>StackSmall：常量，用于小函数调用的优化；</li>
</ul>
<p>先看一下 g 的实现中包含的 stack 属性（runtime/runtime2.go），其实注释写的就很明白了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">g</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// Stack parameters.
</span><span class="c1"></span>	<span class="c1">// stack describes the actual stack memory: [stack.lo, stack.hi).
</span><span class="c1"></span>	<span class="c1">// stackguard0 is the stack pointer compared in the Go stack growth prologue.
</span><span class="c1"></span>	<span class="c1">// It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption.
</span><span class="c1"></span>	<span class="c1">// stackguard1 is the stack pointer compared in the C stack growth prologue.
</span><span class="c1"></span>	<span class="c1">// It is stack.lo+StackGuard on g0 and gsignal stacks.
</span><span class="c1"></span>	<span class="c1">// It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash).
</span><span class="c1"></span>	<span class="nx">stack</span>       <span class="nx">stack</span>   <span class="c1">// offset known to runtime/cgo
</span><span class="c1"></span>	<span class="nx">stackguard0</span> <span class="kt">uintptr</span> <span class="c1">// offset known to liblink
</span><span class="c1"></span>    <span class="nx">stackguard1</span> <span class="kt">uintptr</span> <span class="c1">// offset known to liblink
</span><span class="c1"></span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li><code>stack</code> 属性就是 G 对应的栈了（这也表明了不是使用的进程栈）；</li>
</ul>
<div class="details admonition note open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-pencil-alt fa-fw"></i>Note<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">stack 与 stackguard0 属性一定要在 g 结构的开头，因为汇编中会使用指定的偏移(0x10)来获取对应的值;</div>
        </div>
    </div>
<p>具体看一下 stack 结构（runtime/runtime2.go）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Stack describes a Go execution stack.
</span><span class="c1">// The bounds of the stack are exactly [lo, hi),
</span><span class="c1">// with no implicit data structures on either side.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">stack</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">lo</span> <span class="kt">uintptr</span>
	<span class="nx">hi</span> <span class="kt">uintptr</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="31-新-g-的栈">3.1 新 G 的栈</h3>
<p>在 <strong>malg</strong> 函数中，可以看到对于新 G 的栈的分配（一开始为 2KB）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Allocate a new g, with a stack big enough for stacksize bytes.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">malg</span><span class="p">(</span><span class="nx">stacksize</span> <span class="kt">int32</span><span class="p">)</span> <span class="o">*</span><span class="nx">g</span> <span class="p">{</span>
	<span class="nx">newg</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">g</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">stacksize</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">stacksize</span> <span class="p">=</span> <span class="nf">round2</span><span class="p">(</span><span class="nx">_StackSystem</span> <span class="o">+</span> <span class="nx">stacksize</span><span class="p">)</span>
		
		<span class="c1">// 在公共的 goroutine(g0) 上调用函数
</span><span class="c1"></span>		<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		    <span class="c1">// 分配一个 stack
</span><span class="c1"></span>			<span class="nx">newg</span><span class="p">.</span><span class="nx">stack</span> <span class="p">=</span> <span class="nf">stackalloc</span><span class="p">(</span><span class="nb">uint32</span><span class="p">(</span><span class="nx">stacksize</span><span class="p">))</span>
		<span class="p">})</span>
		
		<span class="c1">// 设置 stackguard0 地址
</span><span class="c1"></span>		<span class="nx">newg</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">newg</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">+</span> <span class="nx">_StackGuard</span>
		<span class="nx">newg</span><span class="p">.</span><span class="nx">stackguard1</span> <span class="p">=</span> <span class="p">^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
		<span class="c1">// Clear the bottom word of the stack. We record g
</span><span class="c1"></span>		<span class="c1">// there on gsignal stack during VDSO on ARM and ARM64.
</span><span class="c1"></span>		<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">newg</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="p">))</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">newg</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="details admonition note open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-pencil-alt fa-fw"></i>Note<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><p>注意 <strong><code>systemstack()</code></strong>，用于将当前栈切换到 M 的 g0 协程栈上执行命令。</p>
<p>Why? 因为 G 用于执行用户逻辑，而某些管理操作不方便在 G 栈上执行（例如 G 可能中途停止，垃圾回收时 G 栈空间也有可能被回收），所以需要执行管理命令时，都会通过 systemstack 方法将线程栈切换为 g0 的栈执行，与用户逻辑隔离。</p>
</div>
        </div>
    </div>
<h3 id="32-栈的分配">3.2 栈的分配</h3>
<p><code>stackalloc()</code> 函数用于分配一个栈，无论是给新 G 还是扩容栈时都会用到，因此栈空间的分配与回收是一个比较频繁的操作，所以栈空间采取了缓存复用的方式。</p>
<p>主要逻辑如下：</p>
<ol>
<li>如果分配的栈空间不大，就走<strong>缓存复用</strong>这种方式分配。没有可以复用的就创建；</li>
<li>如果分配的栈空间很大（大于 32KB），就直接从 heap 分配；</li>
</ol>
<p>这里主要关注第 1 中方式，会调用 <code>stackpoolalloc()</code> 函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Allocates a stack from the free pool. Must be called with
</span><span class="c1">// stackpool[order].item.mu held.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">stackpoolalloc</span><span class="p">(</span><span class="nx">order</span> <span class="kt">uint8</span><span class="p">)</span> <span class="nx">gclinkptr</span> <span class="p">{</span>
	<span class="nx">list</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">stackpool</span><span class="p">[</span><span class="nx">order</span><span class="p">].</span><span class="nx">item</span><span class="p">.</span><span class="nx">span</span>
    <span class="nx">s</span> <span class="o">:=</span> <span class="nx">list</span><span class="p">.</span><span class="nx">first</span>
    
	<span class="c1">// ...
</span><span class="c1"></span>    
    <span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// 没有可以复用的栈，走内存管理创建
</span><span class="c1"></span>		<span class="nx">s</span> <span class="p">=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nf">allocManual</span><span class="p">(</span><span class="nx">_StackCacheSize</span><span class="o">&gt;&gt;</span><span class="nx">_PageShift</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">stacks_inuse</span><span class="p">)</span>
		<span class="c1">// ... 
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="nx">x</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">manualFreeList</span>
	<span class="k">if</span> <span class="nx">x</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;span has no free stacks&#34;</span><span class="p">)</span>
	<span class="p">}</span>
    <span class="nx">s</span><span class="p">.</span><span class="nx">manualFreeList</span> <span class="p">=</span> <span class="nx">x</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">next</span>
    
	<span class="c1">// ...
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">x</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看到，首先尝试从 stackpool 缓存的空闲的 stack 获取，如果没有则走 Go 内存管理申请一个。</p>
<p>再接下来就是 Go 内存管理模块负责的事了，<del>不深入下去</del>（后面再说）。底层创建都是使用 mmap 系统调用实现的，这里可以看下使用的参数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Don&#39;t split the stack as this method may be invoked without a valid G, which
</span><span class="c1">// prevents us from allocating more stack.
</span><span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">sysAlloc</span><span class="p">(</span><span class="nx">n</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">sysStat</span> <span class="o">*</span><span class="kt">uint64</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
	<span class="nx">p</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">mmap</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">_PROT_READ</span><span class="p">|</span><span class="nx">_PROT_WRITE</span><span class="p">,</span> <span class="nx">_MAP_ANON</span><span class="p">|</span><span class="nx">_MAP_PRIVATE</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">_EACCES</span> <span class="p">{</span>
			<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: mmap: access denied\n&#34;</span><span class="p">)</span>
			<span class="nf">exit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">_EAGAIN</span> <span class="p">{</span>
			<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: mmap: too much locked memory (check &#39;ulimit -l&#39;).\n&#34;</span><span class="p">)</span>
			<span class="nf">exit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="nf">mSysStatInc</span><span class="p">(</span><span class="nx">sysStat</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">p</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>通过 mmap 调用的参数可以看到，申请了一个系统分配的<strong>匿名内存映射</strong>。</p>
<h3 id="33-栈的扩容">3.3 栈的扩容</h3>
<h4 id="331-扩容判断">3.3.1 扩容判断</h4>
<p>Go 编译器会在执行函数前，插入一些汇编指令，其中一个功能就是<strong>检查 G 栈是否需要扩容</strong>。看一个函数调用的实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// main() 调用 test()
</span><span class="c1"></span><span class="err">$</span> <span class="k">go</span> <span class="nx">build</span> <span class="o">-</span><span class="nx">gcflags</span> <span class="s">&#34;-l&#34;</span> <span class="o">-</span><span class="nx">o</span> <span class="nx">test</span> <span class="nx">main</span><span class="p">.</span><span class="k">go</span>
<span class="err">$</span> <span class="k">go</span> <span class="nx">tool</span> <span class="nx">objump</span> <span class="o">-</span><span class="nx">s</span> <span class="s">&#34;main\.test&#34;</span> <span class="nx">test</span>
<span class="nx">TEXT</span> <span class="nx">main</span><span class="p">.</span><span class="nf">test</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span> <span class="o">/</span><span class="nx">root</span><span class="o">/</span><span class="nx">yusihao</span><span class="o">/</span><span class="nx">onething</span><span class="o">/</span><span class="nx">BizImages</span><span class="o">/</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span>
  <span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">3</span> <span class="mh">0x45dc80</span> <span class="nx">MOVQ</span> <span class="nx">FS</span><span class="p">:</span><span class="mh">0xfffffff8</span><span class="p">,</span> <span class="nx">CX</span>  <span class="c1">// CX 为当前 G 地址		
</span><span class="c1"></span>  <span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">3</span> <span class="mh">0x45dc89</span> <span class="nx">CMPQ</span> <span class="mh">0x10</span><span class="p">(</span><span class="nx">CX</span><span class="p">),</span> <span class="nx">SP</span>  	 <span class="c1">// CX+0x10 执行 g.stackguard0 属性，与 SP 指针地址比较	
</span><span class="c1"></span>  <span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">3</span> <span class="mh">0x45dc8d</span> <span class="nx">JBE</span> <span class="mh">0x45dccf</span>	 	     <span class="c1">// 如果 SP &lt;=stackguard0  跳转到 0x45dccf，也就是调用 runtime.morestack_noctxt(SB) 函数	
</span><span class="c1"></span>  <span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">3</span> <span class="mh">0x45dc8f</span> <span class="nx">SUBQ</span> <span class="err">$</span><span class="mh">0x18</span><span class="p">,</span> <span class="nx">SP</span>	

  <span class="c1">// ...
</span><span class="c1"></span>
  <span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span> <span class="mh">0x45dcce</span> <span class="nx">RET</span>                                <span class="c1">// 函数执行结束，RET 返回，不会执行后面两个指令				
</span><span class="c1"></span>  <span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">3</span> <span class="mh">0x45dccf</span> <span class="nx">CALL</span> <span class="nx">runtime</span><span class="p">.</span><span class="nf">morestack_noctxt</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>  <span class="c1">// 执行栈扩容	
</span><span class="c1"></span>  <span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">3</span> <span class="mh">0x45dcd4</span> <span class="nx">MP</span> <span class="nx">main</span><span class="p">.</span><span class="nf">test</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>                   <span class="c1">// 执行结束后，重新执行当前函数	
</span></code></pre></td></tr></table>
</div>
</div><p>逻辑很简单，如果 SP &lt;= stackguard0，那么就执行栈的扩容，扩容结束重新执行当前函数。
<div class="details admonition note open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-pencil-alt fa-fw"></i>Note<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><p>上面比较 SP 时候，没有考虑当前函数调用使用的空间大小。Why?</p>
<p>因为测试程序这个函数中使用的空间比较小，而 stackguard0  与 stack.lo 有一段<strong>保护区</strong>，所以编译器允许这里 &ldquo;溢出&rdquo; 一些，所以这里就没有让 SP 考虑函数使用空间。</p>
<p>如果函数中使用的空间大过保护区时，比较时就会让 SP 减去当前函数使用空间再比较了。</p>
</div>
        </div>
    </div></p>
<h4 id="332-扩容">3.3.2 扩容</h4>
<p>扩容逻辑大致分为三步：</p>
<ol>
<li>分配一个 2x 新栈；</li>
<li>拷贝当前栈数据至新栈；</li>
<li>&ldquo;释放&quot;掉旧栈；
从上面扩容判断可以看到，会调用 morestack 的汇编代码：</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Called during function prolog when more stack is needed.
</span><span class="c1">// R3 prolog&#39;s LR
</span><span class="c1">// using NOFRAME means do not save LR on stack.
</span><span class="c1">//
</span><span class="c1">// The traceback routines see morestack on a g0 as being
</span><span class="c1">// the top of a stack (for example, morestack calling newstack
</span><span class="c1">// calling the scheduler calling newm calling gc), so we must
</span><span class="c1">// record an argument size. For that purpose, it has no arguments.
</span><span class="c1"></span><span class="nx">TEXT</span> <span class="nx">runtime</span><span class="err">·</span><span class="nf">morestack</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span><span class="nx">NOSPLIT</span><span class="p">|</span><span class="nx">NOFRAME</span><span class="p">,</span><span class="err">$</span><span class="mi">0</span><span class="o">-</span><span class="mi">0</span>
	<span class="c1">// Cannot grow scheduler stack (m-&gt;g0).
</span><span class="c1"></span>	<span class="nx">MOVW</span>        <span class="nf">g_m</span><span class="p">(</span><span class="nx">g</span><span class="p">),</span> <span class="nx">R8</span>
	<span class="nx">MOVW</span>        <span class="nf">m_g0</span><span class="p">(</span><span class="nx">R8</span><span class="p">),</span> <span class="nx">R4</span>
	<span class="nx">CMP</span>        <span class="nx">g</span><span class="p">,</span> <span class="nx">R4</span>
	<span class="nx">BNE</span>        <span class="mi">3</span><span class="p">(</span><span class="nx">PC</span><span class="p">)</span>
	<span class="nx">BL</span>        <span class="nx">runtime</span><span class="err">·</span><span class="nf">badmorestackg0</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
	<span class="nx">B</span>        <span class="nx">runtime</span><span class="err">·</span><span class="nf">abort</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>

	<span class="c1">// Cannot grow signal stack (m-&gt;gsignal).
</span><span class="c1"></span>	<span class="nx">MOVW</span>        <span class="nf">m_gsignal</span><span class="p">(</span><span class="nx">R8</span><span class="p">),</span> <span class="nx">R4</span>
	<span class="nx">CMP</span>        <span class="nx">g</span><span class="p">,</span> <span class="nx">R4</span>
	<span class="nx">BNE</span>        <span class="mi">3</span><span class="p">(</span><span class="nx">PC</span><span class="p">)</span>
	<span class="nx">BL</span>        <span class="nx">runtime</span><span class="err">·</span><span class="nf">badmorestackgsignal</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
	<span class="nx">B</span>        <span class="nx">runtime</span><span class="err">·</span><span class="nf">abort</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>

	<span class="c1">// Called from f.
</span><span class="c1"></span>	<span class="c1">// Set g-&gt;sched to context in f.
</span><span class="c1"></span>	<span class="nx">MOVW</span>        <span class="nx">R13</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_sp</span><span class="p">)(</span><span class="nx">g</span><span class="p">)</span>
	<span class="nx">MOVW</span>        <span class="nx">LR</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_pc</span><span class="p">)(</span><span class="nx">g</span><span class="p">)</span>
	<span class="nx">MOVW</span>        <span class="nx">R3</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_lr</span><span class="p">)(</span><span class="nx">g</span><span class="p">)</span>
	<span class="nx">MOVW</span>        <span class="nx">R7</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_ctxt</span><span class="p">)(</span><span class="nx">g</span><span class="p">)</span>

	<span class="c1">// Called from f.
</span><span class="c1"></span>	<span class="c1">// Set m-&gt;morebuf to f&#39;s caller.
</span><span class="c1"></span>	<span class="nx">MOVW</span>        <span class="nx">R3</span><span class="p">,</span> <span class="p">(</span><span class="nx">m_morebuf</span><span class="o">+</span><span class="nx">gobuf_pc</span><span class="p">)(</span><span class="nx">R8</span><span class="p">)</span>        <span class="c1">// f&#39;s caller&#39;s PC
</span><span class="c1"></span>	<span class="nx">MOVW</span>        <span class="nx">R13</span><span class="p">,</span> <span class="p">(</span><span class="nx">m_morebuf</span><span class="o">+</span><span class="nx">gobuf_sp</span><span class="p">)(</span><span class="nx">R8</span><span class="p">)</span>        <span class="c1">// f&#39;s caller&#39;s SP
</span><span class="c1"></span>	<span class="nx">MOVW</span>        <span class="nx">g</span><span class="p">,</span> <span class="p">(</span><span class="nx">m_morebuf</span><span class="o">+</span><span class="nx">gobuf_g</span><span class="p">)(</span><span class="nx">R8</span><span class="p">)</span>

	<span class="c1">// Call newstack on m-&gt;g0&#39;s stack.
</span><span class="c1"></span>	<span class="nx">MOVW</span>        <span class="nf">m_g0</span><span class="p">(</span><span class="nx">R8</span><span class="p">),</span> <span class="nx">R0</span>
	<span class="nx">BL</span>        <span class="nx">setg</span><span class="p">&lt;&gt;(</span><span class="nx">SB</span><span class="p">)</span>
	<span class="nf">MOVW</span>        <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_sp</span><span class="p">)(</span><span class="nx">g</span><span class="p">),</span> <span class="nx">R13</span>
	<span class="nx">MOVW</span>        <span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="nx">R0</span>
	<span class="nx">MOVW</span><span class="p">.</span><span class="nx">W</span>  <span class="nx">R0</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">(</span><span class="nx">R13</span><span class="p">)</span>        <span class="c1">// create a call frame on g0 (saved LR)
</span><span class="c1"></span>	<span class="nx">BL</span>        <span class="nx">runtime</span><span class="err">·</span><span class="nf">newstack</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>

	<span class="c1">// Not reached, but make sure the return PC from the call to newstack
</span><span class="c1"></span>	<span class="c1">// is still in this function, and not the beginning of the next.
</span><span class="c1"></span>	<span class="nx">RET</span>

<span class="nx">TEXT</span> <span class="nx">runtime</span><span class="err">·</span><span class="nf">morestack_noctxt</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span><span class="nx">NOSPLIT</span><span class="p">|</span><span class="nx">NOFRAME</span><span class="p">,</span><span class="err">$</span><span class="mi">0</span><span class="o">-</span><span class="mi">0</span>
	<span class="nx">MOVW</span>        <span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="nx">R7</span>
	<span class="nx">B</span> <span class="nx">runtime</span><span class="err">·</span><span class="nf">morestack</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>可以看到 g0，gsignal 的栈都不会扩容</li>
<li>在 g0 栈上会调用 newstack() 函数</li>
</ul>
<p>调用的 newstack 函数（runtime/stack.go），过程很复杂，只看一下关键点：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Called from runtime·morestack when more stack is needed.
</span><span class="c1">// Allocate larger stack and relocate to new stack.
</span><span class="c1">// Stack growth is multiplicative, for constant amortized cost.
</span><span class="c1">//
</span><span class="c1">// g-&gt;atomicstatus will be Grunning or Gscanrunning upon entry.
</span><span class="c1">// If the scheduler is trying to stop this g, then it will set preemptStop.
</span><span class="c1">//
</span><span class="c1">// This must be nowritebarrierrec because it can be called as part of
</span><span class="c1">// stack growth from other nowritebarrierrec functions, but the
</span><span class="c1">// compiler doesn&#39;t check this.
</span><span class="c1">//
</span><span class="c1">//go:nowritebarrierrec
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">newstack</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">thisg</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
    <span class="nx">gp</span> <span class="o">:=</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span>
    
    <span class="c1">// ...
</span><span class="c1"></span>
	<span class="c1">// 新栈大小为当前两倍
</span><span class="c1"></span>	<span class="nx">oldsize</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span> <span class="o">-</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span>
    <span class="nx">newsize</span> <span class="o">:=</span> <span class="nx">oldsize</span> <span class="o">*</span> <span class="mi">2</span>
    
    <span class="c1">// ...
</span><span class="c1"></span>
	<span class="c1">// 改变 G 状态为 copy stack，gc 会跳过该状态的 G
</span><span class="c1"></span>	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Gcopystack</span><span class="p">)</span>

    <span class="c1">// 分配新栈，拷贝数据，释放旧站
</span><span class="c1"></span>	<span class="c1">// The concurrent GC will not scan the stack while we are doing the copy since
</span><span class="c1"></span>	<span class="c1">// the gp is in a Gcopystack status.
</span><span class="c1"></span>	<span class="nf">copystack</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">newsize</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">stackDebug</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;stack grow done\n&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gcopystack</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">)</span>
	<span class="c1">// 执行 G 代码
</span><span class="c1"></span>	<span class="nf">gogo</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Copies gp&#39;s stack to a new stack of a different size.
</span><span class="c1">// Caller must have changed gp status to Gcopystack.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">copystack</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">newsize</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 创建新 stack
</span><span class="c1"></span>	<span class="nx">new</span> <span class="o">:=</span> <span class="nf">stackalloc</span><span class="p">(</span><span class="nb">uint32</span><span class="p">(</span><span class="nx">newsize</span><span class="p">))</span>
	<span class="c1">// ...
</span><span class="c1"></span>	<span class="c1">// 拷贝数据
</span><span class="c1"></span>	<span class="nf">memmove</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">new</span><span class="p">.</span><span class="nx">hi</span><span class="o">-</span><span class="nx">ncopy</span><span class="p">),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">old</span><span class="p">.</span><span class="nx">hi</span><span class="o">-</span><span class="nx">ncopy</span><span class="p">),</span> <span class="nx">ncopy</span><span class="p">)</span>
	<span class="c1">// ...
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span> <span class="p">=</span> <span class="nx">new</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">new</span><span class="p">.</span><span class="nx">lo</span> <span class="o">+</span> <span class="nx">_StackGuard</span> 
	<span class="c1">// 释放旧 stack
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">stackPoisonCopy</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">fillstack</span><span class="p">(</span><span class="nx">old</span><span class="p">,</span> <span class="mh">0xfc</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">stackfree</span><span class="p">(</span><span class="nx">old</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="34-栈的释放">3.4 栈的释放</h3>
<p>stackfree 栈的释放与申请相反，放入 stackpool，或者直接调用内存管理删除，重点还是内存管理的活，所以这里不展开。</p>
<h3 id="35-栈的切换">3.5 栈的切换</h3>
<p>切换应该是属于 goroutine 调度的内容，不过这里可以关注一下栈时如何切换的。
当 M 执行的 G 需要切换，或者一个新创建 G 执行时，最后都会调用 <code>execute()</code> 函数，而 execute() 函数会调用 gogo 汇编实现的函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// func gogo(buf *gobuf)
</span><span class="c1">// restore state from Gobuf; longjmp
</span><span class="c1"></span><span class="nx">TEXT</span> <span class="nx">runtime</span><span class="err">·</span><span class="nf">gogo</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">NOSPLIT</span><span class="p">,</span> <span class="err">$</span><span class="mi">16</span><span class="o">-</span><span class="mi">8</span>
	<span class="nx">MOVQ</span>	<span class="nx">buf</span><span class="o">+</span><span class="mi">0</span><span class="p">(</span><span class="nx">FP</span><span class="p">),</span> <span class="nx">BX</span>		<span class="c1">// gobuf
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="nf">gobuf_g</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">DX</span>
	<span class="nx">MOVQ</span>	<span class="mi">0</span><span class="p">(</span><span class="nx">DX</span><span class="p">),</span> <span class="nx">CX</span>		    <span class="c1">// make sure g != nil
</span><span class="c1"></span>	<span class="nf">get_tls</span><span class="p">(</span><span class="nx">CX</span><span class="p">)</span>
	<span class="nx">MOVQ</span>	<span class="nx">DX</span><span class="p">,</span> <span class="nf">g</span><span class="p">(</span><span class="nx">CX</span><span class="p">)</span>
	<span class="nx">MOVQ</span>	<span class="nf">gobuf_sp</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">SP</span>	<span class="c1">// restore SP (关键!)
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="nf">gobuf_ret</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">AX</span>
	<span class="nx">MOVQ</span>	<span class="nf">gobuf_ctxt</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">DX</span>
	<span class="nx">MOVQ</span>	<span class="nf">gobuf_bp</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">BP</span>
	<span class="nx">MOVQ</span>	<span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="nf">gobuf_sp</span><span class="p">(</span><span class="nx">BX</span><span class="p">)</span>	<span class="c1">// clear to help garbage collector
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="nf">gobuf_ret</span><span class="p">(</span><span class="nx">BX</span><span class="p">)</span>
	<span class="nx">MOVQ</span>	<span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="nf">gobuf_ctxt</span><span class="p">(</span><span class="nx">BX</span><span class="p">)</span>
	<span class="nx">MOVQ</span>	<span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="nf">gobuf_bp</span><span class="p">(</span><span class="nx">BX</span><span class="p">)</span>
	<span class="nx">MOVQ</span>	<span class="nf">gobuf_pc</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">BX</span>
	<span class="nx">JMP</span>	<span class="nx">BX</span>
</code></pre></td></tr></table>
</div>
</div><p><code>gobuf</code> 中保存着要执行的 G 的 sp、pc 指针，可以看到通过<strong>将对应 gobuf.sp 写入到 SP 寄存器中</strong>，也就是将使用的栈切换为了 G 的栈。</p>
<h3 id="36-g0-的栈">3.6 g0 的栈</h3>
<p>在阅读网上的文章时，许多文章都说 g0 使用的是系统栈，我理解为使用的是进程的栈内存区域。但是思考一下，每个 M 对应一个 g0，也就是说有多个线程要同时共享系统栈，这是不可能的。例如在 pthread 实现中，对应新建的线程也是使用 mmap 分配一个内存区域，然后调用 clone() 系统调用时传入栈地址参数。</p>
<p>看一下代码，确认一下到底 g0 的栈到底是啥，找到一个新建 m 的地方：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">mp</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span>
<span class="nx">mp</span><span class="p">.</span><span class="nx">mstartfn</span> <span class="p">=</span> <span class="nx">fn</span>
<span class="nf">mcommoninit</span><span class="p">(</span><span class="nx">mp</span><span class="p">,</span> <span class="nx">id</span><span class="p">)</span>

<span class="c1">// In case of cgo or Solaris or illumos or Darwin, pthread_create will make us a stack.
</span><span class="c1">// Windows and Plan 9 will layout sched stack on OS stack.
</span><span class="c1"></span><span class="k">if</span> <span class="nx">iscgo</span> <span class="o">||</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;solaris&#34;</span> <span class="o">||</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;illumos&#34;</span> <span class="o">||</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;windows&#34;</span> <span class="o">||</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;plan9&#34;</span> <span class="o">||</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;darwin&#34;</span> <span class="p">{</span>
        <span class="nx">mp</span><span class="p">.</span><span class="nx">g0</span> <span class="p">=</span> <span class="nf">malg</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">mp</span><span class="p">.</span><span class="nx">g0</span> <span class="p">=</span> <span class="nf">malg</span><span class="p">(</span><span class="mi">8192</span> <span class="o">*</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">StackGuardMultiplier</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">mp</span><span class="p">.</span><span class="nx">g0</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="nx">mp</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看到，m 的 g0 属性还是使用的 <code>malg()</code> 函数去创建的，与普通的 g 创建一样，只不过初始大小为 8KB。malg() 流程上面有说到，就是走内存管理分配 mspan 作为栈的方式。</p>
<p>不过，g0 的栈还是有些不同的，不会进行栈的扩容（因为仅仅内部管理时用到，不需要进行自动扩容），在栈扩容的 morestack 汇编代码里可以看到。</p>
<h2 id="4-内存模型">4 内存模型</h2>
<h3 id="41-概览">4.1 概览</h3>
<p>Golang 内存管理包含四个组件：</p>
<ol>
<li><strong><code>object</code></strong> ：object 代表用户代码申请的一个对象，没有实际的数据结构，而是在 mspan 中以逻辑切分的方式分配；</li>
<li><strong><code>runtime.mspan</code></strong> ：内存管理的最小单元；</li>
<li><strong><code>runtime.mcache</code></strong> ：单个 P 对应的 mspan 的<strong>缓存</strong>，无锁分配；</li>
<li><strong><code>runtime.mcentral</code></strong> ：按照不同大小的 mspan 分组的管理链表，为 mcache 提供空闲 mspan</li>
<li><strong><code>runtime.mheap</code></strong> ：保存闲置的 mspan 与 largerspan 链表，与操作系统申请与释放内存；</li>
</ol>
<p>上面的组件也可以看做分层，普通对象（object）的申请与释放就是按照上下层顺序申请与释放的。
<div class="details admonition note open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-pencil-alt fa-fw"></i>Note<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">下面<del>不会说</del>（后面再说）具体的 object 分配流程，而是说明各个层次时的申请与释放操作。</div>
        </div>
    </div></p>
<h3 id="42-mspan">4.2 mspan</h3>
<p>所有的 mspan 会以 list 的方式构建，而不同的模块（mcache、mcentral）通过引用指针，来不同方式来组织不同的 mspan。</p>
<p>每个 mspan 管理多个固定大小的 object，通过编号(index)方式来寻找 object 的地址。</p>
<p>结构如下图所示：








    <br><img src="/posts/language/golang/go-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/img3.png"/><br>


</p>
<p>其数据结构如下（省略部分）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">mspan</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">next</span> <span class="o">*</span><span class="nx">mspan</span>     <span class="c1">// next span in list, or nil if none
</span><span class="c1"></span>        <span class="nx">prev</span> <span class="o">*</span><span class="nx">mspan</span>     <span class="c1">// previous span in list, or nil if none
</span><span class="c1"></span>
        <span class="nx">startAddr</span> <span class="kt">uintptr</span> <span class="c1">// address of first byte of span aka s.base()
</span><span class="c1"></span>        <span class="nx">npages</span>    <span class="kt">uintptr</span> <span class="c1">// number of pages in span
</span><span class="c1"></span>
        <span class="nx">manualFreeList</span> <span class="nx">gclinkptr</span> <span class="c1">// list of free objects in mSpanManual spans
</span><span class="c1"></span>        <span class="nx">freeindex</span> <span class="kt">uintptr</span>
        <span class="nx">nelems</span> <span class="kt">uintptr</span> <span class="c1">// number of object in the span.
</span><span class="c1"></span>        
        <span class="nx">allocCache</span> <span class="kt">uint64</span>
        <span class="nx">allocBits</span>  <span class="o">*</span><span class="nx">gcBits</span>
        <span class="nx">gcmarkBits</span> <span class="o">*</span><span class="nx">gcBits</span>
        
		<span class="c1">// sweep generation:
</span><span class="c1"></span>		<span class="c1">// if sweepgen == h-&gt;sweepgen - 2, the span needs sweeping
</span><span class="c1"></span>		<span class="c1">// if sweepgen == h-&gt;sweepgen - 1, the span is currently being swept
</span><span class="c1"></span>		<span class="c1">// if sweepgen == h-&gt;sweepgen, the span is swept and ready to use
</span><span class="c1"></span>		<span class="c1">// if sweepgen == h-&gt;sweepgen + 1, the span was cached before sweep began and is still cached, and needs sweeping
</span><span class="c1"></span>		<span class="c1">// if sweepgen == h-&gt;sweepgen + 3, the span was swept and then cached and is still cached
</span><span class="c1"></span>		<span class="c1">// h-&gt;sweepgen is incremented by 2 after every GC
</span><span class="c1"></span>        <span class="nx">sweepgen</span>    <span class="kt">uint32</span>
        <span class="nx">spanclass</span>   <span class="nx">spanClass</span>     <span class="c1">// size class and noscan (uint8)
</span><span class="c1"></span>        <span class="nx">allocCount</span>  <span class="kt">uint16</span>        <span class="c1">// number of allocated objects
</span><span class="c1"></span>        <span class="nx">elemsize</span>    <span class="kt">uintptr</span>       <span class="c1">// computed from sizeclass or from npages
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>next、prev ：链表前后 span；</li>
<li><strong><code>startAddr</code></strong> ：span 在 arena 区域的起始地址;</li>
<li><strong><code>npages</code></strong> ：占用 page(8KB) 数量；</li>
<li>manualFreeList ：空闲 object 链表；</li>
<li><strong><code>freeindex</code></strong> ：下一个空闲的 object 的编号，如果 freeindex == nelem，表明没有空闲 object 可以分配</li>
<li>nelems ：当前 span 中分配的 object 的上限；</li>
<li><strong><code>allocCache</code></strong> ：freeindex 的 cache，通过 bitmap 的方式记录对应编号的 object 内存是否是空闲的；</li>
<li><strong><code>sweepgen</code></strong> ：mspan 的状态, 见注释；</li>
<li>spanclass ：mspan 大小类别；</li>
<li>allocCount ：已经分配的 object 数量；</li>
<li><strong><code>elemsize</code></strong> ：管理的 object 的固定大小；</li>
</ul>
<p>可以看到，每个 mspan 管理着固定大小的 object，并通过一个 freeindex+allocCache 来记录空闲的 object 的编号。由此可以得出:</p>
<ul>
<li><strong>mspan 的地址区域</strong>: <strong><code>[startAddr, startAddr + npages*8*1024)</code></strong></li>
<li><strong>某个 object 的起始地址</strong>: <strong><code>&lt;index&gt;*elemsize + startAddr</code></strong></li>
</ul>
<h4 id="421-object-分配">4.2.1 object 分配</h4>
<p>在创建新的 object 时，对于普通大小的 object 分配（16&lt;size&lt;32KB)，会在从 mcache 中选出具有空闲空间的 mspan，然后记录到 mspan.allocCache 中。</p>
<p>具体代码如下，<code>nextFreeIndex()</code> 函数就是用于得到下一个空闲 object，并移动 <code>freeindex</code>（runtime/mbitmap.go)：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// nextFreeIndex returns the index of the next free object in s at
</span><span class="c1">// or after s.freeindex.
</span><span class="c1">// There are hardware instructions that can be used to make this
</span><span class="c1">// faster if profiling warrants it.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span><span class="p">)</span> <span class="nf">nextFreeIndex</span><span class="p">()</span> <span class="kt">uintptr</span> <span class="p">{</span>
        <span class="nx">sfreeindex</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">freeindex</span>
        <span class="nx">snelems</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span>
        <span class="k">if</span> <span class="nx">sfreeindex</span> <span class="o">==</span> <span class="nx">snelems</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">sfreeindex</span>
        <span class="p">}</span>

        <span class="nx">aCache</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">allocCache</span>

        <span class="nx">bitIndex</span> <span class="o">:=</span> <span class="nx">sys</span><span class="p">.</span><span class="nf">Ctz64</span><span class="p">(</span><span class="nx">aCache</span><span class="p">)</span>
        <span class="k">for</span> <span class="nx">bitIndex</span> <span class="o">==</span> <span class="mi">64</span> <span class="p">{</span>
                <span class="c1">// Move index to start of next cached bits.
</span><span class="c1"></span>                <span class="nx">sfreeindex</span> <span class="p">=</span> <span class="p">(</span><span class="nx">sfreeindex</span> <span class="o">+</span> <span class="mi">64</span><span class="p">)</span> <span class="o">&amp;^</span> <span class="p">(</span><span class="mi">64</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="nx">sfreeindex</span> <span class="o">&gt;=</span> <span class="nx">snelems</span> <span class="p">{</span>
                        <span class="nx">s</span><span class="p">.</span><span class="nx">freeindex</span> <span class="p">=</span> <span class="nx">snelems</span>
                        <span class="k">return</span> <span class="nx">snelems</span>
                <span class="p">}</span>
                <span class="nx">whichByte</span> <span class="o">:=</span> <span class="nx">sfreeindex</span> <span class="o">/</span> <span class="mi">8</span>
                <span class="c1">// Refill s.allocCache with the next 64 alloc bits.
</span><span class="c1"></span>                <span class="nx">s</span><span class="p">.</span><span class="nf">refillAllocCache</span><span class="p">(</span><span class="nx">whichByte</span><span class="p">)</span>
                <span class="nx">aCache</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">allocCache</span>
                <span class="nx">bitIndex</span> <span class="p">=</span> <span class="nx">sys</span><span class="p">.</span><span class="nf">Ctz64</span><span class="p">(</span><span class="nx">aCache</span><span class="p">)</span>
                <span class="c1">// nothing available in cached bits
</span><span class="c1"></span>                <span class="c1">// grab the next 8 bytes and try again.
</span><span class="c1"></span>        <span class="p">}</span>
        <span class="nx">result</span> <span class="o">:=</span> <span class="nx">sfreeindex</span> <span class="o">+</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">bitIndex</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">result</span> <span class="o">&gt;=</span> <span class="nx">snelems</span> <span class="p">{</span>
                <span class="nx">s</span><span class="p">.</span><span class="nx">freeindex</span> <span class="p">=</span> <span class="nx">snelems</span>
                <span class="k">return</span> <span class="nx">snelems</span>
        <span class="p">}</span>

        <span class="nx">s</span><span class="p">.</span><span class="nx">allocCache</span> <span class="o">&gt;&gt;=</span> <span class="nb">uint</span><span class="p">(</span><span class="nx">bitIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="nx">sfreeindex</span> <span class="p">=</span> <span class="nx">result</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="nx">sfreeindex</span><span class="o">%</span><span class="mi">64</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">sfreeindex</span> <span class="o">!=</span> <span class="nx">snelems</span> <span class="p">{</span>
                <span class="c1">// We just incremented s.freeindex so it isn&#39;t 0.
</span><span class="c1"></span>                <span class="c1">// As each 1 in s.allocCache was encountered and used for allocation
</span><span class="c1"></span>                <span class="c1">// it was shifted away. At this point s.allocCache contains all 0s.
</span><span class="c1"></span>                <span class="c1">// Refill s.allocCache so that it corresponds
</span><span class="c1"></span>                <span class="c1">// to the bits at s.allocBits starting at s.freeindex.
</span><span class="c1"></span>                <span class="nx">whichByte</span> <span class="o">:=</span> <span class="nx">sfreeindex</span> <span class="o">/</span> <span class="mi">8</span>
                <span class="nx">s</span><span class="p">.</span><span class="nf">refillAllocCache</span><span class="p">(</span><span class="nx">whichByte</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">s</span><span class="p">.</span><span class="nx">freeindex</span> <span class="p">=</span> <span class="nx">sfreeindex</span>
        <span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>注意：目前跳过了 &ldquo;nextFreeFast&rdquo; 实现，该获取 span 比 &ldquo;nextFree&rdquo; 更快，使用了 <code>mspan.allocCache</code>。</p>
<h4 id="422-object-的释放">4.2.2 object 的释放</h4>
<p>TODO</p>
<h3 id="43-mcache">4.3 mcache</h3>
<p>每个 P 拥有一个 mcache，mcache 中保存着具有空闲空间的 mspan，用于分配 object 时，不需要加锁即可从 mspan 分配对象。</p>
<p>有两种 object 走 mcache 分配：</p>
<ul>
<li><strong><code>tiny object</code></strong>：mcache 还单独使用一个 mspan 进行<strong>非指针微小对象</strong>的分配。与普通 object 对象分配不同的是，tiny object 不是固定大小分配的，而是通过 mcache 记录其 offset 偏移量，让 tiny object &ldquo;挤在&rdquo; 同一个 mspan 中。</li>
<li><strong><code>normal object</code></strong>：普通大小的 object，会使用 <code>mcache.alloc</code> 进行分配。<code>mcache.alloc</code> 包含 134 个数组项（67 sizeclass * 2），对于每个大小规格的 mspan 有着两个类型：
<ul>
<li><strong>scan</strong>：包含指针的对象</li>
<li><strong>noscan</strong>：不包含指针的对象，GC 时无需进一步扫描是否引用着其他活跃对象</li>
</ul>
</li>
</ul>
<p>mcache &ldquo;永远&rdquo; 有空闲的 mspan 用于 object 的分配，当 mcache 缓存的 mspan 没有空闲空间时，就会<strong>找 mcentral 去申请新的 mspan 用于使用</strong>。








    <br><img src="/posts/language/golang/go-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/img4.png"/><br>


</p>
<p>数据结构如下（runtime/mcache.go）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Per-thread (in Go, per-P) cache for small objects.
</span><span class="c1">// No locking needed because it is per-thread (per-P).
</span><span class="c1">//
</span><span class="c1">// mcaches are allocated from non-GC&#39;d memory, so any heap pointers
</span><span class="c1">// must be specially handled.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">mcache</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="c1">// Allocator cache for tiny objects w/o pointers.
</span><span class="c1"></span>        <span class="c1">// See &#34;Tiny allocator&#34; comment in malloc.go.
</span><span class="c1"></span>
        <span class="c1">// tiny points to the beginning of the current tiny block, or
</span><span class="c1"></span>        <span class="c1">// nil if there is no current tiny block.
</span><span class="c1"></span>        <span class="c1">//
</span><span class="c1"></span>        <span class="c1">// tiny is a heap pointer. Since mcache is in non-GC&#39;d memory,
</span><span class="c1"></span>        <span class="c1">// we handle it by clearing it in releaseAll during mark
</span><span class="c1"></span>        <span class="c1">// termination.
</span><span class="c1"></span>        <span class="nx">tiny</span>             <span class="kt">uintptr</span>
        <span class="nx">tinyoffset</span>       <span class="kt">uintptr</span>
        <span class="nx">local_tinyallocs</span> <span class="kt">uintptr</span> <span class="c1">// number of tiny allocs not counted in other stats
</span><span class="c1"></span>
        <span class="c1">// The rest is not accessed on every malloc.
</span><span class="c1"></span>
        <span class="nx">alloc</span> <span class="p">[</span><span class="nx">numSpanClasses</span><span class="p">]</span><span class="o">*</span><span class="nx">mspan</span> <span class="c1">// spans to allocate from, indexed by spanClass
</span><span class="c1"></span>
        <span class="nx">stackcache</span> <span class="p">[</span><span class="nx">_NumStackOrders</span><span class="p">]</span><span class="nx">stackfreelist</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li><strong><code>tiny</code></strong> <strong><code>tinyoffset</code></strong> ：用于小对象（&lt;16）的分配。tiny 指向当前为 tiny object 准备的 span 的起始地址，tinyoffset 指向对象使用的偏移地址；</li>
<li><strong><code>alloc</code></strong> ：最重要的属性，保存着不同大小的 mspan 各一个。目前，包含固定 64 类 sizeclass：0、8 … 32768；</li>
</ul>
<h4 id="431-mspan-的分配">4.3.1 mspan 的分配</h4>
<p>先看下 tiny object 分配，在分配一个 object 时，如果大小小于 16 字节时，就会走 tiny object 逻辑。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Tiny allocator.
</span><span class="c1">//
</span><span class="c1">// Tiny allocator combines several tiny allocation requests
</span><span class="c1">// into a single memory block. The resulting memory block
</span><span class="c1">// is freed when all subobjects are unreachable. The subobjects
</span><span class="c1">// must be noscan (don&#39;t have pointers), this ensures that
</span><span class="c1">// the amount of potentially wasted memory is bounded.
</span><span class="c1">//
</span><span class="c1">// Size of the memory block used for combining (maxTinySize) is tunable.
</span><span class="c1">// Current setting is 16 bytes, which relates to 2x worst case memory
</span><span class="c1">// wastage (when all but one subobjects are unreachable).
</span><span class="c1">// 8 bytes would result in no wastage at all, but provides less
</span><span class="c1">// opportunities for combining.
</span><span class="c1">// 32 bytes provides more opportunities for combining,
</span><span class="c1">// but can lead to 4x worst case wastage.
</span><span class="c1">// The best case winning is 8x regardless of block size.
</span><span class="c1">//
</span><span class="c1">// Objects obtained from tiny allocator must not be freed explicitly.
</span><span class="c1">// So when an object will be freed explicitly, we ensure that
</span><span class="c1">// its size &gt;= maxTinySize.
</span><span class="c1">//
</span><span class="c1">// SetFinalizer has a special case for objects potentially coming
</span><span class="c1">// from tiny allocator, it such case it allows to set finalizers
</span><span class="c1">// for an inner byte of a memory block.
</span><span class="c1">//
</span><span class="c1">// The main targets of tiny allocator are small strings and
</span><span class="c1">// standalone escaping variables. On a json benchmark
</span><span class="c1">// the allocator reduces number of allocations by ~12% and
</span><span class="c1">// reduces heap size by ~20%.
</span><span class="c1"></span><span class="nx">off</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">tinyoffset</span>
<span class="c1">// Align tiny pointer for required (conservative) alignment.
</span><span class="c1"></span><span class="k">if</span> <span class="nx">size</span><span class="o">&amp;</span><span class="mi">7</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nx">off</span> <span class="p">=</span> <span class="nf">alignUp</span><span class="p">(</span><span class="nx">off</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">size</span><span class="o">&amp;</span><span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nx">off</span> <span class="p">=</span> <span class="nf">alignUp</span><span class="p">(</span><span class="nx">off</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">size</span><span class="o">&amp;</span><span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nx">off</span> <span class="p">=</span> <span class="nf">alignUp</span><span class="p">(</span><span class="nx">off</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">if</span> <span class="nx">off</span><span class="o">+</span><span class="nx">size</span> <span class="o">&lt;=</span> <span class="nx">maxTinySize</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">tiny</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="c1">// The object fits into existing tiny block.
</span><span class="c1"></span>        <span class="nx">x</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">tiny</span> <span class="o">+</span> <span class="nx">off</span><span class="p">)</span>
        <span class="nx">c</span><span class="p">.</span><span class="nx">tinyoffset</span> <span class="p">=</span> <span class="nx">off</span> <span class="o">+</span> <span class="nx">size</span>
        <span class="nx">c</span><span class="p">.</span><span class="nx">local_tinyallocs</span><span class="o">++</span>
        <span class="nx">mp</span><span class="p">.</span><span class="nx">mallocing</span> <span class="p">=</span> <span class="mi">0</span>
        <span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
        <span class="k">return</span> <span class="nx">x</span>
<span class="p">}</span>
<span class="c1">// Allocate a new maxTinySize block.
</span><span class="c1"></span><span class="nx">span</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">alloc</span><span class="p">[</span><span class="nx">tinySpanClass</span><span class="p">]</span>
<span class="nx">v</span> <span class="o">:=</span> <span class="nf">nextFreeFast</span><span class="p">(</span><span class="nx">span</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">v</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nx">v</span><span class="p">,</span> <span class="nx">span</span><span class="p">,</span> <span class="nx">shouldhelpgc</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">nextFree</span><span class="p">(</span><span class="nx">tinySpanClass</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">x</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
<span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kt">uint64</span><span class="p">)(</span><span class="nx">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
<span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kt">uint64</span><span class="p">)(</span><span class="nx">x</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
<span class="c1">// See if we need to replace the existing tiny block with the new one
</span><span class="c1">// based on amount of remaining free space.
</span><span class="c1"></span><span class="k">if</span> <span class="nx">size</span> <span class="p">&lt;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">tinyoffset</span> <span class="o">||</span> <span class="nx">c</span><span class="p">.</span><span class="nx">tiny</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nx">c</span><span class="p">.</span><span class="nx">tiny</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
        <span class="nx">c</span><span class="p">.</span><span class="nx">tinyoffset</span> <span class="p">=</span> <span class="nx">size</span>
<span class="p">}</span>
<span class="nx">size</span> <span class="p">=</span> <span class="nx">maxTinySize</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>如果当前 <strong>tinyoffset+size &lt; 16B</strong>（因为每个 tiny span 的大小为 32B，而每个 tiny object 最大为 16，所以比较 16 即可），那么表明<strong>当前的 tiny span 肯定可以放下</strong>，那么移动 <code>c.tinyoffset</code> 偏移即可；</li>
<li>如果没有，那么就需要<strong>重新申请</strong> tinySpanClass=5 的 span（32B），并替换当前 <code>c.tiny</code> 与 <code>c.tinyoffset</code>（当前 object 可以放在老的 span 或者新的 span）。</li>
</ol>
<p>接着看下普通大小的 object 的分配，在外层函数计算好 spanClass 后，就会调用 <strong><code>nextFree()</code></strong> 函数（runtime/malloc.go）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// nextFree returns the next free object from the cached span if one is available.
</span><span class="c1">// Otherwise it refills the cache with a span with an available object and
</span><span class="c1">// returns that object along with a flag indicating that this was a heavy
</span><span class="c1">// weight allocation. If it is a heavy weight allocation the caller must
</span><span class="c1">// determine whether a new GC cycle needs to be started or if the GC is active
</span><span class="c1">// whether this goroutine needs to assist the GC.
</span><span class="c1">//
</span><span class="c1">// Must run in a non-preemptible context since otherwise the owner of
</span><span class="c1">// c could change.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">mcache</span><span class="p">)</span> <span class="nf">nextFree</span><span class="p">(</span><span class="nx">spc</span> <span class="nx">spanClass</span><span class="p">)</span> <span class="p">(</span><span class="nx">v</span> <span class="nx">gclinkptr</span><span class="p">,</span> <span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span><span class="p">,</span> <span class="nx">shouldhelpgc</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">s</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">alloc</span><span class="p">[</span><span class="nx">spc</span><span class="p">]</span>
        <span class="nx">shouldhelpgc</span> <span class="p">=</span> <span class="kc">false</span>
        <span class="nx">freeIndex</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">nextFreeIndex</span><span class="p">()</span>
        <span class="k">if</span> <span class="nx">freeIndex</span> <span class="o">==</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
                <span class="c1">// The span is full.
</span><span class="c1"></span>                <span class="k">if</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
                        <span class="nb">println</span><span class="p">(</span><span class="s">&#34;runtime: s.allocCount=&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="p">,</span> <span class="s">&#34;s.nelems=&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span><span class="p">)</span>
                        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;s.allocCount != s.nelems &amp;&amp; freeIndex == s.nelems&#34;</span><span class="p">)</span>
                <span class="p">}</span>
                <span class="nx">c</span><span class="p">.</span><span class="nf">refill</span><span class="p">(</span><span class="nx">spc</span><span class="p">)</span>
                <span class="nx">shouldhelpgc</span> <span class="p">=</span> <span class="kc">true</span>
                <span class="nx">s</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">alloc</span><span class="p">[</span><span class="nx">spc</span><span class="p">]</span>

        <span class="nx">freeIndex</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">nextFreeIndex</span><span class="p">()</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="nx">freeIndex</span> <span class="o">&gt;=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
                <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;freeIndex is not valid&#34;</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="nx">v</span> <span class="p">=</span> <span class="nf">gclinkptr</span><span class="p">(</span><span class="nx">freeIndex</span><span class="o">*</span><span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span> <span class="o">+</span> <span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">())</span>
        <span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="o">++</span>
        <span class="k">if</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
                <span class="nb">println</span><span class="p">(</span><span class="s">&#34;s.allocCount=&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="p">,</span> <span class="s">&#34;s.nelems=&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span><span class="p">)</span>
                <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;s.allocCount &gt; s.nelems&#34;</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">return</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>得到 <code>c.alloc</code> 对应大小的 mspan；</li>
<li>如果 mspan 没有空闲空间了（freeIndex == s.nelems），那么走 <code>c.refill()</code> <strong>重新向 mcentral 申请一个 有空闲空间 mspan</strong>；</li>
<li><code>mspan.nextFreeIndex()</code> 下一个 index，并计算出对应的内存地址返回；</li>
</ol>
<h4 id="432-mspan-的获取">4.3.2 mspan 的获取</h4>
<p>前面分配 object 中可以看到，当 mcache 当前大小的 mspan 没有空闲空间后，就会通过 <strong><code>c.refill()</code></strong> 向 mcentral 重新申请一个 mspan（runtime/mcache.go）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// refill acquires a new span of span class spc for c. This span will
</span><span class="c1">// have at least one free object. The current span in c must be full.
</span><span class="c1">//
</span><span class="c1">// Must run in a non-preemptible context since otherwise the owner of
</span><span class="c1">// c could change.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">mcache</span><span class="p">)</span> <span class="nf">refill</span><span class="p">(</span><span class="nx">spc</span> <span class="nx">spanClass</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Return the current cached span to the central lists.
</span><span class="c1"></span>	<span class="nx">s</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">alloc</span><span class="p">[</span><span class="nx">spc</span><span class="p">]</span>

	<span class="k">if</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;refill of span with free space remaining&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">s</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="nx">emptymspan</span> <span class="p">{</span>
		<span class="c1">// Mark this span as no longer cached.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">!=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepgen</span><span class="o">+</span><span class="mi">3</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad sweepgen in refill&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">go115NewMCentralImpl</span> <span class="p">{</span>
			<span class="nx">mheap_</span><span class="p">.</span><span class="nx">central</span><span class="p">[</span><span class="nx">spc</span><span class="p">].</span><span class="nx">mcentral</span><span class="p">.</span><span class="nf">uncacheSpan</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">,</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Get a new cached span from the central lists.
</span><span class="c1"></span>	<span class="nx">s</span> <span class="p">=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">central</span><span class="p">[</span><span class="nx">spc</span><span class="p">].</span><span class="nx">mcentral</span><span class="p">.</span><span class="nf">cacheSpan</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;out of memory&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="p">)</span> <span class="o">==</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;span has no free space&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Indicate that this span is cached and prevent asynchronous
</span><span class="c1"></span>	<span class="c1">// sweeping in the next sweep phase.
</span><span class="c1"></span>	<span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="p">=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">+</span> <span class="mi">3</span>

	<span class="nx">c</span><span class="p">.</span><span class="nx">alloc</span><span class="p">[</span><span class="nx">spc</span><span class="p">]</span> <span class="p">=</span> <span class="nx">s</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>标记当前 mspan 不会在被缓存（猜想，垃圾回收后会改变这个标志位），go 1.15 后的会将 mspan 从 mcache 还给 mcentral；</li>
<li>通过 mheap <strong>对应大小的 mcentral 获取一个空闲的 mspan</strong>，并置位 <code>mspan.sweepgen</code>（表明被 mcache 使用）；</li>
<li>将 <code>c.alloc</code> 对应大小的 mspan 赋值为刚获取到的；</li>
</ol>
<p>可以看到，通过 refill 动态的申请 mspan，mcache 不同大小的 mspan 在 <strong>申请-&gt;使用-&gt;替换</strong> 中不断的循环，而 cache 一直能保存着有着空闲空间的 mspan 供 P 使用。</p>
<h3 id="44-mcentral">4.4 mcentral</h3>
<p><strong><code>mcentral</code></strong> 是内存分配器的中心缓存，<strong>用于给 mcache 提供空闲的 mspan</strong>。因为不是 P 对应的，所以访问也需要锁。</p>
<p>mheap 会创建 64 个 sizeClass 的 mcentral，每个 mcentral 管理相同大小的所有 mspan，以两个链表结构管理：</p>
<ul>
<li><strong><code>nonempty</code></strong> ：包含空闲空间的 mspan 组成的链表；</li>
<li><strong><code>empty</code></strong> ：不包含空闲空间，或者被 mcache 申请的 mspan 组成的链表（判断是否被 mcache 使用是通过 mspan.sweepgen 属性来判断）；</li>
</ul>
<p>当 mcache 要申请某大小的 mspan 时，会回去指定大小的 mcentral 实例上申请。








    <br><img src="/posts/language/golang/go-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/img5.png"/><br>


</p>
<p>数据结构如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Central list of free objects of a given size.
</span><span class="c1">//
</span><span class="c1">//go:notinheap
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">mcentral</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">lock</span>      <span class="nx">mutex</span>
	<span class="nx">spanclass</span> <span class="nx">spanClass</span>

	<span class="c1">// For !go115NewMCentralImpl.
</span><span class="c1"></span>	<span class="nx">nonempty</span> <span class="nx">mSpanList</span> <span class="c1">// list of spans with a free object, ie a nonempty free list
</span><span class="c1"></span>	<span class="nx">empty</span>    <span class="nx">mSpanList</span> <span class="c1">// list of spans with no free objects (or cached in an mcache)
</span><span class="c1"></span>
	<span class="err">…</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li><code>lock</code> ：访问需要加的锁；</li>
<li><code>spanclass</code> ：当前 mcentral 管理的 mspan 大小；</li>
<li><code>nonempty</code> ：包含空闲空间的 mspan 链表；</li>
<li><code>empty</code> ：不包含空闲空间，或者被 mcache 申请了的 mspan 链表；</li>
</ul>
<div class="details admonition note open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-pencil-alt fa-fw"></i>Note<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">源码中存在 go115NewMCentralImpl 的注释，对 mcentral 结构做了很大的改动，但是在 go1.15 release 页面上并没有看到对应的说明。</div>
        </div>
    </div>
<h4 id="441-从-mcentral-申请-mspan">4.4.1 从 mcentral 申请 mspan</h4>
<p>在 mcache 中，可以看到 mcache 通过调用 <code>mcentral.cacheSpan()</code> 申请新的空闲 mspan。在 go1.15 中，因为有新版 mcentral 的实现，因此双链表方式移动到了 <code>mcentral.oldCacheSpan()</code> 方法中。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Allocate a span to use in an mcache.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">mcentral</span><span class="p">)</span> <span class="nf">cacheSpan</span><span class="p">()</span> <span class="o">*</span><span class="nx">mspan</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">go115NewMCentralImpl</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nf">oldCacheSpan</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="err">…</span>
<span class="p">}</span>

<span class="c1">// Allocate a span to use in an mcache.
</span><span class="c1">//
</span><span class="c1">// For !go115NewMCentralImpl.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">mcentral</span><span class="p">)</span> <span class="nf">oldCacheSpan</span><span class="p">()</span> <span class="o">*</span><span class="nx">mspan</span> <span class="p">{</span>
        <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
        <span class="nx">sg</span> <span class="o">:=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepgen</span>
        
<span class="nx">retry</span><span class="p">:</span>
        <span class="kd">var</span> <span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span>
        <span class="c1">// 走 nonempty 链表找
</span><span class="c1"></span>        <span class="k">for</span> <span class="nx">s</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">nonempty</span><span class="p">.</span><span class="nx">first</span><span class="p">;</span> <span class="nx">s</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">s</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">next</span> <span class="p">{</span>
                <span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">==</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">,</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                        <span class="nx">c</span><span class="p">.</span><span class="nx">nonempty</span><span class="p">.</span><span class="nf">remove</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
                        <span class="nx">c</span><span class="p">.</span><span class="nx">empty</span><span class="p">.</span><span class="nf">insertBack</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
                        <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
                        <span class="nx">s</span><span class="p">.</span><span class="nf">sweep</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
                        <span class="k">goto</span> <span class="nx">havespan</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">==</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
                        <span class="c1">// the span is being swept by background sweeper, skip
</span><span class="c1"></span>                        <span class="k">continue</span>
                <span class="p">}</span>
                <span class="c1">// we have a nonempty span that does not require sweeping, allocate from it
</span><span class="c1"></span>                <span class="nx">c</span><span class="p">.</span><span class="nx">nonempty</span><span class="p">.</span><span class="nf">remove</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
                <span class="nx">c</span><span class="p">.</span><span class="nx">empty</span><span class="p">.</span><span class="nf">insertBack</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
                <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
                <span class="k">goto</span> <span class="nx">havespan</span>
        <span class="p">}</span>

        <span class="c1">// 走 empty 链表找
</span><span class="c1"></span>        <span class="k">for</span> <span class="nx">s</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">empty</span><span class="p">.</span><span class="nx">first</span><span class="p">;</span> <span class="nx">s</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">s</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">next</span> <span class="p">{</span>
                <span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">==</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">,</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                        <span class="c1">// we have an empty span that requires sweeping,
</span><span class="c1"></span>                        <span class="c1">// sweep it and see if we can free some space in it
</span><span class="c1"></span>                        <span class="nx">c</span><span class="p">.</span><span class="nx">empty</span><span class="p">.</span><span class="nf">remove</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
                        <span class="c1">// swept spans are at the end of the list
</span><span class="c1"></span>                        <span class="nx">c</span><span class="p">.</span><span class="nx">empty</span><span class="p">.</span><span class="nf">insertBack</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
                        <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
                        <span class="nx">s</span><span class="p">.</span><span class="nf">sweep</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
                        <span class="nx">freeIndex</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">nextFreeIndex</span><span class="p">()</span>
                        <span class="k">if</span> <span class="nx">freeIndex</span> <span class="o">!=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
                                <span class="nx">s</span><span class="p">.</span><span class="nx">freeindex</span> <span class="p">=</span> <span class="nx">freeIndex</span>
                                <span class="k">goto</span> <span class="nx">havespan</span>
                        <span class="p">}</span>
                        <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
                        <span class="c1">// the span is still empty after sweep
</span><span class="c1"></span>                        <span class="c1">// it is already in the empty list, so just retry
</span><span class="c1"></span>                        <span class="k">goto</span> <span class="nx">retry</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">==</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
                        <span class="c1">// the span is being swept by background sweeper, skip
</span><span class="c1"></span>                        <span class="k">continue</span>
                <span class="p">}</span>
                <span class="c1">// already swept empty span,
</span><span class="c1"></span>                <span class="c1">// all subsequent ones must also be either swept or in process of sweeping
</span><span class="c1"></span>                <span class="k">break</span>
        <span class="p">}</span>
        <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

        <span class="c1">// 向 heap 申请新的 mspan
</span><span class="c1"></span>        <span class="c1">// Replenish central list if empty.
</span><span class="c1"></span>        <span class="nx">s</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">grow</span><span class="p">()</span>
        <span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="k">return</span> <span class="kc">nil</span>
        <span class="p">}</span>
        <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
        <span class="nx">c</span><span class="p">.</span><span class="nx">empty</span><span class="p">.</span><span class="nf">insertBack</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
        <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

        <span class="c1">// At this point s is a non-empty span, queued at the end of the empty list,
</span><span class="c1"></span>        <span class="c1">// c is unlocked.
</span><span class="c1"></span><span class="nx">havespan</span><span class="p">:</span>
        <span class="err">…</span>
        <span class="nx">freeByteBase</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">freeindex</span> <span class="o">&amp;^</span> <span class="p">(</span><span class="mi">64</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="nx">whichByte</span> <span class="o">:=</span> <span class="nx">freeByteBase</span> <span class="o">/</span> <span class="mi">8</span>
        <span class="c1">// Init alloc bits cache.
</span><span class="c1"></span>        <span class="nx">s</span><span class="p">.</span><span class="nf">refillAllocCache</span><span class="p">(</span><span class="nx">whichByte</span><span class="p">)</span>

        <span class="c1">// Adjust the allocCache so that s.freeindex corresponds to the low bit in
</span><span class="c1"></span>        <span class="c1">// s.allocCache.
</span><span class="c1"></span>        <span class="nx">s</span><span class="p">.</span><span class="nx">allocCache</span> <span class="o">&gt;&gt;=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">freeindex</span> <span class="o">%</span> <span class="mi">64</span>

        <span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上面逻辑可以大致分为几个步骤：</p>
<ol>
<li>遍历 nonempty 链表，找到可用的 mspan（对于需要 sweep 的 mspan 先进行 sweep）；</li>
<li>没找到，遍历 empty 链表，仅仅遍历需要 sweep 的 mspan，执行 sweep 并判断是否可用；</li>
<li>还是没有，通过 <code>mcentral.grow()</code> 向 mheap 申请新的 mspan，mheap 中都没有，return nil；</li>
<li>找到空闲 mspan 后，会放置到 empty 链表尾部，并返回；</li>
</ol>
<h4 id="442-mcentral-扩容">4.4.2 mcentral 扩容</h4>
<p>在 mcentral 没有任何空闲 mspan 给 mcache 时，就会调用 <code>mcentral.grow()</code> 申请新的 mspan。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// grow allocates a new empty span from the heap and initializes it for c&#39;s size class.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">mcentral</span><span class="p">)</span> <span class="nf">grow</span><span class="p">()</span> <span class="o">*</span><span class="nx">mspan</span> <span class="p">{</span>
        <span class="nx">npages</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">class_to_allocnpages</span><span class="p">[</span><span class="nx">c</span><span class="p">.</span><span class="nx">spanclass</span><span class="p">.</span><span class="nf">sizeclass</span><span class="p">()])</span>
        <span class="nx">size</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">class_to_size</span><span class="p">[</span><span class="nx">c</span><span class="p">.</span><span class="nx">spanclass</span><span class="p">.</span><span class="nf">sizeclass</span><span class="p">()])</span>

        <span class="nx">s</span> <span class="o">:=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nf">alloc</span><span class="p">(</span><span class="nx">npages</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">spanclass</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="k">return</span> <span class="kc">nil</span>
        <span class="p">}</span>

        <span class="c1">// Use division by multiplication and shifts to quickly compute:
</span><span class="c1"></span>        <span class="c1">// n := (npages &lt;&lt; _PageShift) / size
</span><span class="c1"></span>        <span class="nx">n</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">npages</span> <span class="o">&lt;&lt;</span> <span class="nx">_PageShift</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">divShift</span> <span class="o">*</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">divMul</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">divShift2</span>
        <span class="nx">s</span><span class="p">.</span><span class="nx">limit</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()</span> <span class="o">+</span> <span class="nx">size</span><span class="o">*</span><span class="nx">n</span>
        <span class="nf">heapBitsForAddr</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()).</span><span class="nf">initSpan</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
        <span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>通过 <code>mheap.alloc()</code> 申请一个指大小的 mspan；</li>
<li>执行 <code>mheapBit.initSpan()</code> 初始化 mspan；</li>
</ol>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2021-01-05</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"><span>
                            <a class="link-to-markdown" href="/posts/language/golang/go-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/index.md" target="_blank">阅读原始文档</a>
                        </span></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="https://KanShiori.github.io/posts/language/golang/go-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" data-title="Go 内存模型"><i class="fab fa-weibo fa-fw"></i></a><a href="javascript:void(0);" title="分享到 百度" data-sharer="baidu" data-url="https://KanShiori.github.io/posts/language/golang/go-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" data-title="Go 内存模型"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@2.14.0/icons/baidu.svg"></i></a><a href="javascript:void(0);" title="分享到 Evernote" data-sharer="evernote" data-url="https://KanShiori.github.io/posts/language/golang/go-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" data-title="Go 内存模型"><i class="fab fa-evernote fa-fw"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/golang/">Golang</a>,&nbsp;<a href="/tags/golang-%E5%8E%9F%E7%90%86/">Golang 原理</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/cloud_computing/vm/kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%BD%91%E7%BB%9C/" class="prev" rel="prev" title="KVM 虚拟机的存储与网络"><i class="fas fa-angle-left fa-fw"></i>KVM 虚拟机的存储与网络</a></div>
</div>
<div id="comments"><div id="valine" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://valine.js.org/">Valine</a>.
            </noscript></div></article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.76.5">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2019 - 2021</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank">Shiori</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><link rel="stylesheet" href="/lib/valine/valine.min.css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/smooth-scroll@16.1.3/dist/smooth-scroll.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/autocomplete.js@0.37.1/dist/autocomplete.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/algoliasearch@4.2.0/dist/algoliasearch-lite.umd.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.2.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.4.0/sharer.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":25},"comment":{"valine":{"appId":"MmnKVcBz9AcNPahAcxxe8B6A-gzGzoHsz","appKey":"R3UuooucP5zsSKK77zNspvlL","avatar":"mp","el":"#valine","emojiCDN":"https://cdn.jsdelivr.net/npm/emoji-datasource-google@5.0.1/img/google/64/","emojiMaps":{"100":"1f4af.png","alien":"1f47d.png","anger":"1f4a2.png","angry":"1f620.png","anguished":"1f627.png","astonished":"1f632.png","black_heart":"1f5a4.png","blue_heart":"1f499.png","blush":"1f60a.png","bomb":"1f4a3.png","boom":"1f4a5.png","broken_heart":"1f494.png","brown_heart":"1f90e.png","clown_face":"1f921.png","cold_face":"1f976.png","cold_sweat":"1f630.png","confounded":"1f616.png","confused":"1f615.png","cry":"1f622.png","crying_cat_face":"1f63f.png","cupid":"1f498.png","dash":"1f4a8.png","disappointed":"1f61e.png","disappointed_relieved":"1f625.png","dizzy":"1f4ab.png","dizzy_face":"1f635.png","drooling_face":"1f924.png","exploding_head":"1f92f.png","expressionless":"1f611.png","face_vomiting":"1f92e.png","face_with_cowboy_hat":"1f920.png","face_with_hand_over_mouth":"1f92d.png","face_with_head_bandage":"1f915.png","face_with_monocle":"1f9d0.png","face_with_raised_eyebrow":"1f928.png","face_with_rolling_eyes":"1f644.png","face_with_symbols_on_mouth":"1f92c.png","face_with_thermometer":"1f912.png","fearful":"1f628.png","flushed":"1f633.png","frowning":"1f626.png","ghost":"1f47b.png","gift_heart":"1f49d.png","green_heart":"1f49a.png","grimacing":"1f62c.png","grin":"1f601.png","grinning":"1f600.png","hankey":"1f4a9.png","hear_no_evil":"1f649.png","heart":"2764-fe0f.png","heart_decoration":"1f49f.png","heart_eyes":"1f60d.png","heart_eyes_cat":"1f63b.png","heartbeat":"1f493.png","heartpulse":"1f497.png","heavy_heart_exclamation_mark_ornament":"2763-fe0f.png","hole":"1f573-fe0f.png","hot_face":"1f975.png","hugging_face":"1f917.png","hushed":"1f62f.png","imp":"1f47f.png","innocent":"1f607.png","japanese_goblin":"1f47a.png","japanese_ogre":"1f479.png","joy":"1f602.png","joy_cat":"1f639.png","kiss":"1f48b.png","kissing":"1f617.png","kissing_cat":"1f63d.png","kissing_closed_eyes":"1f61a.png","kissing_heart":"1f618.png","kissing_smiling_eyes":"1f619.png","laughing":"1f606.png","left_speech_bubble":"1f5e8-fe0f.png","love_letter":"1f48c.png","lying_face":"1f925.png","mask":"1f637.png","money_mouth_face":"1f911.png","nauseated_face":"1f922.png","nerd_face":"1f913.png","neutral_face":"1f610.png","no_mouth":"1f636.png","open_mouth":"1f62e.png","orange_heart":"1f9e1.png","partying_face":"1f973.png","pensive":"1f614.png","persevere":"1f623.png","pleading_face":"1f97a.png","pouting_cat":"1f63e.png","purple_heart":"1f49c.png","rage":"1f621.png","relaxed":"263a-fe0f.png","relieved":"1f60c.png","revolving_hearts":"1f49e.png","right_anger_bubble":"1f5ef-fe0f.png","robot_face":"1f916.png","rolling_on_the_floor_laughing":"1f923.png","scream":"1f631.png","scream_cat":"1f640.png","see_no_evil":"1f648.png","shushing_face":"1f92b.png","skull":"1f480.png","skull_and_crossbones":"2620-fe0f.png","sleeping":"1f634.png","sleepy":"1f62a.png","slightly_frowning_face":"1f641.png","slightly_smiling_face":"1f642.png","smile":"1f604.png","smile_cat":"1f638.png","smiley":"1f603.png","smiley_cat":"1f63a.png","smiling_face_with_3_hearts":"1f970.png","smiling_imp":"1f608.png","smirk":"1f60f.png","smirk_cat":"1f63c.png","sneezing_face":"1f927.png","sob":"1f62d.png","space_invader":"1f47e.png","sparkling_heart":"1f496.png","speak_no_evil":"1f64a.png","speech_balloon":"1f4ac.png","star-struck":"1f929.png","stuck_out_tongue":"1f61b.png","stuck_out_tongue_closed_eyes":"1f61d.png","stuck_out_tongue_winking_eye":"1f61c.png","sunglasses":"1f60e.png","sweat":"1f613.png","sweat_drops":"1f4a6.png","sweat_smile":"1f605.png","thinking_face":"1f914.png","thought_balloon":"1f4ad.png","tired_face":"1f62b.png","triumph":"1f624.png","two_hearts":"1f495.png","unamused":"1f612.png","upside_down_face":"1f643.png","weary":"1f629.png","white_frowning_face":"2639-fe0f.png","white_heart":"1f90d.png","wink":"1f609.png","woozy_face":"1f974.png","worried":"1f61f.png","yawning_face":"1f971.png","yellow_heart":"1f49b.png","yum":"1f60b.png","zany_face":"1f92a.png","zipper_mouth_face":"1f910.png","zzz":"1f4a4.png"},"enableQQ":false,"highlight":true,"lang":"zh-cn","pageSize":10,"placeholder":"你的评论 ...","recordIP":true,"serverURLs":"https://mmnkvcbz.lc-cn-n1-shared.com","visitor":true}},"search":{"algoliaAppID":"9NJS0VQU0I","algoliaIndex":"blog","algoliaSearchKey":"85d62ea65a7f7445fbfb413bdca088f2","highlightTag":"em","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"algolia"}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
