<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <title>Go 内存管理总结 - Shiori&#39;s Blog</title><meta name="Description" content="Golang 协程栈实现，堆内存管理实现"><meta property="og:title" content="Go 内存管理总结" />
<meta property="og:description" content="Golang 协程栈实现，堆内存管理实现" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://KanShiori.github.io/posts/language/golang/language/memory-manager/" /><meta property="og:image" content="https://KanShiori.github.io/icons/favicon-16x16.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-01-05T18:28:41+08:00" />
<meta property="article:modified_time" content="2022-08-30T21:21:08+08:00" /><meta property="og:site_name" content="My cool site" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://KanShiori.github.io/icons/favicon-16x16.png"/>

<meta name="twitter:title" content="Go 内存管理总结"/>
<meta name="twitter:description" content="Golang 协程栈实现，堆内存管理实现"/>
<meta name="application-name" content="Shiori&#39;s Blog">
<meta name="apple-mobile-web-app-title" content="Shiori&#39;s Blog"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="icon" href="/icons/favicon.ico"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://KanShiori.github.io/posts/language/golang/language/memory-manager/" /><link rel="prev" href="https://KanShiori.github.io/posts/cloud/vm/kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%BD%91%E7%BB%9C/" /><link rel="next" href="https://KanShiori.github.io/posts/language/golang/language/garbage-collection/" /><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css"></noscript><link rel="preload" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css"></noscript><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Go 内存管理总结",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/KanShiori.github.io\/posts\/language\/golang\/language\/memory-manager\/"
        },"image": ["https:\/\/KanShiori.github.io\/images\/Apple-Devices-Preview.png"],"genre": "posts","keywords": "Golang, Golang 原理","wordcount":  15444 ,
        "url": "https:\/\/KanShiori.github.io\/posts\/language\/golang\/language\/memory-manager\/","datePublished": "2021-01-05T18:28:41+08:00","dateModified": "2022-08-30T21:21:08+08:00","license": "This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher": {
            "@type": "Organization",
            "name": "xxxx","logo": "https:\/\/KanShiori.github.io\/images\/avatar.png"},"author": {
                "@type": "Person",
                "name": "Shiori"
            },"description": "Golang 协程栈实现，堆内存管理实现"
    }
    </script></head>
    <body data-header-desktop="fixed" data-header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="Shiori&#39;s Blog"><img
        class="lazyload logo"
        src="/svg/loading.min.svg"
        data-src="/icons/favicon-32x32.png"
        data-srcset="/icons/favicon-32x32.png, /icons/favicon-32x32.png 1.5x, /icons/favicon-32x32.png 2x"
        data-sizes="auto"
        alt="/icons/favicon-32x32.png"
        title="/icons/favicon-32x32.png" />Shiori&#39;s Blog</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="http://kanshiori.cn" rel="noopener noreffer" target="_blank"> 主页 </a><a class="menu-item" href="/posts/"> 所有文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><a class="menu-item" href="/about/"> 关于 </a><a class="menu-item" href="https://github.com/KanShiori/KanShiori.github.io" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i>  </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="Shiori&#39;s Blog"><img
        class="lazyload logo"
        src="/svg/loading.min.svg"
        data-src="/icons/favicon-32x32.png"
        data-srcset="/icons/favicon-32x32.png, /icons/favicon-32x32.png 1.5x, /icons/favicon-32x32.png 2x"
        data-sizes="auto"
        alt="/icons/favicon-32x32.png"
        title="/icons/favicon-32x32.png" />Shiori&#39;s Blog</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="http://kanshiori.cn" title="" rel="noopener noreffer" target="_blank">主页</a><a class="menu-item" href="/posts/" title="">所有文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a class="menu-item" href="/about/" title="">关于</a><a class="menu-item" href="https://github.com/KanShiori/KanShiori.github.io" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i></a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a></div>
    </div>
</header><div class="search-dropdown desktop">
        <div id="search-dropdown-desktop"></div>
    </div>
    <div class="search-dropdown mobile">
        <div id="search-dropdown-mobile"></div>
    </div><main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Go 内存管理总结</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>Shiori</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/golang/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>Golang</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw" aria-hidden="true"></i>&nbsp;<time datetime="2021-01-05">2021-01-05</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden="true"></i>&nbsp;约 15444 字&nbsp;
                <i class="far fa-clock fa-fw" aria-hidden="true"></i>&nbsp;预计阅读 31 分钟&nbsp;</div>
        </div><div class="details toc" id="toc-static"  data-kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right" aria-hidden="true"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#1-linux-内存模型">1 Linux 内存模型</a></li>
    <li><a href="#2-pc-与-sp">2 PC 与 SP</a>
      <ul>
        <li><a href="#21-pc">2.1 PC</a></li>
        <li><a href="#22-sp">2.2 SP</a></li>
      </ul>
    </li>
    <li><a href="#3-goroutine-栈">3 Goroutine 栈</a>
      <ul>
        <li><a href="#31-新-g-的栈">3.1 新 G 的栈</a></li>
        <li><a href="#32-栈的分配">3.2 栈的分配</a></li>
        <li><a href="#33-栈的扩容">3.3 栈的扩容</a>
          <ul>
            <li><a href="#331-扩容判断">3.3.1 扩容判断</a></li>
            <li><a href="#332-扩容">3.3.2 扩容</a></li>
          </ul>
        </li>
        <li><a href="#34-栈的释放">3.4 栈的释放</a></li>
        <li><a href="#35-栈的切换">3.5 栈的切换</a></li>
        <li><a href="#36-g0-的栈">3.6 g0 的栈</a></li>
      </ul>
    </li>
    <li><a href="#4-内存模型">4 内存模型</a>
      <ul>
        <li><a href="#41-概览">4.1 概览</a></li>
        <li><a href="#42-mspan">4.2 mspan</a>
          <ul>
            <li><a href="#421-object-分配">4.2.1 object 分配</a></li>
            <li><a href="#422-mspan-的清理">4.2.2 mspan 的清理</a></li>
          </ul>
        </li>
        <li><a href="#43-mcache">4.3 mcache</a>
          <ul>
            <li><a href="#431-mspan-的分配">4.3.1 mspan 的分配</a></li>
            <li><a href="#432-mspan-的获取">4.3.2 mspan 的获取</a></li>
          </ul>
        </li>
        <li><a href="#44-mcentral">4.4 mcentral</a>
          <ul>
            <li><a href="#441-从-mcentral-申请-mspan">4.4.1 从 mcentral 申请 mspan</a></li>
            <li><a href="#442-mcentral-扩容">4.4.2 mcentral 扩容</a></li>
            <li><a href="#443-mcentral-回收-mspan">4.4.3 mcentral 回收 mspan</a></li>
          </ul>
        </li>
        <li><a href="#45-mheap">4.5 mheap</a>
          <ul>
            <li><a href="#451-虚拟内存布局">4.5.1 虚拟内存布局</a></li>
            <li><a href="#452-mheap-初始化">4.5.2 mheap 初始化</a></li>
            <li><a href="#453-mheap-分配-mspan">4.5.3 mheap 分配 mspan</a></li>
            <li><a href="#454-mheap-回收-mspan">4.5.4 mheap 回收 mspan</a></li>
            <li><a href="#455-mheap-扩容">4.5.5 mheap 扩容</a></li>
          </ul>
        </li>
        <li><a href="#46-总结">4.6 总结</a></li>
      </ul>
    </li>
    <li><a href="#5-对象分配流程">5 对象分配流程</a>
      <ul>
        <li><a href="#51-tiny-object-分配">5.1 tiny object 分配</a></li>
        <li><a href="#52-object-分配">5.2 object 分配</a></li>
        <li><a href="#53-large-object-分配">5.3 large object 分配</a></li>
      </ul>
    </li>
    <li><a href="#6-内存的释放">6 内存的释放</a>
      <ul>
        <li><a href="#61-释放操作">6.1 释放操作</a></li>
        <li><a href="#62-释放时机">6.2 释放时机</a></li>
      </ul>
    </li>
    <li><a href="#参考">参考</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><blockquote>
<p><strong>总结系列的文章</strong>是自己的学习或使用后，对相关知识的一个总结，用于后续可以快速复习与回顾。</p>
</blockquote>
<p>本文是对 Golang 内存模型与内存管理的一个总结，基本内容来源于网络的学习，以及自己观摩了下源码。</p>
<p>下面代码都是基于 go 1.15.6。</p>
<h2 id="1-linux-内存模型">1 Linux 内存模型</h2>
<p>所有语言的内存管理，在 Linux 上都是在以基本的进程内存模型基础上实现的，首先需要知道 Linux 进程内存布局。</p>
<p>在进程角度，看到的所有内存就是 <strong><ruby>虚拟地址空间<rt>virtual address space</rt></ruby></strong> ，整个是一个线性的存储地址。其中一部分高地址区域用户态无法访问，是内核地址空间。而另一部分就是由栈、mmap、堆等内存区域组成的用户地址空间。








    <br><img src="/posts/language/golang/language/memory-manager/img1.png"/>


</p>
<p>上面进程可以自己分配与管理的进程，就是 mmap 与 堆，对应的系统调用为 <strong><code>mmap()</code></strong> 与 <strong><code>brk()</code></strong>，因此所有语言的内存管理都是基于这两个内存区域在进一步实现的（包括 glibc 的 malloc() 与 free()）。</p>
<p>mmap 最基本有两个用途：</p>
<ul>
<li><code>文件映射</code> ：申请一块内存区域，映射到文件系统上一个文件（这也是 page_cache 的基本原理，所以他们在内核中都使用 address_space 实现）</li>
<li><code>匿名映射</code> ：申请一块内存区域，但是没有映射到具体文件，相当于分配了一块内存区域（可以用于父子进程共享、或者自己管理内存的分配等功能）</li>
</ul>
<p>而所有在内存上所说的地址，包括代码指令地址、变量地址都是上面地址空间的一个地址。</p>
<h2 id="2-pc-与-sp">2 PC 与 SP</h2>
<p>Goroutine 将进程的切换变为了协程间的切换，那么就需要<strong>在用户空间负责执行代码与协程上下文的保留与切换</strong>。因此，有两个关键的寄存器：PC 与 SP。</p>
<h3 id="21-pc">2.1 PC</h3>
<p><strong><ruby>程序计数器 PC<rt>Program Counter</rt></ruby></strong> 是 CPU 中的一个寄存器，<strong>保存着下一个 CPU 执行的指令的位置</strong>。顺序执行指令时，PC = PC + 1（一个指令）。而调用函数或者条件跳转时，会将跳到的指令地址设置到 PC 中。</p>
<p>所以，可以想到，当需要切换执行的 goroutine，调用 JMP 指令跳转到 G 对应的代码。</p>
<h3 id="22-sp">2.2 SP</h3>
<p><strong><ruby>栈顶指针 SP<rt>stack pointer</rt></ruby></strong> 是<strong>保存栈顶地址的寄存器</strong>，我们平时所说的临时变量在栈上，就是将临时变量的值写入 SP 保存的内存地址，然后 SP 保存的地址减小（栈是从高地址向低地址变化），然后临时变量销毁时，SP 地址又变为高地址。</p>
<p>不过，因为 goroutine 切换时，必须要保存当前 goroutine 的上下文，也就是栈里的变量。因此，goroutine 栈肯定是不能使用 Linux 进程栈了（因为进程栈有上限，也无法实现“保存”这种功能）。所以所说的<strong>协程栈，都是基于 mmap 申请内存空间</strong>（基于 Go 内存管理，内存管理基于 mmap），然后<strong>切换时修改 SP 寄存器地址实现的</strong>。</p>
<p>这也是为什么 goroutine 栈可以“无限大”的原因了。</p>
<h2 id="3-goroutine-栈">3 Goroutine 栈</h2>
<p>整体的一个 G 的栈如下图所示：








    <br><img src="/posts/language/golang/language/memory-manager/img2.png"/>


</p>
<ul>
<li><code>stack.lo</code>： G 栈的最大低地址（也就是上限）；</li>
<li><code>stack.hi</code>：G 栈的初始地址；</li>
<li><code>stackguard0</code>：阈值地址，用于判断 G 栈是否需要扩容；</li>
<li>StackGuard：常量，栈的保护区，也就是预留的地址；</li>
<li>StackSmall：常量，用于小函数调用的优化；</li>
</ul>
<p>先看一下 g 的实现中包含的 stack 属性（runtime/runtime2.go），其实注释写的就很明白了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">g</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// Stack parameters.
</span><span class="c1"></span>	<span class="c1">// stack describes the actual stack memory: [stack.lo, stack.hi).
</span><span class="c1"></span>	<span class="c1">// stackguard0 is the stack pointer compared in the Go stack growth prologue.
</span><span class="c1"></span>	<span class="c1">// It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption.
</span><span class="c1"></span>	<span class="c1">// stackguard1 is the stack pointer compared in the C stack growth prologue.
</span><span class="c1"></span>	<span class="c1">// It is stack.lo+StackGuard on g0 and gsignal stacks.
</span><span class="c1"></span>	<span class="c1">// It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash).
</span><span class="c1"></span>	<span class="nx">stack</span>       <span class="nx">stack</span>   <span class="c1">// offset known to runtime/cgo
</span><span class="c1"></span>	<span class="nx">stackguard0</span> <span class="kt">uintptr</span> <span class="c1">// offset known to liblink
</span><span class="c1"></span>    <span class="nx">stackguard1</span> <span class="kt">uintptr</span> <span class="c1">// offset known to liblink
</span><span class="c1"></span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li><code>stack</code> 属性就是 G 对应的栈了（这也表明了不是使用的进程栈）；</li>
</ul>
<div class="details admonition note open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-pencil-alt fa-fw" aria-hidden="true"></i>Note<i class="details-icon fas fa-angle-right fa-fw" aria-hidden="true"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">stack 与 stackguard0 属性一定要在 g 结构的开头，因为汇编中会使用指定的偏移 (0x10) 来获取对应的值；</div>
        </div>
    </div>
<p>具体看一下 stack 结构（runtime/runtime2.go）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Stack describes a Go execution stack.
</span><span class="c1">// The bounds of the stack are exactly [lo, hi),
</span><span class="c1">// with no implicit data structures on either side.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">stack</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">lo</span> <span class="kt">uintptr</span>
	<span class="nx">hi</span> <span class="kt">uintptr</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="31-新-g-的栈">3.1 新 G 的栈</h3>
<p>在 <strong><code>malg</code></strong> 函数中，可以看到对于新 G 的栈的分配（一开始为 2KB）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Allocate a new g, with a stack big enough for stacksize bytes.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">malg</span><span class="p">(</span><span class="nx">stacksize</span> <span class="kt">int32</span><span class="p">)</span> <span class="o">*</span><span class="nx">g</span> <span class="p">{</span>
	<span class="nx">newg</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">g</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">stacksize</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">stacksize</span> <span class="p">=</span> <span class="nf">round2</span><span class="p">(</span><span class="nx">_StackSystem</span> <span class="o">+</span> <span class="nx">stacksize</span><span class="p">)</span>
		
		<span class="c1">// 在公共的 goroutine(g0) 上调用函数
</span><span class="c1"></span>		<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		    <span class="c1">// 分配一个 stack
</span><span class="c1"></span>			<span class="nx">newg</span><span class="p">.</span><span class="nx">stack</span> <span class="p">=</span> <span class="nf">stackalloc</span><span class="p">(</span><span class="nb">uint32</span><span class="p">(</span><span class="nx">stacksize</span><span class="p">))</span>
		<span class="p">})</span>
		
		<span class="c1">// 设置 stackguard0 地址
</span><span class="c1"></span>		<span class="nx">newg</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">newg</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">+</span> <span class="nx">_StackGuard</span>
		<span class="nx">newg</span><span class="p">.</span><span class="nx">stackguard1</span> <span class="p">=</span> <span class="p">^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
		<span class="c1">// Clear the bottom word of the stack. We record g
</span><span class="c1"></span>		<span class="c1">// there on gsignal stack during VDSO on ARM and ARM64.
</span><span class="c1"></span>		<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">newg</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="p">))</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">newg</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="details admonition note open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-pencil-alt fa-fw" aria-hidden="true"></i>Note<i class="details-icon fas fa-angle-right fa-fw" aria-hidden="true"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><p>注意 <strong><code>systemstack()</code></strong>，用于将当前栈切换到 M 的 g0 协程栈上执行命令。</p>
<p>Why? 因为 G 用于执行用户逻辑，而某些管理操作不方便在 G 栈上执行（例如 G 可能中途停止，垃圾回收时 G 栈空间也有可能被回收），所以需要执行管理命令时，都会通过 systemstack 方法将线程栈切换为 g0 的栈执行，与用户逻辑隔离。</p>
</div>
        </div>
    </div>
<h3 id="32-栈的分配">3.2 栈的分配</h3>
<p><code>stackalloc()</code> 函数用于分配一个栈，无论是给新 G 还是扩容栈时都会用到，因此栈空间的分配与回收是一个比较频繁的操作，所以栈空间采取了缓存复用的方式。</p>
<p>主要逻辑如下：</p>
<ol>
<li>如果分配的栈空间不大，就走<strong>缓存复用</strong>这种方式分配。没有可以复用的就创建；</li>
<li>如果分配的栈空间很大（大于 32KB），就直接从 heap 分配；</li>
</ol>
<p>这里主要关注第 1 中方式，会调用 <code>stackpoolalloc()</code> 函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Allocates a stack from the free pool. Must be called with
</span><span class="c1">// stackpool[order].item.mu held.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">stackpoolalloc</span><span class="p">(</span><span class="nx">order</span> <span class="kt">uint8</span><span class="p">)</span> <span class="nx">gclinkptr</span> <span class="p">{</span>
	<span class="nx">list</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">stackpool</span><span class="p">[</span><span class="nx">order</span><span class="p">].</span><span class="nx">item</span><span class="p">.</span><span class="nx">span</span>
    <span class="nx">s</span> <span class="o">:=</span> <span class="nx">list</span><span class="p">.</span><span class="nx">first</span>
    
	<span class="c1">// ...
</span><span class="c1"></span>    
    <span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// 没有可以复用的栈，走内存管理创建
</span><span class="c1"></span>		<span class="nx">s</span> <span class="p">=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nf">allocManual</span><span class="p">(</span><span class="nx">_StackCacheSize</span><span class="o">&gt;&gt;</span><span class="nx">_PageShift</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">stacks_inuse</span><span class="p">)</span>
		<span class="c1">// ... 
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="nx">x</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">manualFreeList</span>
	<span class="k">if</span> <span class="nx">x</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;span has no free stacks&#34;</span><span class="p">)</span>
	<span class="p">}</span>
    <span class="nx">s</span><span class="p">.</span><span class="nx">manualFreeList</span> <span class="p">=</span> <span class="nx">x</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">next</span>
    
	<span class="c1">// ...
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">x</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看到，<strong>首先尝试从 stackpool 缓存的空闲的 stack 获取，如果没有则走 Go 内存管理申请一个。</strong></p>
<p>再接下来就是 Go 内存管理模块负责的事了，<del>不深入下去</del>（后面再说）。底层创建都是使用 mmap 系统调用实现的，这里可以看下使用的参数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Don&#39;t split the stack as this method may be invoked without a valid G, which
</span><span class="c1">// prevents us from allocating more stack.
</span><span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">sysAlloc</span><span class="p">(</span><span class="nx">n</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">sysStat</span> <span class="o">*</span><span class="kt">uint64</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
	<span class="nx">p</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">mmap</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">_PROT_READ</span><span class="p">|</span><span class="nx">_PROT_WRITE</span><span class="p">,</span> <span class="nx">_MAP_ANON</span><span class="p">|</span><span class="nx">_MAP_PRIVATE</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">_EACCES</span> <span class="p">{</span>
			<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: mmap: access denied\n&#34;</span><span class="p">)</span>
			<span class="nf">exit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">_EAGAIN</span> <span class="p">{</span>
			<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: mmap: too much locked memory (check &#39;ulimit -l&#39;).\n&#34;</span><span class="p">)</span>
			<span class="nf">exit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="nf">mSysStatInc</span><span class="p">(</span><span class="nx">sysStat</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">p</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>通过 mmap 调用的参数可以看到，申请了一个系统分配的<strong>匿名内存映射</strong>。</p>
<h3 id="33-栈的扩容">3.3 栈的扩容</h3>
<h4 id="331-扩容判断">3.3.1 扩容判断</h4>
<p>Go 编译器会在执行函数前，插入一些汇编指令，其中一个功能就是<strong>检查 G 栈是否需要扩容</strong>。看一个函数调用的实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// main() 调用 test()
</span><span class="c1"></span><span class="err">$</span> <span class="k">go</span> <span class="nx">build</span> <span class="o">-</span><span class="nx">gcflags</span> <span class="s">&#34;-l&#34;</span> <span class="o">-</span><span class="nx">o</span> <span class="nx">test</span> <span class="nx">main</span><span class="p">.</span><span class="k">go</span>
<span class="err">$</span> <span class="k">go</span> <span class="nx">tool</span> <span class="nx">objump</span> <span class="o">-</span><span class="nx">s</span> <span class="s">&#34;main\.test&#34;</span> <span class="nx">test</span>
<span class="nx">TEXT</span> <span class="nx">main</span><span class="p">.</span><span class="nf">test</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span> <span class="o">/</span><span class="nx">root</span><span class="o">/</span><span class="nx">yusihao</span><span class="o">/</span><span class="nx">onething</span><span class="o">/</span><span class="nx">BizImages</span><span class="o">/</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span>
  <span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">3</span> <span class="mh">0x45dc80</span> <span class="nx">MOVQ</span> <span class="nx">FS</span><span class="p">:</span><span class="mh">0xfffffff8</span><span class="p">,</span> <span class="nx">CX</span>  <span class="c1">// CX 为当前 G 地址		
</span><span class="c1"></span>  <span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">3</span> <span class="mh">0x45dc89</span> <span class="nx">CMPQ</span> <span class="mh">0x10</span><span class="p">(</span><span class="nx">CX</span><span class="p">),</span> <span class="nx">SP</span>  	 <span class="c1">// CX+0x10 执行 g.stackguard0 属性，与 SP 指针地址比较	
</span><span class="c1"></span>  <span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">3</span> <span class="mh">0x45dc8d</span> <span class="nx">JBE</span> <span class="mh">0x45dccf</span>	 	     <span class="c1">// 如果 SP &lt;=stackguard0  跳转到 0x45dccf，也就是调用 runtime.morestack_noctxt(SB) 函数	
</span><span class="c1"></span>  <span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">3</span> <span class="mh">0x45dc8f</span> <span class="nx">SUBQ</span> <span class="err">$</span><span class="mh">0x18</span><span class="p">,</span> <span class="nx">SP</span>	

  <span class="c1">// ...
</span><span class="c1"></span>
  <span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span> <span class="mh">0x45dcce</span> <span class="nx">RET</span>                                <span class="c1">// 函数执行结束，RET 返回，不会执行后面两个指令				
</span><span class="c1"></span>  <span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">3</span> <span class="mh">0x45dccf</span> <span class="nx">CALL</span> <span class="nx">runtime</span><span class="p">.</span><span class="nf">morestack_noctxt</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>  <span class="c1">// 执行栈扩容	
</span><span class="c1"></span>  <span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">3</span> <span class="mh">0x45dcd4</span> <span class="nx">MP</span> <span class="nx">main</span><span class="p">.</span><span class="nf">test</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>                   <span class="c1">// 执行结束后，重新执行当前函数	
</span></code></pre></td></tr></table>
</div>
</div><p>逻辑很简单，如果 SP &lt;= stackguard0，那么就执行栈的扩容，扩容结束重新执行当前函数。
<div class="details admonition note open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-pencil-alt fa-fw" aria-hidden="true"></i>Note<i class="details-icon fas fa-angle-right fa-fw" aria-hidden="true"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><p>上面比较 SP 时候，没有考虑当前函数调用使用的空间大小。Why?</p>
<p>因为测试程序这个函数中使用的空间比较小，而 stackguard0  与 stack.lo 有一段<strong>保护区</strong>，所以编译器允许这里 &ldquo;溢出&rdquo; 一些，所以这里就没有让 SP 考虑函数使用空间。</p>
<p>如果函数中使用的空间大过保护区时，比较时就会让 SP 减去当前函数使用空间再比较了。</p>
</div>
        </div>
    </div></p>
<h4 id="332-扩容">3.3.2 扩容</h4>
<p>扩容逻辑大致分为三步：</p>
<ol>
<li>分配一个 2x 新栈；</li>
<li>拷贝当前栈数据至新栈；</li>
<li>&ldquo;释放&quot;掉旧栈；</li>
</ol>
<p>从上面扩容判断可以看到，会调用 <strong><code>morestack</code></strong> 的汇编代码：<a id="morestack"></a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Called during function prolog when more stack is needed.
</span><span class="c1">// R3 prolog&#39;s LR
</span><span class="c1">// using NOFRAME means do not save LR on stack.
</span><span class="c1">//
</span><span class="c1">// The traceback routines see morestack on a g0 as being
</span><span class="c1">// the top of a stack (for example, morestack calling newstack
</span><span class="c1">// calling the scheduler calling newm calling gc), so we must
</span><span class="c1">// record an argument size. For that purpose, it has no arguments.
</span><span class="c1"></span><span class="nx">TEXT</span> <span class="nx">runtime</span><span class="err">·</span><span class="nf">morestack</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span><span class="nx">NOSPLIT</span><span class="p">|</span><span class="nx">NOFRAME</span><span class="p">,</span><span class="err">$</span><span class="mi">0</span><span class="o">-</span><span class="mi">0</span>
	<span class="c1">// Cannot grow scheduler stack (m-&gt;g0).
</span><span class="c1"></span>	<span class="nx">MOVW</span>        <span class="nf">g_m</span><span class="p">(</span><span class="nx">g</span><span class="p">),</span> <span class="nx">R8</span>
	<span class="nx">MOVW</span>        <span class="nf">m_g0</span><span class="p">(</span><span class="nx">R8</span><span class="p">),</span> <span class="nx">R4</span>
	<span class="nx">CMP</span>        <span class="nx">g</span><span class="p">,</span> <span class="nx">R4</span>
	<span class="nx">BNE</span>        <span class="mi">3</span><span class="p">(</span><span class="nx">PC</span><span class="p">)</span>
	<span class="nx">BL</span>        <span class="nx">runtime</span><span class="err">·</span><span class="nf">badmorestackg0</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
	<span class="nx">B</span>        <span class="nx">runtime</span><span class="err">·</span><span class="nf">abort</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>

	<span class="c1">// Cannot grow signal stack (m-&gt;gsignal).
</span><span class="c1"></span>	<span class="nx">MOVW</span>        <span class="nf">m_gsignal</span><span class="p">(</span><span class="nx">R8</span><span class="p">),</span> <span class="nx">R4</span>
	<span class="nx">CMP</span>        <span class="nx">g</span><span class="p">,</span> <span class="nx">R4</span>
	<span class="nx">BNE</span>        <span class="mi">3</span><span class="p">(</span><span class="nx">PC</span><span class="p">)</span>
	<span class="nx">BL</span>        <span class="nx">runtime</span><span class="err">·</span><span class="nf">badmorestackgsignal</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
	<span class="nx">B</span>        <span class="nx">runtime</span><span class="err">·</span><span class="nf">abort</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>

	<span class="c1">// Called from f.
</span><span class="c1"></span>	<span class="c1">// Set g-&gt;sched to context in f.
</span><span class="c1"></span>	<span class="nx">MOVW</span>        <span class="nx">R13</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_sp</span><span class="p">)(</span><span class="nx">g</span><span class="p">)</span>
	<span class="nx">MOVW</span>        <span class="nx">LR</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_pc</span><span class="p">)(</span><span class="nx">g</span><span class="p">)</span>
	<span class="nx">MOVW</span>        <span class="nx">R3</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_lr</span><span class="p">)(</span><span class="nx">g</span><span class="p">)</span>
	<span class="nx">MOVW</span>        <span class="nx">R7</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_ctxt</span><span class="p">)(</span><span class="nx">g</span><span class="p">)</span>

	<span class="c1">// Called from f.
</span><span class="c1"></span>	<span class="c1">// Set m-&gt;morebuf to f&#39;s caller.
</span><span class="c1"></span>	<span class="nx">MOVW</span>        <span class="nx">R3</span><span class="p">,</span> <span class="p">(</span><span class="nx">m_morebuf</span><span class="o">+</span><span class="nx">gobuf_pc</span><span class="p">)(</span><span class="nx">R8</span><span class="p">)</span>        <span class="c1">// f&#39;s caller&#39;s PC
</span><span class="c1"></span>	<span class="nx">MOVW</span>        <span class="nx">R13</span><span class="p">,</span> <span class="p">(</span><span class="nx">m_morebuf</span><span class="o">+</span><span class="nx">gobuf_sp</span><span class="p">)(</span><span class="nx">R8</span><span class="p">)</span>        <span class="c1">// f&#39;s caller&#39;s SP
</span><span class="c1"></span>	<span class="nx">MOVW</span>        <span class="nx">g</span><span class="p">,</span> <span class="p">(</span><span class="nx">m_morebuf</span><span class="o">+</span><span class="nx">gobuf_g</span><span class="p">)(</span><span class="nx">R8</span><span class="p">)</span>

	<span class="c1">// Call newstack on m-&gt;g0&#39;s stack.
</span><span class="c1"></span>	<span class="nx">MOVW</span>        <span class="nf">m_g0</span><span class="p">(</span><span class="nx">R8</span><span class="p">),</span> <span class="nx">R0</span>
	<span class="nx">BL</span>        <span class="nx">setg</span><span class="p">&lt;&gt;(</span><span class="nx">SB</span><span class="p">)</span>
	<span class="nf">MOVW</span>        <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_sp</span><span class="p">)(</span><span class="nx">g</span><span class="p">),</span> <span class="nx">R13</span>
	<span class="nx">MOVW</span>        <span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="nx">R0</span>
	<span class="nx">MOVW</span><span class="p">.</span><span class="nx">W</span>  <span class="nx">R0</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">(</span><span class="nx">R13</span><span class="p">)</span>        <span class="c1">// create a call frame on g0 (saved LR)
</span><span class="c1"></span>	<span class="nx">BL</span>        <span class="nx">runtime</span><span class="err">·</span><span class="nf">newstack</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>

	<span class="c1">// Not reached, but make sure the return PC from the call to newstack
</span><span class="c1"></span>	<span class="c1">// is still in this function, and not the beginning of the next.
</span><span class="c1"></span>	<span class="nx">RET</span>

<span class="nx">TEXT</span> <span class="nx">runtime</span><span class="err">·</span><span class="nf">morestack_noctxt</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span><span class="nx">NOSPLIT</span><span class="p">|</span><span class="nx">NOFRAME</span><span class="p">,</span><span class="err">$</span><span class="mi">0</span><span class="o">-</span><span class="mi">0</span>
	<span class="nx">MOVW</span>        <span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="nx">R7</span>
	<span class="nx">B</span> <span class="nx">runtime</span><span class="err">·</span><span class="nf">morestack</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>可以看到 <strong>g0，gsignal 的栈都不会扩容</strong></li>
<li>在 g0 栈上会调用 <code>newstack()</code> 函数</li>
</ul>
<p>调用的 <strong><code>newstack()</code></strong> 函数（runtime/stack.go），过程很复杂，只看一下关键点：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Called from runtime·morestack when more stack is needed.
</span><span class="c1">// Allocate larger stack and relocate to new stack.
</span><span class="c1">// Stack growth is multiplicative, for constant amortized cost.
</span><span class="c1">//
</span><span class="c1">// g-&gt;atomicstatus will be Grunning or Gscanrunning upon entry.
</span><span class="c1">// If the scheduler is trying to stop this g, then it will set preemptStop.
</span><span class="c1">//
</span><span class="c1">// This must be nowritebarrierrec because it can be called as part of
</span><span class="c1">// stack growth from other nowritebarrierrec functions, but the
</span><span class="c1">// compiler doesn&#39;t check this.
</span><span class="c1">//
</span><span class="c1">//go:nowritebarrierrec
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">newstack</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">thisg</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
    <span class="nx">gp</span> <span class="o">:=</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span>
    
    <span class="c1">// ...
</span><span class="c1"></span>
	<span class="c1">// 新栈大小为当前两倍
</span><span class="c1"></span>	<span class="nx">oldsize</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span> <span class="o">-</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span>
    <span class="nx">newsize</span> <span class="o">:=</span> <span class="nx">oldsize</span> <span class="o">*</span> <span class="mi">2</span>
    
    <span class="c1">// ...
</span><span class="c1"></span>
	<span class="c1">// 改变 G 状态为 copy stack，gc 会跳过该状态的 G
</span><span class="c1"></span>	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Gcopystack</span><span class="p">)</span>

    <span class="c1">// 分配新栈，拷贝数据，释放旧站
</span><span class="c1"></span>	<span class="c1">// The concurrent GC will not scan the stack while we are doing the copy since
</span><span class="c1"></span>	<span class="c1">// the gp is in a Gcopystack status.
</span><span class="c1"></span>	<span class="nf">copystack</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">newsize</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">stackDebug</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;stack grow done\n&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gcopystack</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">)</span>
	<span class="c1">// 执行 G 代码
</span><span class="c1"></span>	<span class="nf">gogo</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Copies gp&#39;s stack to a new stack of a different size.
</span><span class="c1">// Caller must have changed gp status to Gcopystack.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">copystack</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">newsize</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 创建新 stack
</span><span class="c1"></span>	<span class="nx">new</span> <span class="o">:=</span> <span class="nf">stackalloc</span><span class="p">(</span><span class="nb">uint32</span><span class="p">(</span><span class="nx">newsize</span><span class="p">))</span>
	<span class="c1">// ...
</span><span class="c1"></span>	<span class="c1">// 拷贝数据
</span><span class="c1"></span>	<span class="nf">memmove</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">new</span><span class="p">.</span><span class="nx">hi</span><span class="o">-</span><span class="nx">ncopy</span><span class="p">),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">old</span><span class="p">.</span><span class="nx">hi</span><span class="o">-</span><span class="nx">ncopy</span><span class="p">),</span> <span class="nx">ncopy</span><span class="p">)</span>
	<span class="c1">// ...
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span> <span class="p">=</span> <span class="nx">new</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">new</span><span class="p">.</span><span class="nx">lo</span> <span class="o">+</span> <span class="nx">_StackGuard</span> 
	<span class="c1">// 释放旧 stack
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">stackPoisonCopy</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">fillstack</span><span class="p">(</span><span class="nx">old</span><span class="p">,</span> <span class="mh">0xfc</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">stackfree</span><span class="p">(</span><span class="nx">old</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="34-栈的释放">3.4 栈的释放</h3>
<p>stackfree 栈的释放与申请相反，放入 stackpool，或者直接调用内存管理删除，重点还是内存管理的活，所以这里不展开。</p>
<h3 id="35-栈的切换">3.5 栈的切换</h3>
<p>切换应该是属于 goroutine 调度的内容，不过这里可以关注一下栈时如何切换的。
当 M 执行的 G 需要切换，或者一个新创建 G 执行时，最后都会调用 <code>execute()</code> 函数，而 execute() 函数会调用 gogo 汇编实现的函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// func gogo(buf *gobuf)
</span><span class="c1">// restore state from Gobuf; longjmp
</span><span class="c1"></span><span class="nx">TEXT</span> <span class="nx">runtime</span><span class="err">·</span><span class="nf">gogo</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">NOSPLIT</span><span class="p">,</span> <span class="err">$</span><span class="mi">16</span><span class="o">-</span><span class="mi">8</span>
	<span class="nx">MOVQ</span>	<span class="nx">buf</span><span class="o">+</span><span class="mi">0</span><span class="p">(</span><span class="nx">FP</span><span class="p">),</span> <span class="nx">BX</span>		<span class="c1">// gobuf
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="nf">gobuf_g</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">DX</span>
	<span class="nx">MOVQ</span>	<span class="mi">0</span><span class="p">(</span><span class="nx">DX</span><span class="p">),</span> <span class="nx">CX</span>		    <span class="c1">// make sure g != nil
</span><span class="c1"></span>	<span class="nf">get_tls</span><span class="p">(</span><span class="nx">CX</span><span class="p">)</span>
	<span class="nx">MOVQ</span>	<span class="nx">DX</span><span class="p">,</span> <span class="nf">g</span><span class="p">(</span><span class="nx">CX</span><span class="p">)</span>
	<span class="nx">MOVQ</span>	<span class="nf">gobuf_sp</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">SP</span>	<span class="c1">// restore SP （关键！)
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="nf">gobuf_ret</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">AX</span>
	<span class="nx">MOVQ</span>	<span class="nf">gobuf_ctxt</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">DX</span>
	<span class="nx">MOVQ</span>	<span class="nf">gobuf_bp</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">BP</span>
	<span class="nx">MOVQ</span>	<span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="nf">gobuf_sp</span><span class="p">(</span><span class="nx">BX</span><span class="p">)</span>	<span class="c1">// clear to help garbage collector
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="nf">gobuf_ret</span><span class="p">(</span><span class="nx">BX</span><span class="p">)</span>
	<span class="nx">MOVQ</span>	<span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="nf">gobuf_ctxt</span><span class="p">(</span><span class="nx">BX</span><span class="p">)</span>
	<span class="nx">MOVQ</span>	<span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="nf">gobuf_bp</span><span class="p">(</span><span class="nx">BX</span><span class="p">)</span>
	<span class="nx">MOVQ</span>	<span class="nf">gobuf_pc</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">BX</span>
	<span class="nx">JMP</span>	<span class="nx">BX</span>
</code></pre></td></tr></table>
</div>
</div><p><code>gobuf</code> 中保存着要执行的 G 的 sp、pc 指针，可以看到通过<strong>将对应 gobuf.sp 写入到 SP 寄存器中</strong>，也就是将使用的栈切换为了 G 的栈。</p>
<h3 id="36-g0-的栈">3.6 g0 的栈</h3>
<p>在阅读网上的文章时，许多文章都说 g0 使用的是系统栈，我理解为使用的是进程的栈内存区域。但是思考一下，每个 M 对应一个 g0，也就是说有多个线程要同时共享系统栈，这是不可能的。例如在 pthread 实现中，对应新建的线程也是使用 mmap 分配一个内存区域，然后调用 clone() 系统调用时传入栈地址参数。</p>
<p>看一下代码，确认一下到底 g0 的栈到底是啥，找到一个新建 m 的地方：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">mp</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span>
<span class="nx">mp</span><span class="p">.</span><span class="nx">mstartfn</span> <span class="p">=</span> <span class="nx">fn</span>
<span class="nf">mcommoninit</span><span class="p">(</span><span class="nx">mp</span><span class="p">,</span> <span class="nx">id</span><span class="p">)</span>

<span class="c1">// In case of cgo or Solaris or illumos or Darwin, pthread_create will make us a stack.
</span><span class="c1">// Windows and Plan 9 will layout sched stack on OS stack.
</span><span class="c1"></span><span class="k">if</span> <span class="nx">iscgo</span> <span class="o">||</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;solaris&#34;</span> <span class="o">||</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;illumos&#34;</span> <span class="o">||</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;windows&#34;</span> <span class="o">||</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;plan9&#34;</span> <span class="o">||</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;darwin&#34;</span> <span class="p">{</span>
        <span class="nx">mp</span><span class="p">.</span><span class="nx">g0</span> <span class="p">=</span> <span class="nf">malg</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">mp</span><span class="p">.</span><span class="nx">g0</span> <span class="p">=</span> <span class="nf">malg</span><span class="p">(</span><span class="mi">8192</span> <span class="o">*</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">StackGuardMultiplier</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">mp</span><span class="p">.</span><span class="nx">g0</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="nx">mp</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看到，m 的 g0 属性还是使用的 <a href="#31-%e6%96%b0-g-%e7%9a%84%e6%a0%88" rel=""><strong>malg() 函数</strong></a> 去创建的，与普通的 g 创建一样，只不过初始大小为 8KB。malg() 流程上面有说到，就是走内存管理分配 mspan 作为栈的方式。</p>
<p>不过，g0 的栈还是有些不同的，不会进行栈的扩容（因为仅仅内部管理时用到，不需要进行自动扩容），在栈扩容的 <a href="#morestack" rel=""><strong>morestack 汇编代码</strong></a> 里可以看到。</p>
<h2 id="4-内存模型">4 内存模型</h2>
<h3 id="41-概览">4.1 概览</h3>
<p>Golang 内存管理包含四个组件：</p>
<ol>
<li><strong><code>object</code></strong> ：object 代表用户代码申请的一个对象，没有实际的数据结构，而是在 mspan 中以逻辑切分的方式分配；</li>
<li>page：切分内存的单元，mheap 将内存以 8KB page 切分，然后组合成为 mspan；</li>
<li><strong><code>runtime.mspan</code></strong> ：内存管理的最小单元，由多个 8KB 大小的 page 构成，按照固定大小来切分为多个 object；</li>
<li><strong><code>runtime.mcache</code></strong> ：单个 P 对应的 mspan 的<strong>缓存</strong>，无锁分配；</li>
<li><strong><code>runtime.mcentral</code></strong> ：按照不同大小的 mspan 分组的管理链表，为 mcache 提供空闲 mspan</li>
<li><strong><code>runtime.mheap</code></strong> ：保存闲置的 mspan 与 largerspan 链表，与操作系统申请与释放内存；</li>
</ol>
<p>上面的组件也可以看做分层，普通对象（object）的申请与释放就是按照上下层顺序申请与释放的。
<div class="details admonition note open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-pencil-alt fa-fw" aria-hidden="true"></i>Note<i class="details-icon fas fa-angle-right fa-fw" aria-hidden="true"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">下面<del>不会说</del>（后面再说）具体的 object 分配流程，而是说明各个层次时的申请与释放操作。</div>
        </div>
    </div></p>
<h3 id="42-mspan">4.2 mspan</h3>
<p>每个 mspan 由多个 8KB 的 page 组成，所有的 mspan 会以 list 的方式构建，而不同的模块（mcache、mcentral）通过引用指针，来不同方式来组织不同的 mspan。</p>
<p>每个 mspan 管理多个固定大小的 object，通过编号 (index) 方式来寻找 object 的地址。</p>
<p>结构如下图所示：








    <br><img src="/posts/language/golang/language/memory-manager/img3.png"/>


</p>
<p>其数据结构如下（省略部分）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">mspan</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">next</span> <span class="o">*</span><span class="nx">mspan</span>     <span class="c1">// next span in list, or nil if none
</span><span class="c1"></span>        <span class="nx">prev</span> <span class="o">*</span><span class="nx">mspan</span>     <span class="c1">// previous span in list, or nil if none
</span><span class="c1"></span>
        <span class="nx">startAddr</span> <span class="kt">uintptr</span> <span class="c1">// address of first byte of span aka s.base()
</span><span class="c1"></span>        <span class="nx">npages</span>    <span class="kt">uintptr</span> <span class="c1">// number of pages in span
</span><span class="c1"></span>
        <span class="nx">manualFreeList</span> <span class="nx">gclinkptr</span> <span class="c1">// list of free objects in mSpanManual spans
</span><span class="c1"></span>        <span class="nx">freeindex</span> <span class="kt">uintptr</span>
        <span class="nx">nelems</span> <span class="kt">uintptr</span> <span class="c1">// number of object in the span.
</span><span class="c1"></span>        
        <span class="nx">allocCache</span> <span class="kt">uint64</span>
        <span class="nx">allocBits</span>  <span class="o">*</span><span class="nx">gcBits</span>
        <span class="nx">gcmarkBits</span> <span class="o">*</span><span class="nx">gcBits</span>
        
		<span class="c1">// sweep generation:
</span><span class="c1"></span>		<span class="c1">// if sweepgen == h-&gt;sweepgen - 2, the span needs sweeping
</span><span class="c1"></span>		<span class="c1">// if sweepgen == h-&gt;sweepgen - 1, the span is currently being swept
</span><span class="c1"></span>		<span class="c1">// if sweepgen == h-&gt;sweepgen, the span is swept and ready to use
</span><span class="c1"></span>		<span class="c1">// if sweepgen == h-&gt;sweepgen + 1, the span was cached before sweep began and is still cached, and needs sweeping
</span><span class="c1"></span>		<span class="c1">// if sweepgen == h-&gt;sweepgen + 3, the span was swept and then cached and is still cached
</span><span class="c1"></span>		<span class="c1">// h-&gt;sweepgen is incremented by 2 after every GC
</span><span class="c1"></span>        <span class="nx">sweepgen</span>    <span class="kt">uint32</span>
        <span class="nx">spanclass</span>   <span class="nx">spanClass</span>     <span class="c1">// size class and noscan (uint8)
</span><span class="c1"></span>        <span class="nx">allocCount</span>  <span class="kt">uint16</span>        <span class="c1">// number of allocated objects
</span><span class="c1"></span>        <span class="nx">elemsize</span>    <span class="kt">uintptr</span>       <span class="c1">// computed from sizeclass or from npages
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>next、prev ：链表前后 span；</li>
<li><strong><code>startAddr</code></strong> ：span 在 arena 区域的起始地址；</li>
<li><strong><code>npages</code></strong> ：占用 page(8KB) 数量；</li>
<li>manualFreeList ：空闲 object 链表；</li>
<li><strong><code>freeindex</code></strong> ：下一个空闲的 object 的编号，如果 freeindex == nelem，表明没有空闲 object 可以分配</li>
<li>nelems ：当前 span 中分配的 object 的上限；</li>
<li><strong><code>allocCache</code></strong> ：freeindex 的 cache，通过 bitmap 的方式记录对应编号的 object 内存是否是空闲的；</li>
<li><strong><code>allocBits</code></strong> : 通过 bitmap 标识哪些编号的 object 是分配出去的；</li>
<li><strong><code>gcmarkBits</code></strong> : 经过 GC 后，gcmarkBits 标识出的 object 就是被 mark 的，没有 mark 的变为垃圾对象清除；</li>
<li><strong><code>sweepgen</code></strong> ：mspan 的状态，见注释；</li>
<li>spanclass ：mspan 大小类别；</li>
<li>allocCount ：已经分配的 object 数量；</li>
<li><strong><code>elemsize</code></strong> ：管理的 object 的固定大小；</li>
</ul>
<p>可以看到，每个 mspan 管理着固定大小的 object，并通过一个 freeindex+allocCache 来记录空闲的 object 的编号。由此可以得出：</p>
<ul>
<li><strong>mspan 的地址区域</strong>: <strong><code>[startAddr, startAddr + npages*8*1024)</code></strong></li>
<li><strong>某个 object 的起始地址</strong>: <strong><code>&lt;index&gt;*elemsize + startAddr</code></strong></li>
</ul>
<h4 id="421-object-分配">4.2.1 object 分配</h4>
<p>在创建新的 object 时，对于普通大小的 object 分配（16&lt;size&lt;32KB)，会在从 mcache 中选出具有空闲空间的 mspan，然后记录到 mspan.allocCache 中。</p>
<p>具体代码如下，<code>nextFreeIndex()</code> 函数就是用于得到下一个空闲 object，并移动 <code>freeindex</code>（runtime/mbitmap.go)：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// nextFreeIndex returns the index of the next free object in s at
</span><span class="c1">// or after s.freeindex.
</span><span class="c1">// There are hardware instructions that can be used to make this
</span><span class="c1">// faster if profiling warrants it.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span><span class="p">)</span> <span class="nf">nextFreeIndex</span><span class="p">()</span> <span class="kt">uintptr</span> <span class="p">{</span>
        <span class="nx">sfreeindex</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">freeindex</span>
        <span class="nx">snelems</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span>
        <span class="k">if</span> <span class="nx">sfreeindex</span> <span class="o">==</span> <span class="nx">snelems</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">sfreeindex</span>
        <span class="p">}</span>

        <span class="nx">aCache</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">allocCache</span>

        <span class="nx">bitIndex</span> <span class="o">:=</span> <span class="nx">sys</span><span class="p">.</span><span class="nf">Ctz64</span><span class="p">(</span><span class="nx">aCache</span><span class="p">)</span>
        <span class="k">for</span> <span class="nx">bitIndex</span> <span class="o">==</span> <span class="mi">64</span> <span class="p">{</span>
                <span class="c1">// Move index to start of next cached bits.
</span><span class="c1"></span>                <span class="nx">sfreeindex</span> <span class="p">=</span> <span class="p">(</span><span class="nx">sfreeindex</span> <span class="o">+</span> <span class="mi">64</span><span class="p">)</span> <span class="o">&amp;^</span> <span class="p">(</span><span class="mi">64</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="nx">sfreeindex</span> <span class="o">&gt;=</span> <span class="nx">snelems</span> <span class="p">{</span>
                        <span class="nx">s</span><span class="p">.</span><span class="nx">freeindex</span> <span class="p">=</span> <span class="nx">snelems</span>
                        <span class="k">return</span> <span class="nx">snelems</span>
                <span class="p">}</span>
                <span class="nx">whichByte</span> <span class="o">:=</span> <span class="nx">sfreeindex</span> <span class="o">/</span> <span class="mi">8</span>
                <span class="c1">// Refill s.allocCache with the next 64 alloc bits.
</span><span class="c1"></span>                <span class="nx">s</span><span class="p">.</span><span class="nf">refillAllocCache</span><span class="p">(</span><span class="nx">whichByte</span><span class="p">)</span>
                <span class="nx">aCache</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">allocCache</span>
                <span class="nx">bitIndex</span> <span class="p">=</span> <span class="nx">sys</span><span class="p">.</span><span class="nf">Ctz64</span><span class="p">(</span><span class="nx">aCache</span><span class="p">)</span>
                <span class="c1">// nothing available in cached bits
</span><span class="c1"></span>                <span class="c1">// grab the next 8 bytes and try again.
</span><span class="c1"></span>        <span class="p">}</span>
        <span class="nx">result</span> <span class="o">:=</span> <span class="nx">sfreeindex</span> <span class="o">+</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">bitIndex</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">result</span> <span class="o">&gt;=</span> <span class="nx">snelems</span> <span class="p">{</span>
                <span class="nx">s</span><span class="p">.</span><span class="nx">freeindex</span> <span class="p">=</span> <span class="nx">snelems</span>
                <span class="k">return</span> <span class="nx">snelems</span>
        <span class="p">}</span>

        <span class="nx">s</span><span class="p">.</span><span class="nx">allocCache</span> <span class="o">&gt;&gt;=</span> <span class="nb">uint</span><span class="p">(</span><span class="nx">bitIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="nx">sfreeindex</span> <span class="p">=</span> <span class="nx">result</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="nx">sfreeindex</span><span class="o">%</span><span class="mi">64</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">sfreeindex</span> <span class="o">!=</span> <span class="nx">snelems</span> <span class="p">{</span>
                <span class="c1">// We just incremented s.freeindex so it isn&#39;t 0.
</span><span class="c1"></span>                <span class="c1">// As each 1 in s.allocCache was encountered and used for allocation
</span><span class="c1"></span>                <span class="c1">// it was shifted away. At this point s.allocCache contains all 0s.
</span><span class="c1"></span>                <span class="c1">// Refill s.allocCache so that it corresponds
</span><span class="c1"></span>                <span class="c1">// to the bits at s.allocBits starting at s.freeindex.
</span><span class="c1"></span>                <span class="nx">whichByte</span> <span class="o">:=</span> <span class="nx">sfreeindex</span> <span class="o">/</span> <span class="mi">8</span>
                <span class="nx">s</span><span class="p">.</span><span class="nf">refillAllocCache</span><span class="p">(</span><span class="nx">whichByte</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">s</span><span class="p">.</span><span class="nx">freeindex</span> <span class="p">=</span> <span class="nx">sfreeindex</span>
        <span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>注意：目前跳过了 &ldquo;nextFreeFast&rdquo; 实现，该获取 span 比 &ldquo;nextFree&rdquo; 更快，使用了 <code>mspan.allocCache</code>。</p>
<h4 id="422-mspan-的清理">4.2.2 mspan 的清理</h4>
<p>mspan.sweep() 用于进行一个 mspan 的清理，我们先看下旧版本的实现 mspan.oldSweep()：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Sweep frees or collects finalizers for blocks not marked in the mark phase.
</span><span class="c1">// It clears the mark bits in preparation for the next GC round.
</span><span class="c1">// Returns true if the span was returned to heap.
</span><span class="c1">// If preserve=true, don&#39;t return it to heap nor relink in mcentral lists;
</span><span class="c1">// caller takes care of it.
</span><span class="c1">//
</span><span class="c1">// For !go115NewMCentralImpl.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span><span class="p">)</span> <span class="nf">oldSweep</span><span class="p">(</span><span class="nx">preserve</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="c1">// It&#39;s critical that we enter this function with preemption disabled,
</span><span class="c1"></span>	<span class="c1">// GC must not start while we are in the middle of this function.
</span><span class="c1"></span>	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="o">...</span>

	<span class="nx">spc</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">spanclass</span>
	<span class="nx">size</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="kc">false</span>

	<span class="nx">c</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">mcache</span>
	<span class="nx">freeToHeap</span> <span class="o">:=</span> <span class="kc">false</span>

	<span class="c1">// The allocBits indicate which unmarked objects don&#39;t need to be
</span><span class="c1"></span>	<span class="c1">// processed since they were free at the end of the last GC cycle
</span><span class="c1"></span>	<span class="c1">// and were not allocated since then.
</span><span class="c1"></span>	<span class="c1">// If the allocBits index is &gt;= s.freeindex and the bit
</span><span class="c1"></span>	<span class="c1">// is not marked then the object remains unallocated
</span><span class="c1"></span>	<span class="c1">// since the last GC.
</span><span class="c1"></span>	<span class="c1">// This situation is analogous to being on a freelist.
</span><span class="c1"></span>
	<span class="c1">// Unlink &amp; free special records for any objects we&#39;re about to free.
</span><span class="c1"></span>	<span class="c1">// Two complications here:
</span><span class="c1"></span>	<span class="c1">// 1. An object can have both finalizer and profile special records.
</span><span class="c1"></span>	<span class="c1">//    In such case we need to queue finalizer for execution,
</span><span class="c1"></span>	<span class="c1">//    mark the object as live and preserve the profile special.
</span><span class="c1"></span>	<span class="c1">// 2. A tiny object can have several finalizers setup for different offsets.
</span><span class="c1"></span>	<span class="c1">//    If such object is not marked, we need to queue all finalizers at once.
</span><span class="c1"></span>	<span class="c1">// Both 1 and 2 are possible at the same time.
</span><span class="c1"></span>	<span class="nx">hadSpecials</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">specials</span> <span class="o">!=</span> <span class="kc">nil</span>
	<span class="nx">specialp</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">specials</span>
	<span class="nx">special</span> <span class="o">:=</span> <span class="o">*</span><span class="nx">specialp</span>
	<span class="c1">// 收集 mspan.specials 中对象
</span><span class="c1"></span>
	<span class="o">...</span>

	<span class="c1">// Count the number of free objects in this span.
</span><span class="c1"></span>	<span class="nx">nalloc</span> <span class="o">:=</span> <span class="nb">uint16</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">countAlloc</span><span class="p">())</span>  <span class="c1">// 通过 mspan.gcmarkBits 得到正在使用的 object 数量
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">spc</span><span class="p">.</span><span class="nf">sizeclass</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">nalloc</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">needzero</span> <span class="p">=</span> <span class="mi">1</span>
		<span class="nx">freeToHeap</span> <span class="p">=</span> <span class="kc">true</span>  <span class="c1">// 如果是 large object 并且没有任何使用着对象，那么标记还给 heap
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="nx">nfreed</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span> <span class="o">-</span> <span class="nx">nalloc</span> <span class="c1">// 得到需要回收的 object 数量
</span><span class="c1"></span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span> <span class="p">=</span> <span class="nx">nalloc</span>
	<span class="nx">wasempty</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">nextFreeIndex</span><span class="p">()</span> <span class="o">==</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">freeindex</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// reset allocation index to start of span.
</span><span class="c1"></span>
	<span class="c1">// allocBits 与 gcmarkBits 交换
</span><span class="c1"></span>	<span class="c1">// gcmarkBits becomes the allocBits.
</span><span class="c1"></span>	<span class="c1">// get a fresh cleared gcmarkBits in preparation for next GC
</span><span class="c1"></span>	<span class="nx">s</span><span class="p">.</span><span class="nx">allocBits</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">gcmarkBits</span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">gcmarkBits</span> <span class="p">=</span> <span class="nf">newMarkBits</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span><span class="p">)</span>

	<span class="c1">// Initialize alloc bits cache.
</span><span class="c1"></span>	<span class="nx">s</span><span class="p">.</span><span class="nf">refillAllocCache</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

	<span class="c1">// We need to set s.sweepgen = h.sweepgen only when all blocks are swept,
</span><span class="c1"></span>	<span class="c1">// because of the potential for a concurrent free/SetFinalizer.
</span><span class="c1"></span>	<span class="c1">// But we need to set it before we make the span available for allocation
</span><span class="c1"></span>	<span class="c1">// (return it to heap or mcentral), because allocation code assumes that a
</span><span class="c1"></span>	<span class="c1">// span is already swept if available for allocation.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">freeToHeap</span> <span class="o">||</span> <span class="nx">nfreed</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// Serialization point.
</span><span class="c1"></span>		<span class="c1">// At this point the mark bits are cleared and allocation ready
</span><span class="c1"></span>		<span class="c1">// to go so release the span.
</span><span class="c1"></span>		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">,</span> <span class="nx">sweepgen</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 小对象，通过调用 mcentral.freespan 
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">nfreed</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">spc</span><span class="p">.</span><span class="nf">sizeclass</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">local_nsmallfree</span><span class="p">[</span><span class="nx">spc</span><span class="p">.</span><span class="nf">sizeclass</span><span class="p">()]</span> <span class="o">+=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">nfreed</span><span class="p">)</span>
		<span class="nx">res</span> <span class="p">=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">central</span><span class="p">[</span><span class="nx">spc</span><span class="p">].</span><span class="nx">mcentral</span><span class="p">.</span><span class="nf">freeSpan</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">preserve</span><span class="p">,</span> <span class="nx">wasempty</span><span class="p">)</span>
		<span class="c1">// mcentral.freeSpan updates sweepgen
</span><span class="c1"></span>	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">freeToHeap</span> <span class="p">{</span>
		<span class="c1">// Free large span to heap
</span><span class="c1"></span>
		<span class="c1">// NOTE(rsc,dvyukov): The original implementation of efence
</span><span class="c1"></span>		<span class="c1">// in CL 22060046 used sysFree instead of sysFault, so that
</span><span class="c1"></span>		<span class="c1">// the operating system would eventually give the memory
</span><span class="c1"></span>		<span class="c1">// back to us again, so that an efence program could run
</span><span class="c1"></span>		<span class="c1">// longer without running out of memory. Unfortunately,
</span><span class="c1"></span>		<span class="c1">// calling sysFree here without any kind of adjustment of the
</span><span class="c1"></span>		<span class="c1">// heap data structures means that when the memory does
</span><span class="c1"></span>		<span class="c1">// come back to us, we have the wrong metadata for it, either in
</span><span class="c1"></span>		<span class="c1">// the mspan structures or in the garbage collection bitmap.
</span><span class="c1"></span>		<span class="c1">// Using sysFault here means that the program will run out of
</span><span class="c1"></span>		<span class="c1">// memory fairly quickly in efence mode, but at least it won&#39;t
</span><span class="c1"></span>		<span class="c1">// have mysterious crashes due to confused memory reuse.
</span><span class="c1"></span>		<span class="c1">// It should be possible to switch back to sysFree if we also
</span><span class="c1"></span>		<span class="c1">// implement and then call some kind of mheap.deleteSpan.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">efence</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">limit</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// prevent mlookup from finding this span
</span><span class="c1"></span>			<span class="nf">sysFault</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()),</span> <span class="nx">size</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">mheap_</span><span class="p">.</span><span class="nf">freeSpan</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">local_nlargefree</span><span class="o">++</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">local_largefree</span> <span class="o">+=</span> <span class="nx">size</span>
		<span class="nx">res</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">res</span> <span class="p">{</span>
		<span class="c1">// The span has been swept and is still in-use, so put
</span><span class="c1"></span>		<span class="c1">// it on the swept in-use list.
</span><span class="c1"></span>		<span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepSpans</span><span class="p">[</span><span class="nx">sweepgen</span><span class="o">/</span><span class="mi">2</span><span class="o">%</span><span class="mi">2</span><span class="p">].</span><span class="nf">push</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看到，经过 GC 的 <code>mspan.gcmarkBits</code> 会变为 <code>mspan.allocBits</code>，标识哪些 object 是可以使用的，而没有使用的 object 后面就会被新的覆盖了。
而调用 <code>mcentral.freeSpan()</code> 或者 <code>mheap_.freeSpan()</code> 接口，是为了其结构的调整，或者对于完全空的 mspan 真正回收内存。</p>
<h3 id="43-mcache">4.3 mcache</h3>
<p>每个 P 拥有一个 mcache，mcache 中保存着具有空闲空间的 mspan，用于分配 object 时，不需要加锁即可从 mspan 分配对象。</p>
<p>有两种 object 走 mcache 分配：</p>
<ul>
<li><strong><code>tiny object</code></strong>：mcache 还单独使用一个 mspan 进行<strong>非指针微小对象</strong>的分配。与普通 object 对象分配不同的是，tiny object 不是固定大小分配的，而是通过 mcache 记录其 offset 偏移量，让 tiny object &ldquo;挤在&rdquo; 同一个 mspan 中。</li>
<li><strong><code>normal object</code></strong>：普通大小的 object，会使用 <code>mcache.alloc</code> 进行分配。<code>mcache.alloc</code> 包含 134 个数组项（67 sizeclass * 2），对于每个大小规格的 mspan 有着两个类型：
<ul>
<li><strong>scan</strong>：包含指针的对象</li>
<li><strong>noscan</strong>：不包含指针的对象，GC 时无需进一步扫描是否引用着其他活跃对象</li>
</ul>
</li>
</ul>
<p>mcache &ldquo;永远&rdquo; 有空闲的 mspan 用于 object 的分配，当 mcache 缓存的 mspan 没有空闲空间时，就会<strong>找 mcentral 去申请新的 mspan 用于使用</strong>。








    <br><img src="/posts/language/golang/language/memory-manager/img4.png"/>


</p>
<p>数据结构如下（runtime/mcache.go）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Per-thread (in Go, per-P) cache for small objects.
</span><span class="c1">// No locking needed because it is per-thread (per-P).
</span><span class="c1">//
</span><span class="c1">// mcaches are allocated from non-GC&#39;d memory, so any heap pointers
</span><span class="c1">// must be specially handled.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">mcache</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="c1">// Allocator cache for tiny objects w/o pointers.
</span><span class="c1"></span>        <span class="c1">// See &#34;Tiny allocator&#34; comment in malloc.go.
</span><span class="c1"></span>
        <span class="c1">// tiny points to the beginning of the current tiny block, or
</span><span class="c1"></span>        <span class="c1">// nil if there is no current tiny block.
</span><span class="c1"></span>        <span class="c1">//
</span><span class="c1"></span>        <span class="c1">// tiny is a heap pointer. Since mcache is in non-GC&#39;d memory,
</span><span class="c1"></span>        <span class="c1">// we handle it by clearing it in releaseAll during mark
</span><span class="c1"></span>        <span class="c1">// termination.
</span><span class="c1"></span>        <span class="nx">tiny</span>             <span class="kt">uintptr</span>
        <span class="nx">tinyoffset</span>       <span class="kt">uintptr</span>
        <span class="nx">local_tinyallocs</span> <span class="kt">uintptr</span> <span class="c1">// number of tiny allocs not counted in other stats
</span><span class="c1"></span>
        <span class="c1">// The rest is not accessed on every malloc.
</span><span class="c1"></span>
        <span class="nx">alloc</span> <span class="p">[</span><span class="nx">numSpanClasses</span><span class="p">]</span><span class="o">*</span><span class="nx">mspan</span> <span class="c1">// spans to allocate from, indexed by spanClass
</span><span class="c1"></span>
        <span class="nx">stackcache</span> <span class="p">[</span><span class="nx">_NumStackOrders</span><span class="p">]</span><span class="nx">stackfreelist</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li><strong><code>tiny</code></strong> <strong><code>tinyoffset</code></strong> ：用于小对象（&lt;16）的分配。tiny 指向当前为 tiny object 准备的 span 的起始地址，tinyoffset 指向对象使用的偏移地址；</li>
<li><strong><code>alloc</code></strong> ：最重要的属性，保存着不同大小的 mspan 各一个。目前，包含固定 64 类 sizeclass：0、8 … 32768；</li>
</ul>
<h4 id="431-mspan-的分配">4.3.1 mspan 的分配</h4>
<p>先看下 tiny object 分配，在分配一个 object 时，如果大小小于 16 字节时，就会走 tiny object 逻辑。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">size</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">typ</span> <span class="o">*</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">needzero</span> <span class="kt">bool</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">size</span> <span class="o">&lt;=</span> <span class="nx">maxSmallSize</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">noscan</span> <span class="o">&amp;&amp;</span> <span class="nx">size</span> <span class="p">&lt;</span> <span class="nx">maxTinySize</span> <span class="p">{</span>
			<span class="nx">off</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">tinyoffset</span>
			<span class="c1">// Align tiny pointer for required (conservative) alignment.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">size</span><span class="o">&amp;</span><span class="mi">7</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">off</span> <span class="p">=</span> <span class="nf">alignUp</span><span class="p">(</span><span class="nx">off</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">size</span><span class="o">&amp;</span><span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">off</span> <span class="p">=</span> <span class="nf">alignUp</span><span class="p">(</span><span class="nx">off</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">size</span><span class="o">&amp;</span><span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">off</span> <span class="p">=</span> <span class="nf">alignUp</span><span class="p">(</span><span class="nx">off</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">off</span><span class="o">+</span><span class="nx">size</span> <span class="o">&lt;=</span> <span class="nx">maxTinySize</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">tiny</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="c1">// The object fits into existing tiny block.
</span><span class="c1"></span>				<span class="nx">x</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">tiny</span> <span class="o">+</span> <span class="nx">off</span><span class="p">)</span>
				<span class="nx">c</span><span class="p">.</span><span class="nx">tinyoffset</span> <span class="p">=</span> <span class="nx">off</span> <span class="o">+</span> <span class="nx">size</span>
				<span class="nx">c</span><span class="p">.</span><span class="nx">local_tinyallocs</span><span class="o">++</span>
				<span class="nx">mp</span><span class="p">.</span><span class="nx">mallocing</span> <span class="p">=</span> <span class="mi">0</span>
				<span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
				<span class="k">return</span> <span class="nx">x</span>
			<span class="p">}</span>
			<span class="c1">// Allocate a new maxTinySize block.
</span><span class="c1"></span>			<span class="nx">span</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">alloc</span><span class="p">[</span><span class="nx">tinySpanClass</span><span class="p">]</span>
			<span class="nx">v</span> <span class="o">:=</span> <span class="nf">nextFreeFast</span><span class="p">(</span><span class="nx">span</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">v</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">v</span><span class="p">,</span> <span class="nx">span</span><span class="p">,</span> <span class="nx">shouldhelpgc</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">nextFree</span><span class="p">(</span><span class="nx">tinySpanClass</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">x</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
			<span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kt">uint64</span><span class="p">)(</span><span class="nx">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kt">uint64</span><span class="p">)(</span><span class="nx">x</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="c1">// See if we need to replace the existing tiny block with the new one
</span><span class="c1"></span>			<span class="c1">// based on amount of remaining free space.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">size</span> <span class="p">&lt;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">tinyoffset</span> <span class="o">||</span> <span class="nx">c</span><span class="p">.</span><span class="nx">tiny</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">c</span><span class="p">.</span><span class="nx">tiny</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
				<span class="nx">c</span><span class="p">.</span><span class="nx">tinyoffset</span> <span class="p">=</span> <span class="nx">size</span>
			<span class="p">}</span>
			<span class="nx">size</span> <span class="p">=</span> <span class="nx">maxTinySize</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="o">...</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">...</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>如果当前 <strong>tinyoffset+size &lt; 16B</strong>（因为每个 tiny span 的大小为 32B，而每个 tiny object 最大为 16，所以比较 16 即可），那么表明<strong>当前的 tiny span 肯定可以放下</strong>，那么移动 <code>c.tinyoffset</code> 偏移即可；</li>
<li>如果没有，那么就需要<strong>重新申请</strong> tinySpanClass=5 的 span（32B），并替换当前 <code>c.tiny</code> 与 <code>c.tinyoffset</code>（当前 object 可以放在老的 span 或者新的 span）。</li>
</ol>
<p>接着看下普通大小的 object 的分配，在外层函数计算好 spanClass 后，就会调用 <strong><code>nextFree()</code></strong> 函数（runtime/malloc.go）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// nextFree returns the next free object from the cached span if one is available.
</span><span class="c1">// Otherwise it refills the cache with a span with an available object and
</span><span class="c1">// returns that object along with a flag indicating that this was a heavy
</span><span class="c1">// weight allocation. If it is a heavy weight allocation the caller must
</span><span class="c1">// determine whether a new GC cycle needs to be started or if the GC is active
</span><span class="c1">// whether this goroutine needs to assist the GC.
</span><span class="c1">//
</span><span class="c1">// Must run in a non-preemptible context since otherwise the owner of
</span><span class="c1">// c could change.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">mcache</span><span class="p">)</span> <span class="nf">nextFree</span><span class="p">(</span><span class="nx">spc</span> <span class="nx">spanClass</span><span class="p">)</span> <span class="p">(</span><span class="nx">v</span> <span class="nx">gclinkptr</span><span class="p">,</span> <span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span><span class="p">,</span> <span class="nx">shouldhelpgc</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">s</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">alloc</span><span class="p">[</span><span class="nx">spc</span><span class="p">]</span>
        <span class="nx">shouldhelpgc</span> <span class="p">=</span> <span class="kc">false</span>
        <span class="nx">freeIndex</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">nextFreeIndex</span><span class="p">()</span>
        <span class="k">if</span> <span class="nx">freeIndex</span> <span class="o">==</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
                <span class="c1">// The span is full.
</span><span class="c1"></span>                <span class="k">if</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
                        <span class="nb">println</span><span class="p">(</span><span class="s">&#34;runtime: s.allocCount=&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="p">,</span> <span class="s">&#34;s.nelems=&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span><span class="p">)</span>
                        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;s.allocCount != s.nelems &amp;&amp; freeIndex == s.nelems&#34;</span><span class="p">)</span>
                <span class="p">}</span>
                <span class="nx">c</span><span class="p">.</span><span class="nf">refill</span><span class="p">(</span><span class="nx">spc</span><span class="p">)</span>
                <span class="nx">shouldhelpgc</span> <span class="p">=</span> <span class="kc">true</span>
                <span class="nx">s</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">alloc</span><span class="p">[</span><span class="nx">spc</span><span class="p">]</span>

        <span class="nx">freeIndex</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">nextFreeIndex</span><span class="p">()</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="nx">freeIndex</span> <span class="o">&gt;=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
                <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;freeIndex is not valid&#34;</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="nx">v</span> <span class="p">=</span> <span class="nf">gclinkptr</span><span class="p">(</span><span class="nx">freeIndex</span><span class="o">*</span><span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span> <span class="o">+</span> <span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">())</span>
        <span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="o">++</span>
        <span class="k">if</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
                <span class="nb">println</span><span class="p">(</span><span class="s">&#34;s.allocCount=&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="p">,</span> <span class="s">&#34;s.nelems=&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span><span class="p">)</span>
                <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;s.allocCount &gt; s.nelems&#34;</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">return</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>得到 <code>c.alloc</code> 对应大小的 mspan；</li>
<li>如果 mspan 没有空闲空间了（freeIndex == s.nelems），那么走 <code>c.refill()</code> <strong>重新向 mcentral 申请一个 有空闲空间 mspan</strong>；</li>
<li><code>mspan.nextFreeIndex()</code> 下一个 index，并计算出对应的内存地址返回；</li>
</ol>
<h4 id="432-mspan-的获取">4.3.2 mspan 的获取</h4>
<p>前面分配 object 中可以看到，当 mcache 当前大小的 mspan 没有空闲空间后，就会通过 <strong><code>c.refill()</code></strong> <strong>向 mcentral 重新申请一个 mspan</strong>（runtime/mcache.go）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// refill acquires a new span of span class spc for c. This span will
</span><span class="c1">// have at least one free object. The current span in c must be full.
</span><span class="c1">//
</span><span class="c1">// Must run in a non-preemptible context since otherwise the owner of
</span><span class="c1">// c could change.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">mcache</span><span class="p">)</span> <span class="nf">refill</span><span class="p">(</span><span class="nx">spc</span> <span class="nx">spanClass</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Return the current cached span to the central lists.
</span><span class="c1"></span>	<span class="nx">s</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">alloc</span><span class="p">[</span><span class="nx">spc</span><span class="p">]</span>

	<span class="k">if</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;refill of span with free space remaining&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">s</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="nx">emptymspan</span> <span class="p">{</span>
		<span class="c1">// Mark this span as no longer cached.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">!=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepgen</span><span class="o">+</span><span class="mi">3</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad sweepgen in refill&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">go115NewMCentralImpl</span> <span class="p">{</span>
			<span class="nx">mheap_</span><span class="p">.</span><span class="nx">central</span><span class="p">[</span><span class="nx">spc</span><span class="p">].</span><span class="nx">mcentral</span><span class="p">.</span><span class="nf">uncacheSpan</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">,</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Get a new cached span from the central lists.
</span><span class="c1"></span>	<span class="nx">s</span> <span class="p">=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">central</span><span class="p">[</span><span class="nx">spc</span><span class="p">].</span><span class="nx">mcentral</span><span class="p">.</span><span class="nf">cacheSpan</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;out of memory&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="p">)</span> <span class="o">==</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;span has no free space&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Indicate that this span is cached and prevent asynchronous
</span><span class="c1"></span>	<span class="c1">// sweeping in the next sweep phase.
</span><span class="c1"></span>	<span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="p">=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">+</span> <span class="mi">3</span>

	<span class="nx">c</span><span class="p">.</span><span class="nx">alloc</span><span class="p">[</span><span class="nx">spc</span><span class="p">]</span> <span class="p">=</span> <span class="nx">s</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>标记当前 mspan 不会在被缓存（猜想，垃圾回收后会改变这个标志位），go 1.15 后的会将 mspan 从 mcache 还给 mcentral；</li>
<li>通过 mheap <strong>对应大小的 mcentral 获取一个空闲的 mspan</strong>，并置位 <code>mspan.sweepgen</code>（表明被 mcache 使用）；</li>
<li>将 <code>c.alloc</code> 对应大小的 mspan 赋值为刚获取到的；</li>
</ol>
<p>可以看到，通过 refill 动态的申请 mspan，mcache 不同大小的 mspan 在 <strong>申请-&gt;使用-&gt;替换</strong> 中不断的循环，而 cache 一直能保存着有着空闲空间的 mspan 供 P 使用。</p>
<h3 id="44-mcentral">4.4 mcentral</h3>
<p><strong><code>mcentral</code></strong> 是内存分配器的中心缓存，<strong>用于给 mcache 提供空闲的 mspan</strong>。因为不是 P 对应的，所以访问也需要锁。</p>
<p>mheap 会创建 64 个 sizeClass 的 mcentral，每个 mcentral 管理相同大小的所有 mspan，以两个链表结构管理：</p>
<ul>
<li><strong><code>nonempty</code></strong> ：包含空闲空间的 mspan 组成的链表；</li>
<li><strong><code>empty</code></strong> ：不包含空闲空间，或者被 mcache 申请的 mspan 组成的链表（判断是否被 mcache 使用是通过 mspan.sweepgen 属性来判断）；</li>
</ul>
<p>当 mcache 要申请某大小的 mspan 时，会回去指定大小的 mcentral 实例上申请。








    <br><img src="/posts/language/golang/language/memory-manager/img5.png"/>


</p>
<p>数据结构如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Central list of free objects of a given size.
</span><span class="c1">//
</span><span class="c1">//go:notinheap
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">mcentral</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">lock</span>      <span class="nx">mutex</span>
	<span class="nx">spanclass</span> <span class="nx">spanClass</span>

	<span class="c1">// For !go115NewMCentralImpl.
</span><span class="c1"></span>	<span class="nx">nonempty</span> <span class="nx">mSpanList</span> <span class="c1">// list of spans with a free object, ie a nonempty free list
</span><span class="c1"></span>	<span class="nx">empty</span>    <span class="nx">mSpanList</span> <span class="c1">// list of spans with no free objects (or cached in an mcache)
</span><span class="c1"></span>
	<span class="err">…</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li><code>lock</code> ：访问需要加的锁；</li>
<li><code>spanclass</code> ：当前 mcentral 管理的 mspan 大小；</li>
<li><code>nonempty</code> ：包含空闲空间的 mspan 链表；</li>
<li><code>empty</code> ：不包含空闲空间，或者被 mcache 申请了的 mspan 链表；</li>
</ul>
<div class="details admonition note open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-pencil-alt fa-fw" aria-hidden="true"></i>Note<i class="details-icon fas fa-angle-right fa-fw" aria-hidden="true"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><p>源码中存在 go115NewMCentralImpl 的注释，对 mcentral 结构做了很大的改动，但是在 go1.15 release 页面上并没有看到对应的说明。</p>
<p>其 commit 见：<a href="https://github.com/golang/go/commit/a13691966ad571ed9e434d591a2d612c51349fd1" target="_blank" rel="noopener noreffer">runtime: add new mcentral implementation</a></p>
</div>
        </div>
    </div>
<h4 id="441-从-mcentral-申请-mspan">4.4.1 从 mcentral 申请 mspan</h4>
<p>在 <a href="#432-mspan-%e7%9a%84%e8%8e%b7%e5%8f%96" rel=""><strong>mcache 的获取</strong></a> 中，可以看到 mcache 通过调用 <code>mcentral.cacheSpan()</code> 申请新的空闲 mspan。在 go1.15 中，因为有新版 mcentral 的实现，因此双链表方式移动到了 <code>mcentral.oldCacheSpan()</code> 方法中。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Allocate a span to use in an mcache.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">mcentral</span><span class="p">)</span> <span class="nf">cacheSpan</span><span class="p">()</span> <span class="o">*</span><span class="nx">mspan</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">go115NewMCentralImpl</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nf">oldCacheSpan</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="err">…</span>
<span class="p">}</span>

<span class="c1">// Allocate a span to use in an mcache.
</span><span class="c1">//
</span><span class="c1">// For !go115NewMCentralImpl.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">mcentral</span><span class="p">)</span> <span class="nf">oldCacheSpan</span><span class="p">()</span> <span class="o">*</span><span class="nx">mspan</span> <span class="p">{</span>
	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="nx">sg</span> <span class="o">:=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepgen</span>
        
<span class="nx">retry</span><span class="p">:</span>
	<span class="kd">var</span> <span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span>
	<span class="c1">// 走 nonempty 链表找
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">s</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">nonempty</span><span class="p">.</span><span class="nx">first</span><span class="p">;</span> <span class="nx">s</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">s</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">next</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">==</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">,</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">nonempty</span><span class="p">.</span><span class="nf">remove</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">empty</span><span class="p">.</span><span class="nf">insertBack</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
			<span class="nx">s</span><span class="p">.</span><span class="nf">sweep</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
			<span class="k">goto</span> <span class="nx">havespan</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">==</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
			<span class="c1">// the span is being swept by background sweeper, skip
</span><span class="c1"></span>			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="c1">// we have a nonempty span that does not require sweeping, allocate from it
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nx">nonempty</span><span class="p">.</span><span class="nf">remove</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">empty</span><span class="p">.</span><span class="nf">insertBack</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">goto</span> <span class="nx">havespan</span>
	<span class="p">}</span>

	<span class="c1">// 走 empty 链表找
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">s</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">empty</span><span class="p">.</span><span class="nx">first</span><span class="p">;</span> <span class="nx">s</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">s</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">next</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">==</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">,</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// we have an empty span that requires sweeping,
</span><span class="c1"></span>			<span class="c1">// sweep it and see if we can free some space in it
</span><span class="c1"></span>			<span class="nx">c</span><span class="p">.</span><span class="nx">empty</span><span class="p">.</span><span class="nf">remove</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
			<span class="c1">// swept spans are at the end of the list
</span><span class="c1"></span>			<span class="nx">c</span><span class="p">.</span><span class="nx">empty</span><span class="p">.</span><span class="nf">insertBack</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
			<span class="nx">s</span><span class="p">.</span><span class="nf">sweep</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
			<span class="nx">freeIndex</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">nextFreeIndex</span><span class="p">()</span>
			<span class="k">if</span> <span class="nx">freeIndex</span> <span class="o">!=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
				<span class="nx">s</span><span class="p">.</span><span class="nx">freeindex</span> <span class="p">=</span> <span class="nx">freeIndex</span>
				<span class="k">goto</span> <span class="nx">havespan</span>
			<span class="p">}</span>
			<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
			<span class="c1">// the span is still empty after sweep
</span><span class="c1"></span>			<span class="c1">// it is already in the empty list, so just retry
</span><span class="c1"></span>			<span class="k">goto</span> <span class="nx">retry</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">==</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
			 <span class="c1">// the span is being swept by background sweeper, skip
</span><span class="c1"></span>			 <span class="k">continue</span>
		<span class="p">}</span>
		<span class="c1">// already swept empty span,
</span><span class="c1"></span>		<span class="c1">// all subsequent ones must also be either swept or in process of sweeping
</span><span class="c1"></span>		<span class="k">break</span>
	<span class="p">}</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

	<span class="c1">// 向 heap 申请新的 mspan
</span><span class="c1"></span>	<span class="c1">// Replenish central list if empty.
</span><span class="c1"></span>	<span class="nx">s</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">grow</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">empty</span><span class="p">.</span><span class="nf">insertBack</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

	<span class="c1">// At this point s is a non-empty span, queued at the end of the empty list,
</span><span class="c1"></span>	<span class="c1">// c is unlocked.
</span><span class="c1"></span><span class="nx">havespan</span><span class="p">:</span>
	<span class="err">…</span>
	<span class="nx">freeByteBase</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">freeindex</span> <span class="o">&amp;^</span> <span class="p">(</span><span class="mi">64</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
	<span class="nx">whichByte</span> <span class="o">:=</span> <span class="nx">freeByteBase</span> <span class="o">/</span> <span class="mi">8</span>
	<span class="c1">// Init alloc bits cache.
</span><span class="c1"></span>	<span class="nx">s</span><span class="p">.</span><span class="nf">refillAllocCache</span><span class="p">(</span><span class="nx">whichByte</span><span class="p">)</span>

	<span class="c1">// Adjust the allocCache so that s.freeindex corresponds to the low bit in
</span><span class="c1"></span>	<span class="c1">// s.allocCache.
</span><span class="c1"></span>	<span class="nx">s</span><span class="p">.</span><span class="nx">allocCache</span> <span class="o">&gt;&gt;=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">freeindex</span> <span class="o">%</span> <span class="mi">64</span>

	<span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上面逻辑可以大致分为几个步骤：</p>
<ol>
<li>遍历 nonempty 链表，找到可用的 mspan（对于需要 sweep 的 mspan 先进行 sweep）；</li>
<li>没找到，遍历 empty 链表，仅仅遍历需要 sweep 的 mspan，执行 sweep 并判断是否可用；</li>
<li>还是没有，通过 <code>mcentral.grow()</code> 向 mheap 申请新的 mspan，mheap 中都没有，return nil；</li>
<li>找到空闲 mspan 后，会放置到 empty 链表尾部，并返回；</li>
</ol>
<h4 id="442-mcentral-扩容">4.4.2 mcentral 扩容</h4>
<p>在 mcentral 没有任何空闲 mspan 给 mcache 时，就会调用 <code>mcentral.grow()</code> 申请新的 mspan。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// grow allocates a new empty span from the heap and initializes it for c&#39;s size class.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">mcentral</span><span class="p">)</span> <span class="nf">grow</span><span class="p">()</span> <span class="o">*</span><span class="nx">mspan</span> <span class="p">{</span>
	 <span class="nx">npages</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">class_to_allocnpages</span><span class="p">[</span><span class="nx">c</span><span class="p">.</span><span class="nx">spanclass</span><span class="p">.</span><span class="nf">sizeclass</span><span class="p">()])</span>
	 <span class="nx">size</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">class_to_size</span><span class="p">[</span><span class="nx">c</span><span class="p">.</span><span class="nx">spanclass</span><span class="p">.</span><span class="nf">sizeclass</span><span class="p">()])</span>

	 <span class="nx">s</span> <span class="o">:=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nf">alloc</span><span class="p">(</span><span class="nx">npages</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">spanclass</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
	 <span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		 <span class="k">return</span> <span class="kc">nil</span>
	 <span class="p">}</span>

	 <span class="c1">// Use division by multiplication and shifts to quickly compute:
</span><span class="c1"></span>	 <span class="c1">// n := (npages &lt;&lt; _PageShift) / size
</span><span class="c1"></span>	 <span class="nx">n</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">npages</span> <span class="o">&lt;&lt;</span> <span class="nx">_PageShift</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">divShift</span> <span class="o">*</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">divMul</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">divShift2</span>
	 <span class="nx">s</span><span class="p">.</span><span class="nx">limit</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()</span> <span class="o">+</span> <span class="nx">size</span><span class="o">*</span><span class="nx">n</span>
	 <span class="nf">heapBitsForAddr</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()).</span><span class="nf">initSpan</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	 <span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>通过 <code>mheap.alloc()</code> 申请一个指大小的 mspan；</li>
<li>执行 <code>mheapBit.initSpan()</code> 初始化 mspan；</li>
</ol>
<h4 id="443-mcentral-回收-mspan">4.4.3 mcentral 回收 mspan</h4>
<p>前面 <a href="#422-mspan-%e7%9a%84%e6%b8%85%e7%90%86" rel=""><strong>mspan.sweep()</strong></a>时看到，通过调用 mcentral.freeSpan() 调整其 mspan:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// freeSpan updates c and s after sweeping s.
</span><span class="c1">// It sets s&#39;s sweepgen to the latest generation,
</span><span class="c1">// and, based on the number of free objects in s,
</span><span class="c1">// moves s to the appropriate list of c or returns it
</span><span class="c1">// to the heap.
</span><span class="c1">// freeSpan reports whether s was returned to the heap.
</span><span class="c1">// If preserve=true, it does not move s (the caller
</span><span class="c1">// must take care of it).
</span><span class="c1">//
</span><span class="c1">// For !go115NewMCentralImpl.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">mcentral</span><span class="p">)</span> <span class="nf">freeSpan</span><span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span><span class="p">,</span> <span class="nx">preserve</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">wasempty</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">needzero</span> <span class="p">=</span> <span class="mi">1</span>

	<span class="k">if</span> <span class="nx">preserve</span> <span class="p">{</span>
		<span class="c1">// preserve is set only when called from (un)cacheSpan above,
</span><span class="c1"></span>		<span class="c1">// the span must be in the empty list.
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">!</span><span class="nx">s</span><span class="p">.</span><span class="nf">inList</span><span class="p">()</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;can&#39;t preserve unlinked span&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">,</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

	<span class="c1">// 如果 mspan 完全空，调整链表项
</span><span class="c1"></span>	<span class="c1">// Move to nonempty if necessary.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">wasempty</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">empty</span><span class="p">.</span><span class="nf">remove</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">nonempty</span><span class="p">.</span><span class="nf">insert</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// delay updating sweepgen until here. This is the signal that
</span><span class="c1"></span>	<span class="c1">// the span may be used in an mcache, so it must come after the
</span><span class="c1"></span>	<span class="c1">// linked list operations above (actually, just after the
</span><span class="c1"></span>	<span class="c1">// lock of c above.)
</span><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">,</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">)</span>

	<span class="c1">// 还有 object 正在使用，返回
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="c1">// 没有 object 了，也就是空的 mspan 尝试返回给 mheap
</span><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nx">nonempty</span><span class="p">.</span><span class="nf">remove</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="nx">mheap_</span><span class="p">.</span><span class="nf">freeSpan</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>所谓的回收 mspan 仅仅对于 mspan 完全空闲情况下，调用 mheap.freeSpan() 尝试回收。非空的 mspan 其实没有啥操作。</p>
<h3 id="45-mheap">4.5 mheap</h3>
<p>mheap 是最核心的组件了，runtime 只存在一个 mheap 对象，分配、初始化 mspan 都从 mheap 开始。</p>
<p>mheap 直接与虚拟内存打交道，并将在虚拟内存上创建 mspan 提供给上层使用。</p>
<p>mheap 的功能可以看做两个方面：</p>
<ol>
<li>与下层（虚拟内存）：<strong>内存管理</strong>（类似文件系统）。申请虚拟内存得到多个 heaparena，每个 heaparena 将可用内存区域切分为 page 单元，以倍数组成 mspan 分配给上层；</li>
<li>与上层：<strong>提供创建 mspan 的接口</strong>。通过 mcentral 分类不同大小的 mspan，或者大内存需要直接走 mspan 分配；</li>
</ol>
<p>其数据结构很大，省略了部分不会提到的属性（runtime/mheap.go），<strong><code>mheap_</code></strong> 就是 heap 的单实例对象：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">mheap_</span> <span class="nx">mheap</span>

<span class="c1">// Main malloc heap.
</span><span class="c1">// The heap itself is the &#34;free&#34; and &#34;scav&#34; treaps,
</span><span class="c1">// but all the other global data is here too.
</span><span class="c1">//
</span><span class="c1">// mheap must not be heap-allocated because it contains mSpanLists,
</span><span class="c1">// which must not be heap-allocated.
</span><span class="c1">//
</span><span class="c1">//go:notinheap
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">mheap</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// arenas is the heap arena map. It points to the metadata for
</span><span class="c1"></span>	<span class="c1">// the heap for every arena frame of the entire usable virtual
</span><span class="c1"></span>	<span class="c1">// address space.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Use arenaIndex to compute indexes into this array.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For regions of the address space that are not backed by the
</span><span class="c1"></span>	<span class="c1">// Go heap, the arena map contains nil.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Modifications are protected by mheap_.lock. Reads can be
</span><span class="c1"></span>	<span class="c1">// performed without locking; however, a given entry can
</span><span class="c1"></span>	<span class="c1">// transition from nil to non-nil at any time when the lock
</span><span class="c1"></span>	<span class="c1">// isn&#39;t held. (Entries never transitions back to nil.)
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// In general, this is a two-level mapping consisting of an L1
</span><span class="c1"></span>	<span class="c1">// map and possibly many L2 maps. This saves space when there
</span><span class="c1"></span>	<span class="c1">// are a huge number of arena frames. However, on many
</span><span class="c1"></span>	<span class="c1">// platforms (even 64-bit), arenaL1Bits is 0, making this
</span><span class="c1"></span>	<span class="c1">// effectively a single-level map. In this case, arenas[0]
</span><span class="c1"></span>	<span class="c1">// will never be nil.
</span><span class="c1"></span>	<span class="nx">arenas</span> <span class="p">[</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">arenaL1Bits</span><span class="p">]</span><span class="o">*</span><span class="p">[</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">arenaL2Bits</span><span class="p">]</span><span class="o">*</span><span class="nx">heapArena</span>
			
	<span class="c1">// central free lists for small size classes.
</span><span class="c1"></span>	<span class="c1">// the padding makes sure that the mcentrals are
</span><span class="c1"></span>	<span class="c1">// spaced CacheLinePadSize bytes apart, so that each mcentral.lock
</span><span class="c1"></span>	<span class="c1">// gets its own cache line.
</span><span class="c1"></span>	<span class="c1">// central is indexed by spanClass.
</span><span class="c1"></span>	<span class="nx">central</span> <span class="p">[</span><span class="nx">numSpanClasses</span><span class="p">]</span><span class="kd">struct</span> <span class="p">{</span>
			<span class="nx">mcentral</span> <span class="nx">mcentral</span>
			<span class="nx">pad</span>      <span class="p">[</span><span class="nx">cpu</span><span class="p">.</span><span class="nx">CacheLinePadSize</span> <span class="o">-</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">mcentral</span><span class="p">{})</span><span class="o">%</span><span class="nx">cpu</span><span class="p">.</span><span class="nx">CacheLinePadSize</span><span class="p">]</span><span class="kt">byte</span>
	<span class="p">}</span>
			
	<span class="nx">pages</span>     <span class="nx">pageAlloc</span> <span class="c1">// page allocation data structure
</span><span class="c1"></span>			
	<span class="nx">spanalloc</span>             <span class="nx">fixalloc</span> <span class="c1">// allocator for span*
</span><span class="c1"></span>	<span class="nx">cachealloc</span>            <span class="nx">fixalloc</span> <span class="c1">// allocator for mcache*
</span><span class="c1"></span>	<span class="nx">specialfinalizeralloc</span> <span class="nx">fixalloc</span> <span class="c1">// allocator for specialfinalizer*
</span><span class="c1"></span>	<span class="nx">specialprofilealloc</span>   <span class="nx">fixalloc</span> <span class="c1">// allocator for specialprofile*
</span><span class="c1"></span>	<span class="nx">speciallock</span>           <span class="nx">mutex</span>    <span class="c1">// lock for special record allocators.
</span><span class="c1"></span>	<span class="nx">arenaHintAlloc</span>        <span class="nx">fixalloc</span> <span class="c1">// allocator for arenaHints
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li><strong><code>arenas</code></strong> ：内存管理的元信息数组，对于虚拟内存的逻辑切割与管理就靠这个数组了；</li>
<li><strong><code>central</code></strong>  ：按照大小分类的各个 mcentral 对象；</li>
<li><code>pages</code> ：在 arena 区域上用于分配空闲的 pages，依旧使用空闲链表；</li>
<li><code>spanalloc</code>、<code>cachealloc</code> 等 ：各个数据结构的空闲链表分配器，通过连接空闲的 mspan、mcache 等对象，调用 fixalloc.alloc() 函数就获取下一个空闲的内存空间；</li>
</ul>
<h4 id="451-虚拟内存布局">4.5.1 虚拟内存布局</h4>
<p>网上大部分文章还是说 mheap 管理的虚拟内存以 spans+bitmap+arena 管理，如下图：








    <br><img src="/posts/language/golang/language/memory-manager/img6.png"/>


</p>
<p>但是从 go 1.11 开始，Go 开始使稀疏内存方式管理，即管理相互之间不连续的连续的内存区域，如下图（<strong>图片来自 《Golang 设计与实现》</strong>）：








    <br><img src="/posts/language/golang/language/memory-manager/img7.png"/>


</p>
<p>使用的就是 <code>mheap.arenas</code>，一个二维的 heapArena 数组。</p>
<p>不同平台的 heapArena 管理的 arena 大小不同，在 Linux 64bit 平台下，每个 heapArena 管理着 64MB 的 arena 内存区域。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Currently, we balance these as follows:
</span><span class="c1">//
</span><span class="c1">//       Platform  Addr bits  Arena size  L1 entries   L2 entries
</span><span class="c1">// --------------  ---------  ----------  ----------  -----------
</span><span class="c1">//       */64-bit         48        64MB           1    4M (32MB)
</span><span class="c1">// windows/64-bit         48         4MB          64    1M  (8MB)
</span><span class="c1">//       */32-bit         32         4MB           1  1024  (4KB)
</span><span class="c1">//     */mips(le)         31         4MB           1   512  (2KB)
</span></code></pre></td></tr></table>
</div>
</div><div class="details admonition note open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-pencil-alt fa-fw" aria-hidden="true"></i>Note<i class="details-icon fas fa-angle-right fa-fw" aria-hidden="true"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><p>这里不太好理解，但是我觉可以简单理解就是，将原来的 spans+bitmap+arena 管理方式，变为了<strong>多个 spans+bitmap+arena 实现</strong>。而不同 arena 之间的地址不是连续的。</p>
<p>但是为什么要用二维数组？目前不知道，但是 Linux x86-64 架构上一维数组大小为 1，就是相当于 1 维数组。</p>
</div>
        </div>
    </div>
<p><strong><code>heapArena</code></strong> 数据结构如下（runtime/mheap.go）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// A heapArena stores metadata for a heap arena. heapArenas are stored
</span><span class="c1">// outside of the Go heap and accessed via the mheap_.arenas index.
</span><span class="c1">//
</span><span class="c1">//go:notinheap
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">heapArena</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// bitmap stores the pointer/scalar bitmap for the words in
</span><span class="c1"></span>	<span class="c1">// this arena. See mbitmap.go for a description. Use the
</span><span class="c1"></span>	<span class="c1">// heapBits type to access this.
</span><span class="c1"></span>	<span class="nx">bitmap</span> <span class="p">[</span><span class="nx">heapArenaBitmapBytes</span><span class="p">]</span><span class="kt">byte</span>

	<span class="c1">// spans maps from virtual address page ID within this arena to *mspan.
</span><span class="c1"></span>	<span class="c1">// For allocated spans, their pages map to the span itself.
</span><span class="c1"></span>	<span class="c1">// For free spans, only the lowest and highest pages map to the span itself.
</span><span class="c1"></span>	<span class="c1">// Internal pages map to an arbitrary span.
</span><span class="c1"></span>	<span class="c1">// For pages that have never been allocated, spans entries are nil.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Modifications are protected by mheap.lock. Reads can be
</span><span class="c1"></span>	<span class="c1">// performed without locking, but ONLY from indexes that are
</span><span class="c1"></span>	<span class="c1">// known to contain in-use or stack spans. This means there
</span><span class="c1"></span>	<span class="c1">// must not be a safe-point between establishing that an
</span><span class="c1"></span>	<span class="c1">// address is live and looking it up in the spans array.
</span><span class="c1"></span>	<span class="nx">spans</span> <span class="p">[</span><span class="nx">pagesPerArena</span><span class="p">]</span><span class="o">*</span><span class="nx">mspan</span>

	<span class="c1">// pageInUse is a bitmap that indicates which spans are in
</span><span class="c1"></span>	<span class="c1">// state mSpanInUse. This bitmap is indexed by page number,
</span><span class="c1"></span>	<span class="c1">// but only the bit corresponding to the first page in each
</span><span class="c1"></span>	<span class="c1">// span is used.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Reads and writes are atomic.
</span><span class="c1"></span>	<span class="nx">pageInUse</span> <span class="p">[</span><span class="nx">pagesPerArena</span> <span class="o">/</span> <span class="mi">8</span><span class="p">]</span><span class="kt">uint8</span>

	<span class="c1">// pageMarks is a bitmap that indicates which spans have any
</span><span class="c1"></span>	<span class="c1">// marked objects on them. Like pageInUse, only the bit
</span><span class="c1"></span>	<span class="c1">// corresponding to the first page in each span is used.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Writes are done atomically during marking. Reads are
</span><span class="c1"></span>	<span class="c1">// non-atomic and lock-free since they only occur during
</span><span class="c1"></span>	<span class="c1">// sweeping (and hence never race with writes).
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// This is used to quickly find whole spans that can be freed.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// TODO(austin): It would be nice if this was uint64 for
</span><span class="c1"></span>	<span class="c1">// faster scanning, but we don&#39;t have 64-bit atomic bit
</span><span class="c1"></span>	<span class="c1">// operations.
</span><span class="c1"></span>	<span class="nx">pageMarks</span> <span class="p">[</span><span class="nx">pagesPerArena</span> <span class="o">/</span> <span class="mi">8</span><span class="p">]</span><span class="kt">uint8</span>

	<span class="c1">// pageSpecials is a bitmap that indicates which spans have
</span><span class="c1"></span>	<span class="c1">// specials (finalizers or other). Like pageInUse, only the bit
</span><span class="c1"></span>	<span class="c1">// corresponding to the first page in each span is used.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Writes are done atomically whenever a special is added to
</span><span class="c1"></span>	<span class="c1">// a span and whenever the last special is removed from a span.
</span><span class="c1"></span>	<span class="c1">// Reads are done atomically to find spans containing specials
</span><span class="c1"></span>	<span class="c1">// during marking.
</span><span class="c1"></span>	<span class="nx">pageSpecials</span> <span class="p">[</span><span class="nx">pagesPerArena</span> <span class="o">/</span> <span class="mi">8</span><span class="p">]</span><span class="kt">uint8</span>

	<span class="c1">// zeroedBase marks the first byte of the first page in this
</span><span class="c1"></span>	<span class="c1">// arena which hasn&#39;t been used yet and is therefore already
</span><span class="c1"></span>	<span class="c1">// zero. zeroedBase is relative to the arena base.
</span><span class="c1"></span>	<span class="c1">// Increases monotonically until it hits heapArenaBytes.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// This field is sufficient to determine if an allocation
</span><span class="c1"></span>	<span class="c1">// needs to be zeroed because the page allocator follows an
</span><span class="c1"></span>	<span class="c1">// address-ordered first-fit policy.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Read atomically and written with an atomic CAS.
</span><span class="c1"></span>	<span class="nx">zeroedBase</span> <span class="kt">uintptr</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li><code>bitmap</code>：表示该 arena 区域中哪些地址保存了对象，<strong>每个字节的前 4bit 的每个 bit 表示一个 8B 内存（4 个指针大小）是否被扫描，后 4bit 每个 bit 表示是否包含指针</strong>。<br>
因此，一个字节就代表了 32B（4 个指针，每个 8B）内存的状态。<strong>（图片来自《知乎：图解 Go 语言内存分配》）</strong></li>
<li><code>spans</code>：每个 mspan 对应的指针，因为管理 64 MB，所以数组长度为 8192（64MB / 8KB）。<br>
其数组编号就是对应的 page 编号，例如 spans[0] 就代表第一个 page 内存区域大小，执行对应的 mspan 。当然，mspan 可能有多个 page 组成，那么对应的多个数组项就指向的同一个 mspan 对象。</li>
<li><code>zeroedBase</code> 记录管理的 arena 的内存基地址。








    <br><img src="/posts/language/golang/language/memory-manager/img8.png"/>


</li>
</ul>
<p>在一个 heapAreana 空间下，<strong>对于任意一个内存地址 addr，(addr - zeroedBase)/8KB 我们能够计算出对应的 page 编号，那么通过 heapAreana.spans[index] 就可以找到对应的 mspan</strong>。
<div class="details admonition note open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-pencil-alt fa-fw" aria-hidden="true"></i>Note<i class="details-icon fas fa-angle-right fa-fw" aria-hidden="true"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">这个非常重要，在垃圾收集和许多地方都需要通过一个内存地址得到其对应的 mspan。</div>
        </div>
    </div></p>
<h4 id="452-mheap-初始化">4.5.2 mheap 初始化</h4>
<p>在 runtime 初始化时，会镜像 mheap 的初始化，执行 <code>mheap.init()</code> 函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Initialize the heap.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">mheap</span><span class="p">)</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">lockInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">lock</span><span class="p">,</span> <span class="nx">lockRankMheap</span><span class="p">)</span>
	<span class="nf">lockInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">sweepSpans</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">spineLock</span><span class="p">,</span> <span class="nx">lockRankSpine</span><span class="p">)</span>
	<span class="nf">lockInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">sweepSpans</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">spineLock</span><span class="p">,</span> <span class="nx">lockRankSpine</span><span class="p">)</span>
	<span class="nf">lockInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">speciallock</span><span class="p">,</span> <span class="nx">lockRankMheapSpecial</span><span class="p">)</span>

	<span class="nx">h</span><span class="p">.</span><span class="nx">spanalloc</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">mspan</span><span class="p">{}),</span> <span class="nx">recordspan</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">h</span><span class="p">),</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">mspan_sys</span><span class="p">)</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">cachealloc</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">mcache</span><span class="p">{}),</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">mcache_sys</span><span class="p">)</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">specialfinalizeralloc</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">specialfinalizer</span><span class="p">{}),</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">other_sys</span><span class="p">)</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">specialprofilealloc</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">specialprofile</span><span class="p">{}),</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">other_sys</span><span class="p">)</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">arenaHintAlloc</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">arenaHint</span><span class="p">{}),</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">other_sys</span><span class="p">)</span>

	<span class="c1">// Don&#39;t zero mspan allocations. Background sweeping can
</span><span class="c1"></span>	<span class="c1">// inspect a span concurrently with allocating it, so it&#39;s
</span><span class="c1"></span>	<span class="c1">// important that the span&#39;s sweepgen survive across freeing
</span><span class="c1"></span>	<span class="c1">// and re-allocating a span to prevent background sweeping
</span><span class="c1"></span>	<span class="c1">// from improperly cas&#39;ing it from 0.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// This is safe because mspan contains no heap pointers.
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">.</span><span class="nx">spanalloc</span><span class="p">.</span><span class="nx">zero</span> <span class="p">=</span> <span class="kc">false</span>

	<span class="c1">// h-&gt;mapcache needs no init
</span><span class="c1"></span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">h</span><span class="p">.</span><span class="nx">central</span> <span class="p">{</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">central</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">mcentral</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="nf">spanClass</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="nx">h</span><span class="p">.</span><span class="nx">pages</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">gc_sys</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>初始化各个类型的空闲链表分配器：<code>spanalloc</code>、<code>cachealloc</code> 等；</li>
<li>初始化各个 <code>mcentral</code>；</li>
<li>初始化 <code>page alloctor</code>；</li>
</ol>
<h4 id="453-mheap-分配-mspan">4.5.3 mheap 分配 mspan</h4>
<p>在 <a href="#442-mcentral-%e6%89%a9%e5%ae%b9" rel=""><strong>mcentral 扩容流程</strong></a>中看到，会调用 <code>mheap.alloc()</code> 申请一个新的 mspan。</p>
<p>而之前说的 large object 分配，也是直接会走 <code>mheap.alloc()</code> 分配到一个合适大小的 mspan，然后分配 object。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// alloc allocates a new span of npage pages from the GC&#39;d heap.
</span><span class="c1">//
</span><span class="c1">// spanclass indicates the span&#39;s size class and scannability.
</span><span class="c1">//
</span><span class="c1">// If needzero is true, the memory for the returned span will be zeroed.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">mheap</span><span class="p">)</span> <span class="nf">alloc</span><span class="p">(</span><span class="nx">npages</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">spanclass</span> <span class="nx">spanClass</span><span class="p">,</span> <span class="nx">needzero</span> <span class="kt">bool</span><span class="p">)</span> <span class="o">*</span><span class="nx">mspan</span> <span class="p">{</span>
	<span class="c1">// Don&#39;t do any operations that lock the heap on the G stack.
</span><span class="c1"></span>	<span class="c1">// It might trigger stack growth, and the stack growth code needs
</span><span class="c1"></span>	<span class="c1">// to be able to allocate heap.
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span>
	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// To prevent excessive heap growth, before allocating n pages
</span><span class="c1"></span>		<span class="c1">// we need to sweep and reclaim at least n pages.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">sweepdone</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">h</span><span class="p">.</span><span class="nf">reclaim</span><span class="p">(</span><span class="nx">npages</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">s</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nf">allocSpan</span><span class="p">(</span><span class="nx">npages</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">spanclass</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_inuse</span><span class="p">)</span>
	<span class="p">})</span>

	<span class="k">if</span> <span class="nx">s</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">needzero</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">needzero</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		 	<span class="nf">memclrNoHeapPointers</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()),</span> <span class="nx">s</span><span class="p">.</span><span class="nx">npages</span><span class="o">&lt;&lt;</span><span class="nx">_PageShift</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">needzero</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>

<span class="c1">// allocSpan allocates an mspan which owns npages worth of memory.
</span><span class="c1">//
</span><span class="c1">// If manual == false, allocSpan allocates a heap span of class spanclass
</span><span class="c1">// and updates heap accounting. If manual == true, allocSpan allocates a
</span><span class="c1">// manually-managed span (spanclass is ignored), and the caller is
</span><span class="c1">// responsible for any accounting related to its use of the span. Either
</span><span class="c1">// way, allocSpan will atomically add the bytes in the newly allocated
</span><span class="c1">// span to *sysStat.
</span><span class="c1">//
</span><span class="c1">// The returned span is fully initialized.
</span><span class="c1">//
</span><span class="c1">// h must not be locked.
</span><span class="c1">//
</span><span class="c1">// allocSpan must be called on the system stack both because it acquires
</span><span class="c1">// the heap lock and because it must block GC transitions.
</span><span class="c1">//
</span><span class="c1">//go:systemstack
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">mheap</span><span class="p">)</span> <span class="nf">allocSpan</span><span class="p">(</span><span class="nx">npages</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">manual</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">spanclass</span> <span class="nx">spanClass</span><span class="p">,</span> <span class="nx">sysStat</span> <span class="o">*</span><span class="kt">uint64</span><span class="p">)</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Function-global state.
</span><span class="c1"></span>	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="nx">base</span><span class="p">,</span> <span class="nx">scav</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

	<span class="c1">// If the allocation is small enough, try the page cache!
</span><span class="c1"></span>	<span class="nx">pp</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">pp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">npages</span> <span class="p">&lt;</span> <span class="nx">pageCachePages</span><span class="o">/</span><span class="mi">4</span> <span class="p">{</span>
	        <span class="nx">c</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">pp</span><span class="p">.</span><span class="nx">pcache</span>

	<span class="c1">// If the cache is empty, refill it.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="p">{</span>
	        <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	        <span class="o">*</span><span class="nx">c</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">pages</span><span class="p">.</span><span class="nf">allocToCache</span><span class="p">()</span>
	        <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Try to allocate from the cache.
</span><span class="c1"></span>	<span class="nx">base</span><span class="p">,</span> <span class="nx">scav</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">alloc</span><span class="p">(</span><span class="nx">npages</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">base</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
	        <span class="nx">s</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nf">tryAllocMSpan</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">s</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">gcBlackenEnabled</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">manual</span> <span class="o">||</span> <span class="nx">spanclass</span><span class="p">.</span><span class="nf">sizeclass</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
	        <span class="k">goto</span> <span class="nx">HaveSpan</span>
	<span class="p">}</span>
	        
	<span class="k">if</span> <span class="nx">base</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// Try to acquire a base address.
</span><span class="c1"></span>		<span class="nx">base</span><span class="p">,</span> <span class="nx">scav</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">pages</span><span class="p">.</span><span class="nf">alloc</span><span class="p">(</span><span class="nx">npages</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">base</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">!</span><span class="nx">h</span><span class="p">.</span><span class="nf">grow</span><span class="p">(</span><span class="nx">npages</span><span class="p">)</span> <span class="p">{</span>
				<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
				<span class="k">return</span> <span class="kc">nil</span>
			<span class="p">}</span>
			<span class="nx">base</span><span class="p">,</span> <span class="nx">scav</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">pages</span><span class="p">.</span><span class="nf">alloc</span><span class="p">(</span><span class="nx">npages</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">base</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			 	<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;grew heap, but no adequate free space found&#34;</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	        
	<span class="err">…</span> 
<span class="nx">HaveSpan</span><span class="p">:</span>
	<span class="c1">// 初始化 mspan
</span><span class="c1"></span>	<span class="err">…</span>
	<span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>函数很长，这里只保留了最关键的步骤：</p>
<ol>
<li>小内存，从当前 <code>p.pcache</code>（pageCache 结构）获取一个内存区域（又是一个缓存~）；</li>
<li><code>p.pcache</code> 中没有获取到，从 p.mspancache 中获取  mspan（还是缓存~）；</li>
<li>内存比较大（large mspan），或者上面还是没有获取到，那么只能从 mheap 中获取了，加锁操作：
<ol>
<li>从 <code>pagealloc.alloc()</code> 获取内存；</li>
<li>没有获取到，<code>mheap.grow()</code> 进行堆扩容，再尝试一次；</li>
</ol>
</li>
<li>还是没有，panic !</li>
</ol>
<p>最后获取到之后，就会走 mspan 的初始化流程，包括初始 mspan 数据结构，记录 mspan 指针到 <code>mheap.arenas</code> 等行为。</p>
<h4 id="454-mheap-回收-mspan">4.5.4 mheap 回收 mspan</h4>
<p>所有的回收 mspan 操作最后殊途同归，会走到 <code>mheap.freeSpan()</code> 函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Free the span back into the heap.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">mheap</span><span class="p">)</span> <span class="nf">freeSpan</span><span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">c</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">mcache</span>
		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="nx">h</span><span class="p">.</span><span class="nf">freeSpanLocked</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="p">})</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">mheap</span><span class="p">)</span> <span class="nf">freeSpanLocked</span><span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span><span class="p">,</span> <span class="nx">acctinuse</span><span class="p">,</span> <span class="nx">acctidle</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="o">...</span>

	<span class="c1">// Mark the space as free.
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">.</span><span class="nx">pages</span><span class="p">.</span><span class="nf">free</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">(),</span> <span class="nx">s</span><span class="p">.</span><span class="nx">npages</span><span class="p">)</span>

	<span class="c1">// Free the span structure. We no longer have a use for it.
</span><span class="c1"></span>	<span class="nx">s</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">mSpanDead</span><span class="p">)</span>
	<span class="nx">h</span><span class="p">.</span><span class="nf">freeMSpanLocked</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// free returns npages worth of memory starting at base back to the page heap.
</span><span class="c1">//
</span><span class="c1">// s.mheapLock must be held.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">pageAlloc</span><span class="p">)</span> <span class="nf">free</span><span class="p">(</span><span class="nx">base</span><span class="p">,</span> <span class="nx">npages</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// If we&#39;re freeing pages below the s.searchAddr, update searchAddr.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">b</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">offAddr</span><span class="p">{</span><span class="nx">base</span><span class="p">});</span> <span class="nx">b</span><span class="p">.</span><span class="nf">lessThan</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">searchAddr</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">searchAddr</span> <span class="p">=</span> <span class="nx">b</span>
	<span class="p">}</span>
	<span class="c1">// Update the free high watermark for the scavenger.
</span><span class="c1"></span>	<span class="nx">limit</span> <span class="o">:=</span> <span class="nx">base</span> <span class="o">+</span> <span class="nx">npages</span><span class="o">*</span><span class="nx">pageSize</span> <span class="o">-</span> <span class="mi">1</span>
	<span class="k">if</span> <span class="nx">offLimit</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">offAddr</span><span class="p">{</span><span class="nx">limit</span><span class="p">});</span> <span class="nx">s</span><span class="p">.</span><span class="nx">scav</span><span class="p">.</span><span class="nx">freeHWM</span><span class="p">.</span><span class="nf">lessThan</span><span class="p">(</span><span class="nx">offLimit</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">scav</span><span class="p">.</span><span class="nx">freeHWM</span> <span class="p">=</span> <span class="nx">offLimit</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">npages</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="c1">// Fast path: we&#39;re clearing a single bit, and we know exactly
</span><span class="c1"></span>		<span class="c1">// where it is, so mark it directly.
</span><span class="c1"></span>		<span class="nx">i</span> <span class="o">:=</span> <span class="nf">chunkIndex</span><span class="p">(</span><span class="nx">base</span><span class="p">)</span>
		<span class="nx">s</span><span class="p">.</span><span class="nf">chunkOf</span><span class="p">(</span><span class="nx">i</span><span class="p">).</span><span class="nf">free1</span><span class="p">(</span><span class="nf">chunkPageIndex</span><span class="p">(</span><span class="nx">base</span><span class="p">))</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// Slow path: we&#39;re clearing more bits so we may need to iterate.
</span><span class="c1"></span>		<span class="nx">sc</span><span class="p">,</span> <span class="nx">ec</span> <span class="o">:=</span> <span class="nf">chunkIndex</span><span class="p">(</span><span class="nx">base</span><span class="p">),</span> <span class="nf">chunkIndex</span><span class="p">(</span><span class="nx">limit</span><span class="p">)</span>
		<span class="nx">si</span><span class="p">,</span> <span class="nx">ei</span> <span class="o">:=</span> <span class="nf">chunkPageIndex</span><span class="p">(</span><span class="nx">base</span><span class="p">),</span> <span class="nf">chunkPageIndex</span><span class="p">(</span><span class="nx">limit</span><span class="p">)</span>

		<span class="k">if</span> <span class="nx">sc</span> <span class="o">==</span> <span class="nx">ec</span> <span class="p">{</span>
			<span class="c1">// The range doesn&#39;t cross any chunk boundaries.
</span><span class="c1"></span>			<span class="nx">s</span><span class="p">.</span><span class="nf">chunkOf</span><span class="p">(</span><span class="nx">sc</span><span class="p">).</span><span class="nf">free</span><span class="p">(</span><span class="nx">si</span><span class="p">,</span> <span class="nx">ei</span><span class="o">+</span><span class="mi">1</span><span class="o">-</span><span class="nx">si</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">// The range crosses at least one chunk boundary.
</span><span class="c1"></span>			<span class="nx">s</span><span class="p">.</span><span class="nf">chunkOf</span><span class="p">(</span><span class="nx">sc</span><span class="p">).</span><span class="nf">free</span><span class="p">(</span><span class="nx">si</span><span class="p">,</span> <span class="nx">pallocChunkPages</span><span class="o">-</span><span class="nx">si</span><span class="p">)</span>
			<span class="k">for</span> <span class="nx">c</span> <span class="o">:=</span> <span class="nx">sc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">c</span> <span class="p">&lt;</span> <span class="nx">ec</span><span class="p">;</span> <span class="nx">c</span><span class="o">++</span> <span class="p">{</span>
				<span class="nx">s</span><span class="p">.</span><span class="nf">chunkOf</span><span class="p">(</span><span class="nx">c</span><span class="p">).</span><span class="nf">freeAll</span><span class="p">()</span>
			<span class="p">}</span>
			<span class="nx">s</span><span class="p">.</span><span class="nf">chunkOf</span><span class="p">(</span><span class="nx">ec</span><span class="p">).</span><span class="nf">free</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">ei</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">s</span><span class="p">.</span><span class="nf">update</span><span class="p">(</span><span class="nx">base</span><span class="p">,</span> <span class="nx">npages</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>清理操作将对应的 page 标记为未使用的，这样之后新的 mspan 创建时可以复用。</p>
<h4 id="455-mheap-扩容">4.5.5 mheap 扩容</h4>
<p>扩容的逻辑更加复杂，目前先不细致的分析了。</p>
<p>这里可以看一下申请内存使用的方式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">sysReserve</span><span class="p">(</span><span class="nx">v</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
	<span class="nx">p</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">mmap</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">_PROT_NONE</span><span class="p">,</span> <span class="nx">_MAP_ANON</span><span class="p">|</span><span class="nx">_MAP_PRIVATE</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">p</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">sysMap</span><span class="p">(</span><span class="nx">v</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">sysStat</span> <span class="o">*</span><span class="kt">uint64</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">mSysStatInc</span><span class="p">(</span><span class="nx">sysStat</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>

	<span class="nx">p</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">mmap</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">_PROT_READ</span><span class="p">|</span><span class="nx">_PROT_WRITE</span><span class="p">,</span> <span class="nx">_MAP_ANON</span><span class="p">|</span><span class="nx">_MAP_FIXED</span><span class="p">|</span><span class="nx">_MAP_PRIVATE</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">_ENOMEM</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: out of memory&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">p</span> <span class="o">!=</span> <span class="nx">v</span> <span class="o">||</span> <span class="nx">err</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: cannot map pages in arena address space&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>会先调用 <code>sysReserve()</code> 来申请内存，但是不使用，预备状态；</li>
<li>经过地址检查后，<code>sysMap()</code> 将其转为可读可写，就可以使用该内存了；</li>
</ol>
<h3 id="46-总结">4.6 总结</h3>
<p>粗略地看完整个内存模型后，大概内存的结构如下：








    <br><img src="/posts/language/golang/language/memory-manager/img9.png"/>


</p>
<p>其中比较核心的就是：<strong>内存被切分为 page，多个 page 组成不同大小的 mspan，而在 mspan 上又分割为固定大小的 object</strong>。</p>
<p>而上层的 mcache、mcentral 只是以不同的方式组织 mspan，<strong>通过多级缓存的思想，使得并发的获取一个可用的 mspan 更快</strong>。</p>
<ul>
<li>mcache 将一部分 mspan 独立于 P 所有，使得不需要加锁既可以获取 mspan；</li>
<li>mcentral 以大小来分类 mspan，将各个大小的 mspan 请求独立，缩小了锁的粒度；</li>
</ul>
<p>mheap 作为最底层，就好像文件系统一样，管理着整个内存分配的骨架。而与上层的交互就是靠 mspan 作为单位。</p>
<h2 id="5-对象分配流程">5 对象分配流程</h2>
<p>前面一直提到的，对象的分配分为三类：</p>
<ul>
<li><strong><code>tiny object</code></strong> <code>(0, 16B)</code>: 使用 tiny allocator 分配，使用 mcahe 一个独立的 mspan，挤压式的；</li>
<li><strong><code>object</code></strong> <code>[16B, 32KB]</code>: 使用 mcache 分配；</li>
<li><strong><code>large object</code></strong> <code>(32KB, +∞)</code>: 直接通过 mheap 分配；</li>
</ul>
<p>所有的分配逻辑在 <code>mallocgc()</code> 开始分叉，下面分别看下具体的分配代码。</p>
<h3 id="51-tiny-object-分配">5.1 tiny object 分配</h3>
<p>tiny object 分配的代码在 <a href="#431-mspan-%e7%9a%84%e5%88%86%e9%85%8d" rel=""><strong>mspan 分配</strong></a>中已经说明了，这里再理一下大致步骤：</p>
<ol>
<li>不包含指针 (noscan) 并且小于 16B 的对象才走微小对象分配；</li>
<li>tiny object 分配仅仅是增大 mcache.tinyoffset 的值，所以是不同大小 tiny object 挤压在一个 mspan 中；</li>
<li>如果当前的 mspan 没有空间了，通过 mcache.nextFree() 来获取新的指定大小的 mspan，而获取的流程就是前面所说的（走 mcentral-&gt;mheap);</li>
</ol>
<h3 id="52-object-分配">5.2 object 分配</h3>
<p>普通大小 object 分配流程就很简单了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">size</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">typ</span> <span class="o">*</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">needzero</span> <span class="kt">bool</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">size</span> <span class="o">&lt;=</span> <span class="nx">maxSmallSize</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">noscan</span> <span class="o">&amp;&amp;</span> <span class="nx">size</span> <span class="p">&lt;</span> <span class="nx">maxTinySize</span> <span class="p">{</span>
			<span class="o">...</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="kd">var</span> <span class="nx">sizeclass</span> <span class="kt">uint8</span>
			<span class="k">if</span> <span class="nx">size</span> <span class="o">&lt;=</span> <span class="nx">smallSizeMax</span><span class="o">-</span><span class="mi">8</span> <span class="p">{</span>
				<span class="nx">sizeclass</span> <span class="p">=</span> <span class="nx">size_to_class8</span><span class="p">[</span><span class="nf">divRoundUp</span><span class="p">(</span><span class="nx">size</span><span class="p">,</span> <span class="nx">smallSizeDiv</span><span class="p">)]</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">sizeclass</span> <span class="p">=</span> <span class="nx">size_to_class128</span><span class="p">[</span><span class="nf">divRoundUp</span><span class="p">(</span><span class="nx">size</span><span class="o">-</span><span class="nx">smallSizeMax</span><span class="p">,</span> <span class="nx">largeSizeDiv</span><span class="p">)]</span>
			<span class="p">}</span>
			<span class="nx">size</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">class_to_size</span><span class="p">[</span><span class="nx">sizeclass</span><span class="p">])</span>
			<span class="nx">spc</span> <span class="o">:=</span> <span class="nf">makeSpanClass</span><span class="p">(</span><span class="nx">sizeclass</span><span class="p">,</span> <span class="nx">noscan</span><span class="p">)</span>
			<span class="nx">span</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">alloc</span><span class="p">[</span><span class="nx">spc</span><span class="p">]</span>
			<span class="nx">v</span> <span class="o">:=</span> <span class="nf">nextFreeFast</span><span class="p">(</span><span class="nx">span</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">v</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">v</span><span class="p">,</span> <span class="nx">span</span><span class="p">,</span> <span class="nx">shouldhelpgc</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">nextFree</span><span class="p">(</span><span class="nx">spc</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">x</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">needzero</span> <span class="o">&amp;&amp;</span> <span class="nx">span</span><span class="p">.</span><span class="nx">needzero</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nf">memclrNoHeapPointers</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">v</span><span class="p">),</span> <span class="nx">size</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">...</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>计算出对应的 sizeclass；</li>
<li>从 <code>mcache.alloc[]</code> 得到对应的 mspan。如果没有，通过 <code>nextFree()</code> 申请；</li>
<li>调用 <code>memclrNoHeapPointers()</code> 清理空闲内存中所有数据；</li>
</ol>
<h3 id="53-large-object-分配">5.3 large object 分配</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">size</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">typ</span> <span class="o">*</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">needzero</span> <span class="kt">bool</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">size</span> <span class="o">&lt;=</span> <span class="nx">maxSmallSize</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">noscan</span> <span class="o">&amp;&amp;</span> <span class="nx">size</span> <span class="p">&lt;</span> <span class="nx">maxTinySize</span> <span class="p">{</span>
			<span class="o">...</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="o">...</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">shouldhelpgc</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">span</span> <span class="p">=</span> <span class="nf">largeAlloc</span><span class="p">(</span><span class="nx">size</span><span class="p">,</span> <span class="nx">needzero</span><span class="p">,</span> <span class="nx">noscan</span><span class="p">)</span>
		<span class="p">})</span>
		<span class="nx">span</span><span class="p">.</span><span class="nx">freeindex</span> <span class="p">=</span> <span class="mi">1</span>
		<span class="nx">span</span><span class="p">.</span><span class="nx">allocCount</span> <span class="p">=</span> <span class="mi">1</span>
		<span class="nx">x</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">span</span><span class="p">.</span><span class="nf">base</span><span class="p">())</span>
		<span class="nx">size</span> <span class="p">=</span> <span class="nx">span</span><span class="p">.</span><span class="nx">elemsize</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">largeAlloc</span><span class="p">(</span><span class="nx">size</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">needzero</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">noscan</span> <span class="kt">bool</span><span class="p">)</span> <span class="o">*</span><span class="nx">mspan</span> <span class="p">{</span>
	<span class="c1">// print(&#34;largeAlloc size=&#34;, size, &#34;\n&#34;)
</span><span class="c1"></span>
	<span class="k">if</span> <span class="nx">size</span><span class="o">+</span><span class="nx">_PageSize</span> <span class="p">&lt;</span> <span class="nx">size</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;out of memory&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">npages</span> <span class="o">:=</span> <span class="nx">size</span> <span class="o">&gt;&gt;</span> <span class="nx">_PageShift</span>
	<span class="k">if</span> <span class="nx">size</span><span class="o">&amp;</span><span class="nx">_PageMask</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">npages</span><span class="o">++</span>
	<span class="p">}</span>

	<span class="c1">// Deduct credit for this span allocation and sweep if
</span><span class="c1"></span>	<span class="c1">// necessary. mHeap_Alloc will also sweep npages, so this only
</span><span class="c1"></span>	<span class="c1">// pays the debt down to npage pages.
</span><span class="c1"></span>	<span class="nf">deductSweepCredit</span><span class="p">(</span><span class="nx">npages</span><span class="o">*</span><span class="nx">_PageSize</span><span class="p">,</span> <span class="nx">npages</span><span class="p">)</span>

	<span class="nx">spc</span> <span class="o">:=</span> <span class="nf">makeSpanClass</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">noscan</span><span class="p">)</span>
	<span class="nx">s</span> <span class="o">:=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nf">alloc</span><span class="p">(</span><span class="nx">npages</span><span class="p">,</span> <span class="nx">spc</span><span class="p">,</span> <span class="nx">needzero</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;out of memory&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">go115NewMCentralImpl</span> <span class="p">{</span>
		<span class="c1">// Put the large span in the mcentral swept list so that it&#39;s
</span><span class="c1"></span>		<span class="c1">// visible to the background sweeper.
</span><span class="c1"></span>		<span class="nx">mheap_</span><span class="p">.</span><span class="nx">central</span><span class="p">[</span><span class="nx">spc</span><span class="p">].</span><span class="nx">mcentral</span><span class="p">.</span><span class="nf">fullSwept</span><span class="p">(</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">).</span><span class="nf">push</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">limit</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()</span> <span class="o">+</span> <span class="nx">size</span>
	<span class="nf">heapBitsForAddr</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()).</span><span class="nf">initSpan</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>large object 会切换到系统栈，然后走 mheap 申请；</li>
<li>计算对象需要的 page 数量，然后调用 mheap.alloc() 申请空闲的 mspan；</li>
</ol>
<p>而 <a href="#453-mheap-%e5%88%86%e9%85%8d-mspan" rel=""><strong>mheap.alloc()</strong></a> 就是 mcentral 申请 mspan 的方法。</p>
<h2 id="6-内存的释放">6 内存的释放</h2>
<h3 id="61-释放操作">6.1 释放操作</h3>
<p>前面 <a href="#454-mheap-%e5%9b%9e%e6%94%b6-mspan" rel=""><strong>4.5.4 mheap 回收 mspan</strong></a> 中看到，mheap 不会真正的释放内存，而是等待其被复用。但是不可能一直扩展内存，而不释放。</p>
<p>释放内存由 <code>mheap.page</code> 的 <code>pageAlloc.scavenge()</code> 函数负责（runtime/mgcscavenge.go）:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// scavenge scavenges nbytes worth of free pages, starting with the
</span><span class="c1">// highest address first. Successive calls continue from where it left
</span><span class="c1">// off until the heap is exhausted. Call scavengeStartGen to bring it
</span><span class="c1">// back to the top of the heap.
</span><span class="c1">//
</span><span class="c1">// Returns the amount of memory scavenged in bytes.
</span><span class="c1">//
</span><span class="c1">// s.mheapLock must be held, but may be temporarily released if
</span><span class="c1">// mayUnlock == true.
</span><span class="c1">//
</span><span class="c1">// Must run on the system stack because s.mheapLock must be held.
</span><span class="c1">//
</span><span class="c1">//go:systemstack
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">pageAlloc</span><span class="p">)</span> <span class="nf">scavenge</span><span class="p">(</span><span class="nx">nbytes</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">mayUnlock</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">uintptr</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="p">(</span>
		<span class="nx">addrs</span> <span class="nx">addrRange</span>
		<span class="nx">gen</span>   <span class="kt">uint32</span>
	<span class="p">)</span>
	<span class="nx">released</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">released</span> <span class="p">&lt;</span> <span class="nx">nbytes</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">addrs</span><span class="p">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// 通过标记选出一部分需要释放的内存区域
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">addrs</span><span class="p">,</span> <span class="nx">gen</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">scavengeReserve</span><span class="p">();</span> <span class="nx">addrs</span><span class="p">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="k">break</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="c1">// 释放内存
</span><span class="c1"></span>		<span class="nx">r</span><span class="p">,</span> <span class="nx">a</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">scavengeOne</span><span class="p">(</span><span class="nx">addrs</span><span class="p">,</span> <span class="nx">nbytes</span><span class="o">-</span><span class="nx">released</span><span class="p">,</span> <span class="nx">mayUnlock</span><span class="p">)</span>
		<span class="nx">released</span> <span class="o">+=</span> <span class="nx">r</span>
		<span class="nx">addrs</span> <span class="p">=</span> <span class="nx">a</span>
	<span class="p">}</span>
	<span class="c1">// Only unreserve the space which hasn&#39;t been scavenged or searched
</span><span class="c1"></span>	<span class="c1">// to ensure we always make progress.
</span><span class="c1"></span>	<span class="nx">s</span><span class="p">.</span><span class="nf">scavengeUnreserve</span><span class="p">(</span><span class="nx">addrs</span><span class="p">,</span> <span class="nx">gen</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">released</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>释放的流程比较复杂，没有研究过看不懂，目前知道下最后会调用 <code>sysUnused()</code> 函数释放（runtime/mem_linux.go）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">sysUnused</span><span class="p">(</span><span class="nx">v</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// huge page 处理
</span><span class="c1"></span>	<span class="o">...</span>

	<span class="kd">var</span> <span class="nx">advise</span> <span class="kt">uint32</span>
	<span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">madvdontneed</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">advise</span> <span class="p">=</span> <span class="nx">_MADV_DONTNEED</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">advise</span> <span class="p">=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">adviseUnused</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">errno</span> <span class="o">:=</span> <span class="nf">madvise</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">advise</span><span class="p">));</span> <span class="nx">advise</span> <span class="o">==</span> <span class="nx">_MADV_FREE</span> <span class="o">&amp;&amp;</span> <span class="nx">errno</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// MADV_FREE was added in Linux 4.5. Fall back to MADV_DONTNEED if it is
</span><span class="c1"></span>		<span class="c1">// not supported.
</span><span class="c1"></span>		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">adviseUnused</span><span class="p">,</span> <span class="nx">_MADV_DONTNEED</span><span class="p">)</span>
		<span class="nf">madvise</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">_MADV_DONTNEED</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>通过系统调用 <strong><code>madvise()</code></strong> 告知操作系统某段内存不适用，建议内核回收对应物理内存。<br>
当然，内核在物理内存充足情况下可能不会实际回收内存，以减少无谓的回收消耗。<br>
而当再次使用此内存块时，会引发缺页异常，内核会自动重新关联物理内存页。</li>
</ul>
<h3 id="62-释放时机">6.2 释放时机</h3>
<p><code>scavenge()</code> 有两个地方会被调用：</p>
<ol>
<li><strong>周期性的触发</strong>（每 5 min?）；</li>
<li><strong>mheap 扩容时</strong> 或者 <strong>调用 <a href="https://pkg.go.dev/runtime/debug#FreeOSMemory" target="_blank" rel="noopener noreffer">runtime/debug.FreeOSMemory()</a> 主动触发</strong>；</li>
</ol>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://github.com/qyuhen/book" target="_blank" rel="noopener noreffer">《Golang 学习笔记》</a></li>
<li><a href="https://medium.com/@ankur_anand/a-visual-guide-to-golang-memory-allocator-from-ground-up-e132258453ed" target="_blank" rel="noopener noreffer">Blog：Go 内存管理可视化</a></li>
<li><a href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/#71-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8" target="_blank" rel="noopener noreffer">《Golang 设计与实现》：内存分配器</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/59125443" target="_blank" rel="noopener noreffer">知乎：图解 Go 语言内存分配</a></li>
</ul>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2022-08-30&nbsp;<a class="git-hash" href="https://github.com/KanShiori/KanShiori.github.io/commit/f5ba9207995057a8a740dd42de4f0089c8ad6424" target="_blank" title="commit by Shiori(yshshihaoren@qq.com) f5ba9207995057a8a740dd42de4f0089c8ad6424: Post(CSI Implement): optimize (#14)">
                                    <i class="fas fa-hashtag fa-fw" aria-hidden="true"></i>f5ba920</a></span>
            </div></div>
        <div class="post-info-line">
            <div class="post-info-md"><span>
                            <a class="link-to-markdown" href="/posts/language/golang/language/memory-manager/index.md" target="_blank">阅读原始文档</a>
                        </span></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="分享到 Twitter" data-sharer="twitter" data-url="https://KanShiori.github.io/posts/language/golang/language/memory-manager/" data-title="Go 内存管理总结" data-hashtags="Golang,Golang 原理"><i class="fab fa-twitter fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 Facebook" data-sharer="facebook" data-url="https://KanShiori.github.io/posts/language/golang/language/memory-manager/" data-hashtag="Golang"><i class="fab fa-facebook-square fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 Hacker News" data-sharer="hackernews" data-url="https://KanShiori.github.io/posts/language/golang/language/memory-manager/" data-title="Go 内存管理总结"><i class="fab fa-hacker-news fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 Line" data-sharer="line" data-url="https://KanShiori.github.io/posts/language/golang/language/memory-manager/" data-title="Go 内存管理总结"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@6.20.0/icons/line.svg" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="https://KanShiori.github.io/posts/language/golang/language/memory-manager/" data-title="Go 内存管理总结"><i class="fab fa-weibo fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 百度" data-sharer="baidu" data-url="https://KanShiori.github.io/posts/language/golang/language/memory-manager/" data-title="Go 内存管理总结"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@6.20.0/icons/baidu.svg" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 Evernote" data-sharer="evernote" data-url="https://KanShiori.github.io/posts/language/golang/language/memory-manager/" data-title="Go 内存管理总结"><i class="fab fa-evernote fa-fw" aria-hidden="true"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;<a href="/tags/golang/">Golang</a>,&nbsp;<a href="/tags/golang-%E5%8E%9F%E7%90%86/">Golang 原理</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/cloud/vm/kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%BD%91%E7%BB%9C/" class="prev" rel="prev" title="KVM 虚拟机的存储与网络总结"><i class="fas fa-angle-left fa-fw" aria-hidden="true"></i>KVM 虚拟机的存储与网络总结</a>
            <a href="/posts/language/golang/language/garbage-collection/" class="next" rel="next" title="Go 垃圾收集总结">Go 垃圾收集总结<i class="fas fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
</article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><i class="far fa-copyright fa-fw" aria-hidden="true"></i><span itemprop="copyrightYear">2020 - 2022</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank">Shiori</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw" aria-hidden="true"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw" aria-hidden="true"></i>
            </a>
        </div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/algoliasearch@4.13.0/dist/algoliasearch-lite.umd.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.1/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":35},"comment":{},"search":{"algoliaAppID":"9NJS0VQU0I","algoliaIndex":"blog","algoliaSearchKey":"85d62ea65a7f7445fbfb413bdca088f2","highlightTag":"em","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"algolia"}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
