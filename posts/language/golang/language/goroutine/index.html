<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <title>Go 并发调度总结 - Shiori&#39;s Blog</title><meta name="Description" content="Go 协程实现，GMP 模型实现，调度算法实现"><meta property="og:title" content="Go 并发调度总结" />
<meta property="og:description" content="Go 协程实现，GMP 模型实现，调度算法实现" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://KanShiori.github.io/posts/language/golang/language/goroutine/" /><meta property="og:image" content="https://KanShiori.github.io/icons/favicon-16x16.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-01-23T17:45:55+08:00" />
<meta property="article:modified_time" content="2022-12-29T15:20:59+08:00" /><meta property="og:site_name" content="My cool site" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://KanShiori.github.io/icons/favicon-16x16.png"/>

<meta name="twitter:title" content="Go 并发调度总结"/>
<meta name="twitter:description" content="Go 协程实现，GMP 模型实现，调度算法实现"/>
<meta name="application-name" content="Shiori&#39;s Blog">
<meta name="apple-mobile-web-app-title" content="Shiori&#39;s Blog"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="icon" href="/icons/favicon.ico"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://KanShiori.github.io/posts/language/golang/language/goroutine/" /><link rel="prev" href="https://KanShiori.github.io/posts/language/golang/language/garbage-collection/" /><link rel="next" href="https://KanShiori.github.io/posts/linux/net/linux-%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91%E5%8C%85%E8%BF%87%E7%A8%8B%E6%80%BB%E7%BB%93/" /><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css"></noscript><link rel="preload" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css"></noscript><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Go 并发调度总结",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/KanShiori.github.io\/posts\/language\/golang\/language\/goroutine\/"
        },"image": ["https:\/\/KanShiori.github.io\/images\/Apple-Devices-Preview.png"],"genre": "posts","keywords": "Golang, Golang 原理","wordcount":  14980 ,
        "url": "https:\/\/KanShiori.github.io\/posts\/language\/golang\/language\/goroutine\/","datePublished": "2021-01-23T17:45:55+08:00","dateModified": "2022-12-29T15:20:59+08:00","license": "This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher": {
            "@type": "Organization",
            "name": "xxxx","logo": "https:\/\/KanShiori.github.io\/images\/avatar.png"},"author": {
                "@type": "Person",
                "name": "Shiori"
            },"description": "Go 协程实现，GMP 模型实现，调度算法实现"
    }
    </script></head>
    <body data-header-desktop="fixed" data-header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="Shiori&#39;s Blog"><img
        class="lazyload logo"
        src="/svg/loading.min.svg"
        data-src="/icons/favicon-32x32.png"
        data-srcset="/icons/favicon-32x32.png, /icons/favicon-32x32.png 1.5x, /icons/favicon-32x32.png 2x"
        data-sizes="auto"
        alt="/icons/favicon-32x32.png"
        title="/icons/favicon-32x32.png" />Shiori&#39;s Blog</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="http://kanshiori.cn" rel="noopener noreffer" target="_blank"> 主页 </a><a class="menu-item" href="/posts/"> 所有文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><a class="menu-item" href="/about/"> 关于 </a><a class="menu-item" href="https://github.com/KanShiori/KanShiori.github.io" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i>  </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="Shiori&#39;s Blog"><img
        class="lazyload logo"
        src="/svg/loading.min.svg"
        data-src="/icons/favicon-32x32.png"
        data-srcset="/icons/favicon-32x32.png, /icons/favicon-32x32.png 1.5x, /icons/favicon-32x32.png 2x"
        data-sizes="auto"
        alt="/icons/favicon-32x32.png"
        title="/icons/favicon-32x32.png" />Shiori&#39;s Blog</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="http://kanshiori.cn" title="" rel="noopener noreffer" target="_blank">主页</a><a class="menu-item" href="/posts/" title="">所有文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a class="menu-item" href="/about/" title="">关于</a><a class="menu-item" href="https://github.com/KanShiori/KanShiori.github.io" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i></a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a></div>
    </div>
</header><div class="search-dropdown desktop">
        <div id="search-dropdown-desktop"></div>
    </div>
    <div class="search-dropdown mobile">
        <div id="search-dropdown-mobile"></div>
    </div><main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Go 并发调度总结</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>Shiori</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/golang/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>Golang</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw" aria-hidden="true"></i>&nbsp;<time datetime="2021-01-23">2021-01-23</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden="true"></i>&nbsp;约 14980 字&nbsp;
                <i class="far fa-clock fa-fw" aria-hidden="true"></i>&nbsp;预计阅读 30 分钟&nbsp;</div>
        </div><div class="details toc" id="toc-static"  data-kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right" aria-hidden="true"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#1-背景知识">1 背景知识</a>
      <ul>
        <li><a href="#11-进程-线程-协程">1.1 进程 线程 协程</a></li>
        <li><a href="#12-调度器">1.2 调度器</a></li>
        <li><a href="#13-pc-与-sp">1.3 PC 与 SP</a>
          <ul>
            <li><a href="#131-pc">1.3.1 PC</a></li>
            <li><a href="#132-sp">1.3.2 SP</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#2-gmp-模型">2 GMP 模型</a>
      <ul>
        <li><a href="#21-g">2.1 G</a>
          <ul>
            <li><a href="#211-g-的状态">2.1.1 G 的状态</a></li>
            <li><a href="#212-g-的创建">2.1.2 G 的创建</a></li>
            <li><a href="#213-g-上下文的保存">2.1.3 G 上下文的保存</a></li>
          </ul>
        </li>
        <li><a href="#22-m">2.2 M</a>
          <ul>
            <li><a href="#221-m-的创建">2.2.1 M 的创建</a></li>
            <li><a href="#222-m-的启动">2.2.2 M 的启动</a></li>
            <li><a href="#223-m-的退出">2.2.3 M 的退出</a></li>
            <li><a href="#224-m-与-g-的锁定">2.2.4 M 与 G 的锁定</a></li>
          </ul>
        </li>
        <li><a href="#23-p">2.3 P</a>
          <ul>
            <li><a href="#231-p-的状态">2.3.1 P 的状态</a></li>
            <li><a href="#232-p-的创建销毁">2.3.2 P 的创建/销毁</a></li>
            <li><a href="#233-p-数量调整">2.3.3 P 数量调整</a></li>
            <li><a href="#234-p-的可运行队列">2.3.4 P 的可运行队列</a></li>
          </ul>
        </li>
        <li><a href="#24-schedt">2.4 schedt</a></li>
      </ul>
    </li>
    <li><a href="#3-调度循环">3 调度循环</a>
      <ul>
        <li><a href="#31-schedule">3.1 schedule()</a>
          <ul>
            <li><a href="#311-fundrunnable">3.1.1 fundrunnable()</a></li>
          </ul>
        </li>
        <li><a href="#32-execute">3.2 execute()</a></li>
        <li><a href="#33-goexit">3.3 goexit()</a></li>
      </ul>
    </li>
    <li><a href="#4-调度切换">4 调度切换</a>
      <ul>
        <li><a href="#41-切换时机">4.1 切换时机</a></li>
        <li><a href="#42-主动挂起">4.2 主动挂起</a></li>
        <li><a href="#43-主动调度">4.3 主动调度</a></li>
        <li><a href="#44-系统调用">4.4 系统调用</a>
          <ul>
            <li><a href="#441-系统调用前的准备">4.4.1 系统调用前的准备</a></li>
            <li><a href="#442-系统调用后的恢复">4.4.2 系统调用后的恢复</a></li>
          </ul>
        </li>
        <li><a href="#45-抢占">4.5 抢占</a>
          <ul>
            <li><a href="#451-触发抢占时机">4.5.1 触发抢占时机</a></li>
            <li><a href="#452-触发抢占">4.5.2 触发抢占</a></li>
            <li><a href="#453-通过抢占标志抢占">4.5.3 通过抢占标志抢占</a></li>
            <li><a href="#454-信号抢占">4.5.4 信号抢占</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#总结">总结</a></li>
    <li><a href="#参考">参考</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><blockquote>
<p><strong>总结系列的文章</strong>是自己的学习或使用后，对相关知识的一个总结，用于后续可以快速复习与回顾。</p>
</blockquote>
<p>本文是对 Golang 并发调度实现的一个总结，基本内容来源于网络的学习，以及自己观摩了下源码。</p>
<p>所以学习的书籍与文章见 <a href="#%e5%8f%82%e8%80%83" rel=""><strong>参考</strong></a>。</p>
<p>下面代码都是基于 go 1.15.6。</p>
<h2 id="1-背景知识">1 背景知识</h2>
<h3 id="11-进程-线程-协程">1.1 进程 线程 协程</h3>
<p>看协程的实现之前，绕不开的需要知道进程与线程，以及它们之间的比较。</p>
<p><strong><ruby>进程<rt>progress</rt></ruby></strong> 就是程序执行的实例。在内核角度上看，进程是<strong>分配系统资源的实体</strong>。</p>
<p>而这也可以推出，所谓的进程切换的消耗，也就是切换分配的系统资源，包括<strong>虚拟内存（页表等）</strong>、<strong>寄存器的值</strong>等。
<div class="details admonition tip open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-lightbulb fa-fw" aria-hidden="true"></i>Tip<i class="details-icon fas fa-angle-right fa-fw" aria-hidden="true"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">据说每次上下文切换需要几十纳秒到微秒的 CPU 时间。</div>
        </div>
    </div></p>
<p><strong><ruby>线程<rt>thread</rt></ruby></strong> 是<strong>内核调度的基本单元</strong>，在 Linux 上，线程就是 “轻量级进程”，因为它与进程在内核的看来都一样，仅仅是共享了一些资源，包括：</p>
<ul>
<li>内存地址空间；</li>
<li>进程的基础信息；</li>
<li>打开的文件描述符；</li>
<li>信号处理；</li>
<li>等等</li>
</ul>
<p>所以相对于进程间切换，同一个进程下的线程切换，可以<strong>省略这些共享的资源的切换</strong>。因此，线程间切换速度快于进程间切换。
<div class="details admonition note open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-pencil-alt fa-fw" aria-hidden="true"></i>Note<i class="details-icon fas fa-angle-right fa-fw" aria-hidden="true"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">所谓进程切换就是不同进程间的线程切换，所以下面所说的线程间的切换、线程上下文都是指同进程下的线程。</div>
        </div>
    </div></p>
<p>上面所说的调度、切换都是站在内核的角度看线程。而站在线程的角度，它可以认为自己是 <strong>“完全” 占用 CPU 的</strong>。如果线程阻塞等待，就等于 CPU 在 <del>空闲</del> 浪费。</p>
<p>所以，写代码往往会使用异步 API，<strong>通过回调/通知来使得线程阻塞的更加少</strong>（典型的 epoll），这时候 CPU 原来阻塞的时间可以执行其他的代码。</p>
<p>但是，回调的代码不是同一个函数里线性执行的，会有一些缺点，具体例子，A 函数最初的执行流为：</p>
<ul>
<li>执行 -&gt; 读取数据 -&gt; 执行</li>
</ul>
<p>如果使用异步 API，其执行流程变为：</p>
<ul>
<li>A 函数：执行 -&gt; 异步 -&gt; 返回</li>
<li>回调函数：读取数据 -&gt; 执行。</li>
</ul>
<p>首先，单个函数的执行流变为了两个不同函数，代码写法上串行的思维要变为分割的思维。并且，如果这个操作还是有状态的，那么还涉及到了 “A 函数将状态传递到回调函数” 等问题。








    <br><img src="/posts/language/golang/language/goroutine/img1.png"/>


</p>
<p>因此，<strong><ruby>协程<rt>routine</rt></ruby></strong> 出现，上面的例子的执行流还是：</p>
<ul>
<li>执行 -&gt; 读取数据 -&gt; 执行</li>
</ul>
<p>但是，<strong>在读取数据这一步，协程会主动让出 CPU，等待数据到来时再次切换到该协程</strong>，继续执行。因此，写法不变，功能相同。</p>
<p>并且，在一些用户空间的生产消费模型实现上（channel），协程的阻塞不需要线程阻塞，而在用户空间就完成了协程的切换。</p>
<h3 id="12-调度器">1.2 调度器</h3>
<p><strong><ruby>调度器<rt>scheduler</rt></ruby></strong> 是为了在决定在有限的 CPU 上，选择哪些任务（进程/线程/协程）执行使得系统运行更高效，所以主要有两个工作：</p>
<ol>
<li><strong>决定为各个任务决定其运行多长时间，以及何时切换到下个任务执行</strong>；</li>
<li><strong>在切换任务 A 至任务 B 时，必须保存任务 A 的运行环境，并且任务 B 的运行环境与上次其被切换时完全相同</strong>；</li>
</ol>
<p>第 1 个工作涉及到的就是 <strong><code>调度算法</code></strong>，如何调度使得系统运行的最高效。</p>
<p>第 2 个工作涉及到的就是 <strong><code>上下文切换</code></strong>，这里再说一下进程、线程、协程的上下文：</p>
<ul>
<li>进程：虚拟内存、寄存器的值、内核对应进程信息等；（内核完成上下文切换）</li>
<li>线程：寄存器的值、内核对应的进程信息等；（内核完成上下文切换）</li>
<li>协程：寄存器的值、用户空间对应的协程信息等；（用户空闲 runtime 完成协程上下文切换）</li>
</ul>
<div class="details admonition note open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-pencil-alt fa-fw" aria-hidden="true"></i>Note<i class="details-icon fas fa-angle-right fa-fw" aria-hidden="true"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">上面的切换没有说栈，因为栈的切换就是寄存器的切换。</div>
        </div>
    </div>
<h3 id="13-pc-与-sp">1.3 PC 与 SP</h3>
<p>这一块在 <a href="../memory-manager/#2-pc-%e4%b8%8e-sp" rel=""><strong>内存管理总结</strong></a> 说过，因为对协程切换很重要，这个再次复制一下。</p>
<h4 id="131-pc">1.3.1 PC</h4>
<p><strong><ruby>程序计数器 PC<rt>Program Counter</rt></ruby></strong> 是 CPU 中的一个寄存器，<strong>保存着下一个 CPU 执行的指令的位置</strong>。顺序执行指令时，PC = PC + 1（一个指令）。而调用函数或者条件跳转时，会将跳到的指令地址设置到 PC 中。</p>
<p>所以，可以想到，当需要切换执行的 goroutine，调用 JMP 指令跳转到 G 对应的代码。</p>
<h4 id="132-sp">1.3.2 SP</h4>
<p><strong><ruby>栈顶指针 SP<rt>stack pointer</rt></ruby></strong> 是<strong>保存栈顶地址的寄存器</strong>，我们平时所说的临时变量在栈上，就是将临时变量的值写入 SP 保存的内存地址，然后 SP 保存的地址减小（栈是从高地址向低地址变化），然后临时变量销毁时，SP 地址又变为高地址。</p>
<p>不过，因为 goroutine 切换时，必须要保存当前 goroutine 的上下文，也就是栈里的变量。因此，goroutine 栈肯定是不能使用 Linux 进程栈了（因为进程栈有上限，也无法实现“保存”这种功能）。所以所说的<strong>协程栈，都是基于 mmap 申请内存空间</strong>（基于 Go 内存管理，内存管理基于 mmap），然后<strong>切换时修改 SP 寄存器地址实现的</strong>。</p>
<p>这也是为什么 goroutine 栈可以“无限大”的原因了。</p>
<h2 id="2-gmp-模型">2 GMP 模型</h2>
<p>先从整体模型入手，整个协程实现有着三个最主要的对象：</p>
<ul>
<li><strong><code>G</code></strong> ：表示 Goroutine，<strong>保存并发任务的状态（上下文）</strong>；</li>
<li><strong><code>M</code></strong> ：表示<strong>系统线程，必须在绑定 P 后，执行 G 任务</strong>；</li>
<li><strong><code>P</code></strong> ：处理器，作用类似于 CPU 核，<strong>控制并发执行任务数量</strong>；</li>
<li><strong><code>schedt</code></strong> ：全局的链表，包括<strong>全局的 G 可运行链表、空闲 M 链表、空闲 P 链表</strong>；</li>
</ul>
<p>而大致的运行的模型如下：








    <br><img src="/posts/language/golang/language/goroutine/img2.png"/>


</p>
<ul>
<li>每个 P 绑定一个 M，与一个正在运行的 G；</li>
<li>每个 P 包含自己本地的可运行的 G 的链表；</li>
<li>全局的 G 的可运行链表，用以提供给无 G 可以执行的 P；</li>
<li>一些 M 与 G 的绑定，因为系统调用阻塞而解绑了 P，M 阻塞结束后还是会进入调度循环；</li>
<li>一些 G 主动进入 waiting 状态，等待唤醒后重新加入某个可运行队列（典型的，读取 channel 阻塞，这是一个用户空间的阻塞，由发送 channel 时将其唤醒）；</li>
<li>空闲 M 链表，空闲 P 链表，空闲 G 链表等；</li>
</ul>
<h3 id="21-g">2.1 G</h3>
<p><strong><code>g 结构</code></strong>（runtime/runtime2.go）代表一个 G，包含了某个任务的上下文，M 切换 G 执行时，当前 G 的上下文就保存在了 g 结构中。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">g</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="c1">// Stack parameters.
</span><span class="c1"></span>        <span class="c1">// stack describes the actual stack memory: [stack.lo, stack.hi).
</span><span class="c1"></span>        <span class="c1">// stackguard0 is the stack pointer compared in the Go stack growth prologue.
</span><span class="c1"></span>        <span class="c1">// It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption.
</span><span class="c1"></span>        <span class="c1">// stackguard1 is the stack pointer compared in the C stack growth prologue.
</span><span class="c1"></span>        <span class="c1">// It is stack.lo+StackGuard on g0 and gsignal stacks.
</span><span class="c1"></span>        <span class="c1">// It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash).
</span><span class="c1"></span>        <span class="nx">stack</span>       <span class="nx">stack</span>   <span class="c1">// offset known to runtime/cgo
</span><span class="c1"></span>        <span class="nx">stackguard0</span> <span class="kt">uintptr</span> <span class="c1">// offset known to liblink
</span><span class="c1"></span>        <span class="nx">stackguard1</span> <span class="kt">uintptr</span> <span class="c1">// offset known to liblink
</span><span class="c1"></span>
        <span class="nx">_panic</span>       <span class="o">*</span><span class="nx">_panic</span> <span class="c1">// innermost panic - offset known to liblink
</span><span class="c1"></span>        <span class="nx">_defer</span>       <span class="o">*</span><span class="nx">_defer</span> <span class="c1">// innermost defer
</span><span class="c1"></span>        <span class="nx">m</span>            <span class="o">*</span><span class="nx">m</span>      <span class="c1">// current m; offset known to arm liblink
</span><span class="c1"></span>        <span class="nx">sched</span>        <span class="nx">gobuf</span>
        
        <span class="nx">atomicstatus</span> <span class="kt">uint32</span>
        <span class="nx">goid</span>         <span class="kt">int64</span>
        
        <span class="nx">preempt</span>       <span class="kt">bool</span> <span class="c1">// preemption signal, duplicates stackguard0 = stackpreempt
</span><span class="c1"></span>        <span class="nx">preemptStop</span>   <span class="kt">bool</span> <span class="c1">// transition to _Gpreempted on preemption; otherwise, just deschedule
</span><span class="c1"></span>        <span class="nx">preemptShrink</span> <span class="kt">bool</span> <span class="c1">// shrink stack at synchronous safe point
</span><span class="c1"></span>
       <span class="nx">lockedm</span>        <span class="nx">muintptr</span> 
        <span class="err">…</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li><code>stack</code>：G 对应栈空间的地址，见（内存管理模型-Goroutine 的栈）；</li>
<li><strong><code>stackguar0</code></strong>：扩容栈的地址，也可以用于判断 G 是否应该被抢占；当 stackguard0 == stackpreempt 就表明当前 G 被抢占了；</li>
<li><code>_panic</code>：G 下的 panic 链表；</li>
<li><code>_defer</code>：G 下的所有 defer 组成的链表；</li>
<li><strong><code>m</code></strong>：当前绑定的 M，为 nil 就表示当前 G 没有在执行；</li>
<li><strong><code>sched</code></strong>：G 的部分上下文，会提供给汇编代码；</li>
<li><strong><code>atomicstatus</code></strong>：G 的状态；</li>
<li><code>goid</code>：G 的唯一 ID，但是用户代码无法读取；</li>
<li><code>preempt</code>：抢占标志；</li>
<li><strong><code>lockedm</code></strong>：记录 G 被锁定的 M，实现 runtime.LockOSThread()</li>
</ul>
<p>其中 g.sched 是一个非常重要的结构，需要看一下其 <strong><code>gobuf</code></strong> 的实现（runtime/runtime2.go）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">gobuf</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="c1">// The offsets of sp, pc, and g are known to (hard-coded in) libmach.
</span><span class="c1"></span>        <span class="c1">//
</span><span class="c1"></span>        <span class="c1">// ctxt is unusual with respect to GC: it may be a
</span><span class="c1"></span>        <span class="c1">// heap-allocated funcval, so GC needs to track it, but it
</span><span class="c1"></span>        <span class="c1">// needs to be set and cleared from assembly, where it&#39;s
</span><span class="c1"></span>        <span class="c1">// difficult to have write barriers. However, ctxt is really a
</span><span class="c1"></span>        <span class="c1">// saved, live register, and we only ever exchange it between
</span><span class="c1"></span>        <span class="c1">// the real register and the gobuf. Hence, we treat it as a
</span><span class="c1"></span>        <span class="c1">// root during stack scanning, which means assembly that saves
</span><span class="c1"></span>        <span class="c1">// and restores it doesn&#39;t need write barriers. It&#39;s still
</span><span class="c1"></span>        <span class="c1">// typed as a pointer so that any other writes from Go get
</span><span class="c1"></span>        <span class="c1">// write barriers.
</span><span class="c1"></span>        <span class="nx">sp</span>   <span class="kt">uintptr</span>
        <span class="nx">pc</span>   <span class="kt">uintptr</span>
        <span class="nx">g</span>    <span class="nx">guintptr</span>
        <span class="nx">ctxt</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
        <span class="nx">ret</span>  <span class="nx">sys</span><span class="p">.</span><span class="nx">Uintreg</span>
        <span class="err">…</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li><strong><code>sp</code></strong>：当前 G 的 SP 指针地址，在创建 G 时默认设置为 goexit 函数地址；</li>
<li><strong><code>pc</code></strong>：当前 G 的 PC 指针地址；</li>
<li><code>g</code>：gobuf 所属的 g 结构地址；</li>
<li><code>ret</code>：系统调用的返回值；</li>
</ul>
<h4 id="211-g-的状态">2.1.1 G 的状态</h4>
<p>目前 G 可能处于以下 9 种状态：</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>_Gidle</td>
<td>0</td>
<td>G 刚分配，并且还没有被初始化</td>
</tr>
<tr>
<td>_Grunnable</td>
<td>1</td>
<td>G 处于可运行队列中，但是并没有被执行</td>
</tr>
<tr>
<td>_Grunning</td>
<td>2</td>
<td>G 绑定了 M、P，不在可运行队列，并且可能正在执行</td>
</tr>
<tr>
<td>_Gsyscall</td>
<td>3</td>
<td>G 正在执行系统调用而阻塞，不在可运行队列上，绑定了 M，没有绑定 P</td>
</tr>
<tr>
<td>_Gwaiting</td>
<td>4</td>
<td>G 因为用户空间而阻塞，不在可运行队列，等待其他 G 唤醒，没有绑定 M、P</td>
</tr>
<tr>
<td>_Gdead</td>
<td>5</td>
<td>G 当前没有被使用，其 g 结构可以被复用</td>
</tr>
<tr>
<td>_Gcopystack</td>
<td>6</td>
<td>G 的栈正在被拷贝，没有执行，不再可运行队列</td>
</tr>
<tr>
<td>_Gpreempted</td>
<td>7</td>
<td>由于抢占而被阻塞，没有执行，等待唤醒</td>
</tr>
<tr>
<td>_Gscan</td>
<td>8</td>
<td>GC 正在扫描 G 的栈，可与其他状态同时存在</td>
</tr>
</tbody>
</table>
<p>其状态轮转如下图所示：








    <br><img src="/posts/language/golang/language/goroutine/img3.png"/>


</p>
<h4 id="212-g-的创建">2.1.2 G 的创建</h4>
<p>在代码中调用 go 语句时，编译器会将其翻译为 <code>newproc()</code> 调用，这也就是创建 G 的开端：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">newproc</span><span class="p">(</span><span class="nx">siz</span> <span class="kt">int32</span><span class="p">,</span> <span class="nx">fn</span> <span class="o">*</span><span class="nx">funcval</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">argp</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">fn</span><span class="p">),</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">)</span>
        <span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
        <span class="nx">pc</span> <span class="o">:=</span> <span class="nf">getcallerpc</span><span class="p">()</span>
        <span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
                <span class="c1">// 创建 g 结构
</span><span class="c1"></span>                <span class="nx">newg</span> <span class="o">:=</span> <span class="nf">newproc1</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span> <span class="nx">argp</span><span class="p">,</span> <span class="nx">siz</span><span class="p">,</span> <span class="nx">gp</span><span class="p">,</span> <span class="nx">pc</span><span class="p">)</span>

        <span class="c1">// 放入当前 P 或者全局可运行队列
</span><span class="c1"></span>        <span class="nx">_p_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
        <span class="nf">runqput</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="nx">newg</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>

        <span class="k">if</span> <span class="nx">mainStarted</span> <span class="p">{</span>
                <span class="nf">wakep</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="p">})</span>
<span class="p">}</span>

<span class="c1">// Create a new g in state _Grunnable, starting at fn, with narg bytes
</span><span class="c1">// of arguments starting at argp. callerpc is the address of the go
</span><span class="c1">// statement that created this. The caller is responsible for adding
</span><span class="c1">// the new g to the scheduler.
</span><span class="c1">//
</span><span class="c1">// This must run on the system stack because it&#39;s the continuation of
</span><span class="c1">// newproc, which cannot split the stack.
</span><span class="c1">//
</span><span class="c1">//go:systemstack
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">newproc1</span><span class="p">(</span><span class="nx">fn</span> <span class="o">*</span><span class="nx">funcval</span><span class="p">,</span> <span class="nx">argp</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">narg</span> <span class="kt">int32</span><span class="p">,</span> <span class="nx">callergp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">callerpc</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="o">*</span><span class="nx">g</span> <span class="p">{</span>
        <span class="c1">// 调用 go 语句的 G
</span><span class="c1"></span>        <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
        <span class="nx">siz</span> <span class="o">:=</span> <span class="nx">narg</span>
        <span class="nx">siz</span> <span class="p">=</span> <span class="p">(</span><span class="nx">siz</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&amp;^</span> <span class="mi">7</span>

        <span class="c1">// 从 P.gFree 获取一个可复用的 g 对象
</span><span class="c1"></span>        <span class="nx">_p_</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
        <span class="nx">newg</span> <span class="o">:=</span> <span class="nf">gfget</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
        
        <span class="c1">// 没有可复用的，重新分配一个 g 对象
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">newg</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="nx">newg</span> <span class="p">=</span> <span class="nf">malg</span><span class="p">(</span><span class="nx">_StackMin</span><span class="p">)</span>
                <span class="nf">casgstatus</span><span class="p">(</span><span class="nx">newg</span><span class="p">,</span> <span class="nx">_Gidle</span><span class="p">,</span> <span class="nx">_Gdead</span><span class="p">)</span>
                <span class="nf">allgadd</span><span class="p">(</span><span class="nx">newg</span><span class="p">)</span> <span class="c1">// publishes with a g-&gt;status of Gdead so GC scanner doesn&#39;t look at uninitialized stack.
</span><span class="c1"></span>        <span class="p">}</span>

        <span class="nx">totalSize</span> <span class="o">:=</span> <span class="mi">4</span><span class="o">*</span><span class="nx">sys</span><span class="p">.</span><span class="nx">RegSize</span> <span class="o">+</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">siz</span><span class="p">)</span> <span class="o">+</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">MinFrameSize</span> <span class="c1">// extra space in case of reads slightly beyond frame
</span><span class="c1"></span>        <span class="nx">totalSize</span> <span class="o">+=</span> <span class="o">-</span><span class="nx">totalSize</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nx">sys</span><span class="p">.</span><span class="nx">SpAlign</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>                  <span class="c1">// align to spAlign
</span><span class="c1"></span>        <span class="nx">sp</span> <span class="o">:=</span> <span class="nx">newg</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span> <span class="o">-</span> <span class="nx">totalSize</span>
        <span class="nx">spArg</span> <span class="o">:=</span> <span class="nx">sp</span>
        <span class="k">if</span> <span class="nx">usesLR</span> <span class="p">{</span>
                <span class="c1">// caller&#39;s LR
</span><span class="c1"></span>                <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">sp</span><span class="p">))</span> <span class="p">=</span> <span class="mi">0</span>
                <span class="nf">prepGoExitFrame</span><span class="p">(</span><span class="nx">sp</span><span class="p">)</span>
                <span class="nx">spArg</span> <span class="o">+=</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">MinFrameSize</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nx">narg</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="c1">// 
</span><span class="c1"></span>                <span class="nf">memmove</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">spArg</span><span class="p">),</span> <span class="nx">argp</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">narg</span><span class="p">))</span>
                <span class="c1">// This is a stack-to-stack copy. If write barriers
</span><span class="c1"></span>                <span class="c1">// are enabled and the source stack is grey (the
</span><span class="c1"></span>                <span class="c1">// destination is always black), then perform a
</span><span class="c1"></span>                <span class="c1">// barrier copy. We do this *after* the memmove
</span><span class="c1"></span>                <span class="c1">// because the destination stack may have garbage on
</span><span class="c1"></span>                <span class="c1">// it.
</span><span class="c1"></span>                <span class="k">if</span> <span class="nx">writeBarrier</span><span class="p">.</span><span class="nx">needed</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span><span class="p">.</span><span class="nx">gcscandone</span> <span class="p">{</span>
                        <span class="nx">f</span> <span class="o">:=</span> <span class="nf">findfunc</span><span class="p">(</span><span class="nx">fn</span><span class="p">.</span><span class="nx">fn</span><span class="p">)</span>
                        <span class="nx">stkmap</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">stackmap</span><span class="p">)(</span><span class="nf">funcdata</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">_FUNCDATA_ArgsPointerMaps</span><span class="p">))</span>
                        <span class="k">if</span> <span class="nx">stkmap</span><span class="p">.</span><span class="nx">nbit</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
                                <span class="c1">// We&#39;re in the prologue, so it&#39;s always stack map index 0.
</span><span class="c1"></span>                                <span class="nx">bv</span> <span class="o">:=</span> <span class="nf">stackmapdata</span><span class="p">(</span><span class="nx">stkmap</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                                <span class="nf">bulkBarrierBitmap</span><span class="p">(</span><span class="nx">spArg</span><span class="p">,</span> <span class="nx">spArg</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">bv</span><span class="p">.</span><span class="nx">n</span><span class="p">)</span><span class="o">*</span><span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">bv</span><span class="p">.</span><span class="nx">bytedata</span><span class="p">)</span>
                        <span class="p">}</span>
                <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// 初始化 G 的属性
</span><span class="c1"></span>        <span class="c1">// pc 指针的设置是一个比较关键的，将 goexit 地址保存在 sched 中，用于 G 函数结束后可以平滑执行 goexit
</span><span class="c1"></span>        <span class="nf">memclrNoHeapPointers</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">))</span>
        <span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sp</span> <span class="p">=</span> <span class="nx">sp</span>
        <span class="nx">newg</span><span class="p">.</span><span class="nx">stktopsp</span> <span class="p">=</span> <span class="nx">sp</span>
        <span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">pc</span> <span class="p">=</span> <span class="nf">funcPC</span><span class="p">(</span><span class="nx">goexit</span><span class="p">)</span> <span class="o">+</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PCQuantum</span> <span class="c1">// +PCQuantum so that previous instruction is in same function
</span><span class="c1"></span>        <span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">g</span> <span class="p">=</span> <span class="nf">guintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">newg</span><span class="p">))</span>
        <span class="nf">gostartcallfn</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">,</span> <span class="nx">fn</span><span class="p">)</span>
        <span class="nx">newg</span><span class="p">.</span><span class="nx">gopc</span> <span class="p">=</span> <span class="nx">callerpc</span>
        <span class="nx">newg</span><span class="p">.</span><span class="nx">ancestors</span> <span class="p">=</span> <span class="nf">saveAncestors</span><span class="p">(</span><span class="nx">callergp</span><span class="p">)</span>
        <span class="nx">newg</span><span class="p">.</span><span class="nx">startpc</span> <span class="p">=</span> <span class="nx">fn</span><span class="p">.</span><span class="nx">fn</span>
        
        <span class="c1">// G 由 _Gdead -&gt; _Grunnable
</span><span class="c1"></span>        <span class="nf">casgstatus</span><span class="p">(</span><span class="nx">newg</span><span class="p">,</span> <span class="nx">_Gdead</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>

        <span class="k">return</span> <span class="nx">newg</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>构建 G 对应的 g 结构；
<ol>
<li>尝试<strong>从 <code>P.gFree</code> 链表中获取</strong> _GDead 的 G。如果没有，走 <code>mlag()</code> <strong>分配一个新的 g</strong>；</li>
<li>拷贝 fn 函数的所有参数到栈上；</li>
<li>设置 g 的属性（比较关键的就是 g.sched 属性），可以看到<strong>将 g.sched.sp 设置为了 goexit 函数的地址，这在调度循环中至关重要</strong>；</li>
<li>G 状态由 _GDead -&gt; _Grunnable；</li>
</ol>
</li>
<li><code>runqput()</code> 将新的 <strong>G 放入 P 或者全局的可运行队列</strong>；</li>
</ol>
<h4 id="213-g-上下文的保存">2.1.3 G 上下文的保存</h4>
<p>在切换 G 之间，一个必要的操作就是将 G 的 PC/SP 指针保存到 <code>g.sched</code> 中，在源码中有两个函数负责这个行为。</p>
<p><strong><code>mcall()</code></strong> 用于在 runtime 运行期间，将一个 M 绑定的 G 切换。<strong>它将 M 切换到 g0 栈，然后执行 G 上下文的保存</strong>，其实现是一段汇编代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// func mcall(fn func(*g))
</span><span class="c1">// Switch to m-&gt;g0&#39;s stack, call fn(g).
</span><span class="c1">// Fn must never return. It should gogo(&amp;g-&gt;sched)
</span><span class="c1">// to keep running g.
</span><span class="c1"></span><span class="nx">TEXT</span> <span class="nx">runtime</span><span class="err">·</span><span class="nf">mcall</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">NOSPLIT</span><span class="p">,</span> <span class="err">$</span><span class="mi">0</span><span class="o">-</span><span class="mi">8</span>
	        <span class="nx">MOVQ</span>        <span class="nx">fn</span><span class="o">+</span><span class="mi">0</span><span class="p">(</span><span class="nx">FP</span><span class="p">),</span> <span class="nx">DI</span>

	        <span class="nf">get_tls</span><span class="p">(</span><span class="nx">CX</span><span class="p">)</span>
	        <span class="nx">MOVQ</span>        <span class="nf">g</span><span class="p">(</span><span class="nx">CX</span><span class="p">),</span> <span class="nx">AX</span>        <span class="c1">// save state in g-&gt;sched
</span><span class="c1"></span>	        <span class="nx">MOVQ</span>        <span class="mi">0</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">BX</span>        <span class="c1">// caller&#39;s PC
</span><span class="c1"></span>	        <span class="nx">MOVQ</span>        <span class="nx">BX</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_pc</span><span class="p">)(</span><span class="nx">AX</span><span class="p">)</span>
	        <span class="nx">LEAQ</span>        <span class="nx">fn</span><span class="o">+</span><span class="mi">0</span><span class="p">(</span><span class="nx">FP</span><span class="p">),</span> <span class="nx">BX</span>        <span class="c1">// caller&#39;s SP
</span><span class="c1"></span>	        <span class="nx">MOVQ</span>        <span class="nx">BX</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_sp</span><span class="p">)(</span><span class="nx">AX</span><span class="p">)</span>
	        <span class="nx">MOVQ</span>        <span class="nx">AX</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_g</span><span class="p">)(</span><span class="nx">AX</span><span class="p">)</span>
	        <span class="nx">MOVQ</span>        <span class="nx">BP</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_bp</span><span class="p">)(</span><span class="nx">AX</span><span class="p">)</span>

	        <span class="c1">// switch to m-&gt;g0 &amp; its stack, call fn
</span><span class="c1"></span>	        <span class="nx">MOVQ</span>        <span class="nf">g</span><span class="p">(</span><span class="nx">CX</span><span class="p">),</span> <span class="nx">BX</span>
	        <span class="nx">MOVQ</span>        <span class="nf">g_m</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">BX</span>
	        <span class="nx">MOVQ</span>        <span class="nf">m_g0</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">SI</span>
	        <span class="nx">CMPQ</span>        <span class="nx">SI</span><span class="p">,</span> <span class="nx">AX</span>        <span class="c1">// if g == m-&gt;g0 call badmcall
</span><span class="c1"></span>	        <span class="nx">JNE</span>        <span class="mi">3</span><span class="p">(</span><span class="nx">PC</span><span class="p">)</span>
	        <span class="nx">MOVQ</span>        <span class="err">$</span><span class="nx">runtime</span><span class="err">·</span><span class="nf">badmcall</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">AX</span>
	        <span class="nx">JMP</span>        <span class="nx">AX</span>
	        <span class="nx">MOVQ</span>        <span class="nx">SI</span><span class="p">,</span> <span class="nf">g</span><span class="p">(</span><span class="nx">CX</span><span class="p">)</span>        <span class="c1">// g = m-&gt;g0
</span><span class="c1"></span>	        <span class="nf">MOVQ</span>        <span class="p">(</span><span class="nx">g_sched</span><span class="o">+</span><span class="nx">gobuf_sp</span><span class="p">)(</span><span class="nx">SI</span><span class="p">),</span> <span class="nx">SP</span>        <span class="c1">// sp = m-&gt;g0-&gt;sched.sp
</span><span class="c1"></span>	        <span class="nx">PUSHQ</span>        <span class="nx">AX</span>
	        <span class="nx">MOVQ</span>        <span class="nx">DI</span><span class="p">,</span> <span class="nx">DX</span>
	        <span class="nx">MOVQ</span>        <span class="mi">0</span><span class="p">(</span><span class="nx">DI</span><span class="p">),</span> <span class="nx">DI</span>
	        <span class="nx">CALL</span>        <span class="nx">DI</span>
	        <span class="nx">POPQ</span>        <span class="nx">AX</span>
	        <span class="nx">MOVQ</span>        <span class="err">$</span><span class="nx">runtime</span><span class="err">·</span><span class="nf">badmcall2</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">AX</span>
	        <span class="nx">JMP</span>        <span class="nx">AX</span>
	                <span class="nx">RET</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li><strong>保存当前的 SP、PC 至 <code>g.sched</code> 属性中</strong>；</li>
<li><strong>切换到 m.g0 栈，执行传入的函数</strong>；</li>
</ol>
<p><code>save()</code> 用于 G 进入系统调用阻塞前，保存 G 的上下文，<strong>用于系统调用结束后，进行相关信息的恢复</strong>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">save</span><span class="p">(</span><span class="nx">pc</span><span class="p">,</span> <span class="nx">sp</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

        <span class="nx">_g_</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">pc</span> <span class="p">=</span> <span class="nx">pc</span>
        <span class="nx">_g_</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sp</span> <span class="p">=</span> <span class="nx">sp</span>
        <span class="nx">_g_</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lr</span> <span class="p">=</span> <span class="mi">0</span>
        <span class="nx">_g_</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">ret</span> <span class="p">=</span> <span class="mi">0</span>
        <span class="nx">_g_</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">g</span> <span class="p">=</span> <span class="nf">guintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">_g_</span><span class="p">))</span>
        <span class="c1">// We need to ensure ctxt is zero, but can&#39;t have a write
</span><span class="c1"></span>        <span class="c1">// barrier here. However, it should always already be zero.
</span><span class="c1"></span>        <span class="c1">// Assert that.
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">ctxt</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="nf">badctxt</span><span class="p">()</span>
        <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="22-m">2.2 M</h3>
<p>M 代表的就是一个操作系统线程，由 <strong><code>m 结构</code></strong> 表示（runtime/runtime2.go）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">m</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">g0</span>      <span class="o">*</span><span class="nx">g</span>     <span class="c1">// goroutine with scheduling stack
</span><span class="c1"></span>        
        <span class="nx">gsignal</span>       <span class="o">*</span><span class="nx">g</span>           <span class="c1">// signal-handling g
</span><span class="c1"></span>        <span class="nx">goSigStack</span>    <span class="nx">gsignalStack</span> <span class="c1">// Go-allocated signal handling stack
</span><span class="c1"></span>        
        <span class="nx">curg</span>          <span class="o">*</span><span class="nx">g</span>       <span class="c1">// current running goroutine
</span><span class="c1"></span>        
        <span class="nx">p</span>             <span class="nx">puintptr</span> <span class="c1">// attached p for executing go code (nil if not executing go code)
</span><span class="c1"></span>        <span class="nx">nextp</span>         <span class="nx">puintptr</span>
        <span class="nx">oldp</span>          <span class="nx">puintptr</span> <span class="c1">// the p that was attached before executing a syscall
</span><span class="c1"></span>        <span class="nx">id</span>            <span class="kt">int64</span>
        
        <span class="nx">lockedg</span>       <span class="nx">guintptr</span>
        <span class="nx">lockedExt</span>     <span class="kt">uint32</span>      <span class="c1">// tracking for external LockOSThread
</span><span class="c1"></span>        <span class="nx">lockedInt</span>     <span class="kt">uint32</span>      <span class="c1">// tracking for internal lockOSThread
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li><strong><code>g0</code></strong> : M 私有的 g0；</li>
<li><code>gsignal</code> ：用于处理操作系统信号的 G；</li>
<li><strong><code>curg</code></strong> ：当前 M 正在执行的 G；</li>
<li><strong><code>p</code></strong> : 当前 M 绑定的 P；</li>
<li><code>nextp</code> ：暂存的 nextp；</li>
<li><code>oldp</code> ：M 陷入系统调用前绑定的 P，用于系统调用结束后尝试重新绑定；</li>
<li><code>id</code> ：m 的 ID；</li>
<li><strong><code>lockedg</code></strong> ：保存 M 锁定的 G，实现 runtime.LockOSThread()；</li>
</ul>
<h4 id="221-m-的创建">2.2.1 M 的创建</h4>
<p>在创建 G 或者其他地方，当 G 变为 runnable 后，就会调用 <code>wakep()</code> 触发一次 P 执行 G 的过程。其会调用 <code>startm()</code> <strong>选择/创建 一个 M 绑定 P</strong>，并执行一个 G。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Tries to add one more P to execute G&#39;s.
</span><span class="c1">// Called when a G is made runnable (newproc, ready).
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">wakep</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">npidle</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="k">return</span>
        <span class="p">}</span>
        <span class="nf">startm</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Schedules some M to run the p (creates an M if necessary).
</span><span class="c1">// If p==nil, tries to get an idle P, if no idle P&#39;s does nothing.
</span><span class="c1">// May run with m.p==nil, so write barriers are not allowed.
</span><span class="c1">// If spinning is set, the caller has incremented nmspinning and startm will
</span><span class="c1">// either decrement nmspinning or set m.spinning in the newly started M.
</span><span class="c1">//go:nowritebarrierrec
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">startm</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">spinning</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 选择一个空闲的 P
</span><span class="c1"></span>        <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">_p_</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="nx">_p_</span> <span class="p">=</span> <span class="nf">pidleget</span><span class="p">()</span>
                <span class="k">if</span> <span class="nx">_p_</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
                        <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
                        <span class="k">return</span>
                <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="c1">// 选择一个空闲的 M
</span><span class="c1"></span>        <span class="nx">mp</span> <span class="o">:=</span> <span class="nf">mget</span><span class="p">()</span>
        <span class="k">if</span> <span class="nx">mp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="c1">// No M is available, we must drop sched.lock and call newm.
</span><span class="c1"></span>                <span class="c1">// However, we already own a P to assign to the M.
</span><span class="c1"></span>                <span class="c1">//
</span><span class="c1"></span>                <span class="c1">// Once sched.lock is released, another G (e.g., in a syscall),
</span><span class="c1"></span>                <span class="c1">// could find no idle P while checkdead finds a runnable G but
</span><span class="c1"></span>                <span class="c1">// no running M&#39;s because this new M hasn&#39;t started yet, thus
</span><span class="c1"></span>                <span class="c1">// throwing in an apparent deadlock.
</span><span class="c1"></span>                <span class="c1">//
</span><span class="c1"></span>                <span class="c1">// Avoid this situation by pre-allocating the ID for the new M,
</span><span class="c1"></span>                <span class="c1">// thus marking it as &#39;running&#39; before we drop sched.lock. This
</span><span class="c1"></span>                <span class="c1">// new M will eventually run the scheduler to execute any
</span><span class="c1"></span>                <span class="c1">// queued G&#39;s.
</span><span class="c1"></span>                <span class="nx">id</span> <span class="o">:=</span> <span class="nf">mReserveID</span><span class="p">()</span>
                <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

        <span class="kd">var</span> <span class="nx">fn</span> <span class="kd">func</span><span class="p">()</span>
        <span class="k">if</span> <span class="nx">spinning</span> <span class="p">{</span>
                <span class="c1">// The caller incremented nmspinning, so set m.spinning in the new M.
</span><span class="c1"></span>                <span class="nx">fn</span> <span class="p">=</span> <span class="nx">mspinning</span>
        <span class="p">}</span>
        <span class="c1">// 创建一个 M
</span><span class="c1"></span>        <span class="nf">newm</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span> <span class="nx">_p_</span><span class="p">,</span> <span class="nx">id</span><span class="p">)</span>
        <span class="k">return</span>
        <span class="p">}</span>
        <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
        
        <span class="c1">// The caller incremented nmspinning, so set m.spinning in the new M.
</span><span class="c1"></span>        <span class="nx">mp</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">=</span> <span class="nx">spinning</span>
        <span class="nx">mp</span><span class="p">.</span><span class="nx">nextp</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
        <span class="nf">notewakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mp</span><span class="p">.</span><span class="nx">park</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>当存在空闲的 P，但是没有空闲的 M 时，就会调用 <code>newm()</code> 创建一个 M；</li>
</ul>
<p><code>newm()</code> 就是<strong>创建 m 结构，以及启动系统线程的地方</strong>（runtime/proc.go）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Create a new m. It will start off with a call to fn, or else the scheduler.
</span><span class="c1">// fn needs to be static and not a heap allocated closure.
</span><span class="c1">// May run with m.p==nil, so write barriers are not allowed.
</span><span class="c1">//
</span><span class="c1">// id is optional pre-allocated m ID. Omit by passing -1.
</span><span class="c1">//go:nowritebarrierrec
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">newm</span><span class="p">(</span><span class="nx">fn</span> <span class="kd">func</span><span class="p">(),</span> <span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">id</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 分配 m 对象（复用 sched.freem 或者新创建）
</span><span class="c1"></span>        <span class="nx">mp</span> <span class="o">:=</span> <span class="nf">allocm</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="nx">fn</span><span class="p">,</span> <span class="nx">id</span><span class="p">)</span>
        <span class="nx">mp</span><span class="p">.</span><span class="nx">nextp</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
        <span class="nx">mp</span><span class="p">.</span><span class="nx">sigmask</span> <span class="p">=</span> <span class="nx">initSigmask</span>
        
        <span class="err">…</span>
        <span class="nf">newm1</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">newm1</span><span class="p">(</span><span class="nx">mp</span> <span class="o">*</span><span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
        <span class="err">…</span>
        <span class="nx">execLock</span><span class="p">.</span><span class="nf">rlock</span><span class="p">()</span> <span class="c1">// Prevent process clone.
</span><span class="c1"></span>        <span class="nf">newosproc</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
        <span class="nx">execLock</span><span class="p">.</span><span class="nf">runlock</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// May run with m.p==nil, so write barriers are not allowed.
</span><span class="c1">//go:nowritebarrier
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">newosproc</span><span class="p">(</span><span class="nx">mp</span> <span class="o">*</span><span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">stk</span> <span class="o">:=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">mp</span><span class="p">.</span><span class="nx">g0</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span><span class="p">)</span>
        
        <span class="c1">// 给 thread 初始的栈来自于 g0
</span><span class="c1"></span>        <span class="c1">// Disable signals during clone, so that the new thread starts
</span><span class="c1"></span>        <span class="c1">// with signals disabled. It will enable them in minit.
</span><span class="c1"></span>        <span class="kd">var</span> <span class="nx">oset</span> <span class="nx">sigset</span>
        <span class="nf">sigprocmask</span><span class="p">(</span><span class="nx">_SIG_SETMASK</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">sigset_all</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">oset</span><span class="p">)</span>
        <span class="nx">ret</span> <span class="o">:=</span> <span class="nf">clone</span><span class="p">(</span><span class="nx">cloneFlags</span><span class="p">,</span> <span class="nx">stk</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">mp</span><span class="p">),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">mp</span><span class="p">.</span><span class="nx">g0</span><span class="p">),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nf">funcPC</span><span class="p">(</span><span class="nx">mstart</span><span class="p">)))</span>
        <span class="nf">sigprocmask</span><span class="p">(</span><span class="nx">_SIG_SETMASK</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">oset</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>

        <span class="k">if</span> <span class="nx">ret</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;newosproc&#34;</span><span class="p">)</span>
        <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>获取 m 对象，来自于 <code>sched.freem</code> 或者新创建一个；</li>
<li>通过 <code>clone()</code> 系统调用创建一个系统线程，执行的函数为 <code>mstart()</code>；</li>
</ol>
<p>看一下 clone 的 flags：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="p">(</span>
        <span class="nx">cloneFlags</span> <span class="p">=</span> <span class="nx">_CLONE_VM</span> <span class="p">|</span> <span class="cm">/* share memory */</span>
                <span class="nx">_CLONE_FS</span> <span class="p">|</span> <span class="cm">/* share cwd, etc */</span>
                <span class="nx">_CLONE_FILES</span> <span class="p">|</span> <span class="cm">/* share fd table */</span>
                <span class="nx">_CLONE_SIGHAND</span> <span class="p">|</span> <span class="cm">/* share sig handler table */</span>
                <span class="nx">_CLONE_SYSVSEM</span> <span class="p">|</span> <span class="cm">/* share SysV semaphore undo lists (see issue #20763) */</span>
                <span class="nx">_CLONE_THREAD</span> <span class="cm">/* revisit - okay for now */</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="222-m-的启动">2.2.2 M 的启动</h4>
<p>前面看到，M 线程启动后执行 <code>mstart()</code> 函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mstart</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

        <span class="c1">// 确定栈边界
</span><span class="c1"></span>        <span class="nx">osStack</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="nx">osStack</span> <span class="p">{</span>
                <span class="c1">// Initialize stack bounds from system stack.
</span><span class="c1"></span>                <span class="c1">// Cgo may have left stack size in stack.hi.
</span><span class="c1"></span>                <span class="c1">// minit may update the stack bounds.
</span><span class="c1"></span>                <span class="nx">size</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span>
                <span class="k">if</span> <span class="nx">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                        <span class="nx">size</span> <span class="p">=</span> <span class="mi">8192</span> <span class="o">*</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">StackGuardMultiplier</span>
                <span class="p">}</span>
                <span class="nx">_g_</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nf">noescape</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">size</span><span class="p">)))</span>
                <span class="nx">_g_</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="p">=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span> <span class="o">-</span> <span class="nx">size</span> <span class="o">+</span> <span class="mi">1024</span>
        <span class="p">}</span>
        <span class="nx">_g_</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">+</span> <span class="nx">_StackGuard</span>
        <span class="nx">_g_</span><span class="p">.</span><span class="nx">stackguard1</span> <span class="p">=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">stackguard0</span>
        
        <span class="c1">// 准备进入调度循环
</span><span class="c1"></span>        <span class="nf">mstart1</span><span class="p">()</span>

        <span class="c1">// 线程退出
</span><span class="c1"></span>        <span class="c1">// Exit this thread.
</span><span class="c1"></span>        <span class="k">switch</span> <span class="nx">GOOS</span> <span class="p">{</span>
        <span class="k">case</span> <span class="s">&#34;windows&#34;</span><span class="p">,</span> <span class="s">&#34;solaris&#34;</span><span class="p">,</span> <span class="s">&#34;illumos&#34;</span><span class="p">,</span> <span class="s">&#34;plan9&#34;</span><span class="p">,</span> <span class="s">&#34;darwin&#34;</span><span class="p">,</span> <span class="s">&#34;aix&#34;</span><span class="p">:</span>
                <span class="nx">osStack</span> <span class="p">=</span> <span class="kc">true</span>
        <span class="p">}</span>
        <span class="nf">mexit</span><span class="p">(</span><span class="nx">osStack</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">mstart1</span><span class="p">()</span> <span class="p">{</span>
	    <span class="c1">// 这是 g0
</span><span class="c1"></span>        <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

        <span class="c1">// Record the caller for use as the top of stack in mcall and
</span><span class="c1"></span>        <span class="c1">// for terminating the thread.
</span><span class="c1"></span>        <span class="c1">// We&#39;re never coming back to mstart1 after we call schedule,
</span><span class="c1"></span>        <span class="c1">// so other calls can reuse the current frame.
</span><span class="c1"></span>        <span class="nf">save</span><span class="p">(</span><span class="nf">getcallerpc</span><span class="p">(),</span> <span class="nf">getcallersp</span><span class="p">())</span>
        <span class="nf">asminit</span><span class="p">()</span>
        <span class="nf">minit</span><span class="p">()</span>

        <span class="c1">// m0 需要的信号初始化工作
</span><span class="c1"></span>        <span class="c1">// Install signal handlers; after minit so that minit can
</span><span class="c1"></span>        <span class="c1">// prepare the thread to be able to handle the signals.
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span> <span class="o">==</span> <span class="o">&amp;</span><span class="nx">m0</span> <span class="p">{</span>
                <span class="nf">mstartm0</span><span class="p">()</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="nx">fn</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">mstartfn</span><span class="p">;</span> <span class="nx">fn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="nf">fn</span><span class="p">()</span>
        <span class="p">}</span>

        <span class="c1">// 绑定前面存下的 P
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="nx">m0</span> <span class="p">{</span>
                <span class="nf">acquirep</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">nextp</span><span class="p">.</span><span class="nf">ptr</span><span class="p">())</span>
                <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">nextp</span> <span class="p">=</span> <span class="mi">0</span>
        <span class="p">}</span>
        
        <span class="c1">// 进入调度循环，不再返回
</span><span class="c1"></span>        <span class="nf">schedule</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上面的关键就是，<strong>M 最后绑定 P，调用 schedule() 进入调度循环</strong>，并且不会再返回。
<div class="details admonition tip open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-lightbulb fa-fw" aria-hidden="true"></i>m0<i class="details-icon fas fa-angle-right fa-fw" aria-hidden="true"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">m0 是程序启动的 main M</div>
        </div>
    </div></p>
<h4 id="223-m-的退出">2.2.3 M 的退出</h4>
<p>前面 <code>mexit()</code> 就是用于<strong>释放 M 资源，m 结构记录在 <code>sched.freem</code>，并使得线程退出</strong>。</p>
<p>但是，M 进入调度循环后，就不会返回了，所以需要使用调用 g0 保存的栈帧实现。</p>
<p>当然，M 线程退出只是在特定的场景（见 <a href="#33-goexit" rel=""><strong>goexit()</strong></a>）会出现：调用 <code>runtime.LockOSThread()</code> 锁定 M 后，没有调用 <code>runtime.UnlockOSThread()</code> 解锁， G 用户函数执行完毕后退出，M 对应线程退出。</p>
<div class="details admonition note open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-pencil-alt fa-fw" aria-hidden="true"></i>线程是否会减少<i class="details-icon fas fa-angle-right fa-fw" aria-hidden="true"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">Linux 上 go 进程的线程数量可能减少，当你调用 LockOSThread() 而没有解锁，执行完 groutine 代码后，对应线程会退出。</div>
        </div>
    </div>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// mexit tears down and exits the current thread.
</span><span class="c1">//
</span><span class="c1">// Don&#39;t call this directly to exit the thread, since it must run at
</span><span class="c1">// the top of the thread stack. Instead, use gogo(&amp;_g_.m.g0.sched) to
</span><span class="c1">// unwind the stack to the point that exits the thread.
</span><span class="c1">//
</span><span class="c1">// It is entered with m.p != nil, so write barriers are allowed. It
</span><span class="c1">// will release the P before exiting.
</span><span class="c1">//
</span><span class="c1">//go:yeswritebarrierrec
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">mexit</span><span class="p">(</span><span class="nx">osStack</span> <span class="kt">bool</span><span class="p">)</span> 
</code></pre></td></tr></table>
</div>
</div><h4 id="224-m-与-g-的锁定">2.2.4 M 与 G 的锁定</h4>
<p>通过 <code>runtime.LockOSThread()</code> 与 <code>runtime.UnlockOSThread()</code> 实现将 M 与 G 的锁定与解锁。</p>
<p>锁定后，该 M 只能执行锁定的 G，并且不会执行其他的 G 与被调度。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">LockOSThread</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">newmHandoff</span><span class="p">.</span><span class="nx">haveTemplateThread</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">GOOS</span> <span class="o">!=</span> <span class="s">&#34;plan9&#34;</span> <span class="p">{</span>
                <span class="c1">// If we need to start a new thread from the locked
</span><span class="c1"></span>                <span class="c1">// thread, we need the template thread. Start it now
</span><span class="c1"></span>                <span class="c1">// while we&#39;re in a known-good state.
</span><span class="c1"></span>                <span class="nf">startTemplateThread</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
        <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedExt</span><span class="o">++</span>
        <span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedExt</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedExt</span><span class="o">--</span>
                <span class="nb">panic</span><span class="p">(</span><span class="s">&#34;LockOSThread nesting overflow&#34;</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nf">dolockOSThread</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">dolockOSThread</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">GOARCH</span> <span class="o">==</span> <span class="s">&#34;wasm&#34;</span> <span class="p">{</span>
                <span class="k">return</span> <span class="c1">// no threads on wasm yet
</span><span class="c1"></span>        <span class="p">}</span>
        <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
        <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedg</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">_g_</span><span class="p">)</span>
        <span class="nx">_g_</span><span class="p">.</span><span class="nx">lockedm</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>将 G 记录在 <code>m.lockedg</code>，将 M 记录在 <code>g.lockedm</code> 实现了 M 与 G 的映射关系，实现锁定的功能。</p>
<h3 id="23-p">2.3 P</h3>
<p>P 是 M 与 G 的中间层，没有了 P，M 与 G 实际上就是一个线程池。<strong>通过 P 来分片所有可运行的 G，使得运行效率更加的高</strong>。</p>
<p><strong><code>p</code></strong> 是 P 的结构体表示（runtime/runtime2.go）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">p</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">id</span>          <span class="kt">int32</span>
        <span class="nx">status</span>      <span class="kt">uint32</span> <span class="c1">// one of pidle/prunning/...
</span><span class="c1"></span>        
        <span class="nx">m</span>           <span class="nx">muintptr</span>   <span class="c1">// back-link to associated m (nil if idle)
</span><span class="c1"></span>        <span class="nx">mcache</span>      <span class="o">*</span><span class="nx">mcache</span>
        <span class="nx">pcache</span>      <span class="nx">pageCache</span>

        <span class="c1">// Queue of runnable goroutines. Accessed without lock.
</span><span class="c1"></span>        <span class="nx">runqhead</span> <span class="kt">uint32</span>
        <span class="nx">runqtail</span> <span class="kt">uint32</span>
        <span class="nx">runq</span>     <span class="p">[</span><span class="mi">256</span><span class="p">]</span><span class="nx">guintptr</span>
        <span class="c1">// runnext, if non-nil, is a runnable G that was ready&#39;d by
</span><span class="c1"></span>        <span class="c1">// the current G and should be run next instead of what&#39;s in
</span><span class="c1"></span>        <span class="c1">// runq if there&#39;s time remaining in the running G&#39;s time
</span><span class="c1"></span>        <span class="c1">// slice. It will inherit the time left in the current time
</span><span class="c1"></span>        <span class="c1">// slice. If a set of goroutines is locked in a
</span><span class="c1"></span>        <span class="c1">// communicate-and-wait pattern, this schedules that set as a
</span><span class="c1"></span>        <span class="c1">// unit and eliminates the (potentially large) scheduling
</span><span class="c1"></span>        <span class="c1">// latency that otherwise arises from adding the ready&#39;d
</span><span class="c1"></span>        <span class="c1">// goroutines to the end of the run queue.
</span><span class="c1"></span>        <span class="nx">runnext</span> <span class="nx">guintptr</span>

        <span class="c1">// Available G&#39;s (status == Gdead)
</span><span class="c1"></span>        <span class="nx">gFree</span> <span class="kd">struct</span> <span class="p">{</span>
                <span class="nx">gList</span>
                <span class="nx">n</span> <span class="kt">int32</span>
        <span class="p">}</span>

        <span class="nx">sudogcache</span> <span class="p">[]</span><span class="o">*</span><span class="nx">sudog</span>
        <span class="nx">sudogbuf</span>   <span class="p">[</span><span class="mi">128</span><span class="p">]</span><span class="o">*</span><span class="nx">sudog</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li><code>status</code> ：P 的状态；</li>
<li><strong><code>m</code></strong> ：当前绑定的 M；</li>
<li><code>mcache</code> ：P 唯一的 mcache，将【内存管理】；</li>
<li><code>runqhead</code> ：P 的可运行队列的 head index；</li>
<li><code>runqtail</code> ：P 的可以行队列的 tail index；</li>
<li><strong><code>runq</code></strong> ：P 的可运行队列，可以看到大小为 256；</li>
<li><code>runnext</code>  ：下一次优先执行的 G，优先级高于 runq；</li>
<li><strong><code>gFree</code></strong> ：可复用的 g 结构链表；</li>
</ul>
<p>P 还包含大量与 GC 内存管理相关的字段，这里暂时省略。</p>
<h4 id="231-p-的状态">2.3.1 P 的状态</h4>
<table>
<thead>
<tr>
<th>状态</th>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>_Pidle</td>
<td>0</td>
<td>P 没有任何 G 可以执行，被空闲 P 链表持有着</td>
</tr>
<tr>
<td>_Prunning</td>
<td>1</td>
<td>P 绑定了一个 M，并且正在执行 G</td>
</tr>
<tr>
<td>_Psyscall</td>
<td>2</td>
<td>P 绑定了 M，但是 M 陷入系统调用阻塞，P 可以被其他 M 获取</td>
</tr>
<tr>
<td>_Pgcstop</td>
<td>3</td>
<td>P 绑定着 M，但是因为 STW 挂起</td>
</tr>
<tr>
<td>_Pdead</td>
<td>4</td>
<td>P 不在被使用，由于 GOMAXPROCS 缩小</td>
</tr>
</tbody>
</table>
<p>可以看到，_Pidle 与 _Psyscall 都属于 P 可以被其他 M 绑定的状态。</p>
<h4 id="232-p-的创建销毁">2.3.2 P 的创建/销毁</h4>
<p>前面可以看到，G 是由 <code>go</code> 命令创建的，而 M 是按需创建的。P 的创建不同，因为其代表的是并发个数，所以其创建是<strong>在程序启动时创建</strong>。</p>
<p>在执行用户 main 函数之间的 <code>scheinit()</code> 中进行 runtime 的初始化，其中一项就是初始化 P:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// The bootstrap sequence is:
</span><span class="c1">//
</span><span class="c1">//        call osinit
</span><span class="c1">//        call schedinit
</span><span class="c1">//        make &amp; queue new G
</span><span class="c1">//        call runtime·mstart
</span><span class="c1">//
</span><span class="c1">// The new G calls runtime·main.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">schedinit</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// …
</span><span class="c1"></span>
        <span class="nx">procs</span> <span class="o">:=</span> <span class="nx">ncpu</span>
        <span class="k">if</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nf">atoi32</span><span class="p">(</span><span class="nf">gogetenv</span><span class="p">(</span><span class="s">&#34;GOMAXPROCS&#34;</span><span class="p">));</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="nx">procs</span> <span class="p">=</span> <span class="nx">n</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nf">procresize</span><span class="p">(</span><span class="nx">procs</span><span class="p">)</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;unknown runnable goroutine during bootstrap&#34;</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="c1">// …
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>procresize()</code> 用于改变 P 的数量（runtime/proc.go）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span><span class="lnt">94
</span><span class="lnt">95
</span><span class="lnt">96
</span><span class="lnt">97
</span><span class="lnt">98
</span><span class="lnt">99
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Change number of processors. The world is stopped, sched is locked.
</span><span class="c1">// gcworkbufs are not being modified by either the GC or
</span><span class="c1">// the write barrier code.
</span><span class="c1">// Returns list of Ps with local work, they need to be scheduled by the caller.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">procresize</span><span class="p">(</span><span class="nx">nprocs</span> <span class="kt">int32</span><span class="p">)</span> <span class="o">*</span><span class="nx">p</span> <span class="p">{</span>
        <span class="nx">old</span> <span class="o">:=</span> <span class="nx">gomaxprocs</span>
        
        <span class="c1">// 扩大 P 的数量
</span><span class="c1"></span>        <span class="c1">// Grow allp if necessary.
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">nprocs</span> <span class="p">&gt;</span> <span class="nb">int32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">allp</span><span class="p">))</span> <span class="p">{</span>
                <span class="c1">// Synchronize with retake, which could be running
</span><span class="c1"></span>                <span class="c1">// concurrently since it doesn&#39;t run on a P.
</span><span class="c1"></span>                <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allpLock</span><span class="p">)</span>
                <span class="k">if</span> <span class="nx">nprocs</span> <span class="o">&lt;=</span> <span class="nb">int32</span><span class="p">(</span><span class="nb">cap</span><span class="p">(</span><span class="nx">allp</span><span class="p">))</span> <span class="p">{</span>
                        <span class="nx">allp</span> <span class="p">=</span> <span class="nx">allp</span><span class="p">[:</span><span class="nx">nprocs</span><span class="p">]</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="nx">nallp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">nprocs</span><span class="p">)</span>
                        <span class="c1">// Copy everything up to allp&#39;s cap so we
</span><span class="c1"></span>                        <span class="c1">// never lose old allocated Ps.
</span><span class="c1"></span>                        <span class="nb">copy</span><span class="p">(</span><span class="nx">nallp</span><span class="p">,</span> <span class="nx">allp</span><span class="p">[:</span><span class="nb">cap</span><span class="p">(</span><span class="nx">allp</span><span class="p">)])</span>
                        <span class="nx">allp</span> <span class="p">=</span> <span class="nx">nallp</span>
                <span class="p">}</span>
                <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allpLock</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="c1">// 初始化新的 P
</span><span class="c1"></span>        <span class="c1">// initialize new P&#39;s
</span><span class="c1"></span>        <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">old</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">nprocs</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
                <span class="nx">pp</span> <span class="o">:=</span> <span class="nx">allp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="nx">pp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
                        <span class="nx">pp</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
                <span class="p">}</span>
                <span class="nx">pp</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
                <span class="nf">atomicstorep</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allp</span><span class="p">[</span><span class="nx">i</span><span class="p">]),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">pp</span><span class="p">))</span>
        <span class="p">}</span>

        <span class="c1">// 如果当前 M 绑定的 P 是要被释放的，那么 M 新选取一个可用的 P
</span><span class="c1"></span>        <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
        <span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">id</span> <span class="p">&lt;</span> <span class="nx">nprocs</span> <span class="p">{</span>
                <span class="c1">// continue to use the current P
</span><span class="c1"></span>                <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">_Prunning</span>
                <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">mcache</span><span class="p">.</span><span class="nf">prepareForSweep</span><span class="p">()</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="c1">// release the current P and acquire allp[0].
</span><span class="c1"></span>                <span class="c1">//
</span><span class="c1"></span>                <span class="c1">// We must do this before destroying our current P
</span><span class="c1"></span>                <span class="c1">// because p.destroy itself has write barriers, so we
</span><span class="c1"></span>                <span class="c1">// need to do that from a valid P.
</span><span class="c1"></span>                <span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
                        <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">m</span> <span class="p">=</span> <span class="mi">0</span>
                <span class="p">}</span>
                <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="p">=</span> <span class="mi">0</span>
                <span class="nx">p</span> <span class="o">:=</span> <span class="nx">allp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="nx">p</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="mi">0</span>
                <span class="nx">p</span><span class="p">.</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">_Pidle</span>
                <span class="nf">acquirep</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
                <span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
                        <span class="nf">traceGoStart</span><span class="p">()</span>
                <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// g.m.p is now set, so we no longer need mcache0 for bootstrapping.
</span><span class="c1"></span>        <span class="nx">mcache0</span> <span class="p">=</span> <span class="kc">nil</span>

        <span class="c1">// 清理不使用的 P
</span><span class="c1"></span>        <span class="c1">// release resources from unused P&#39;s
</span><span class="c1"></span>        <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">nprocs</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">old</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
                <span class="nx">p</span> <span class="o">:=</span> <span class="nx">allp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
                <span class="nx">p</span><span class="p">.</span><span class="nf">destroy</span><span class="p">()</span>
                <span class="c1">// can&#39;t free P itself because it can be referenced by an M in syscall
</span><span class="c1"></span>        <span class="p">}</span>

        <span class="c1">// Trim allp.
</span><span class="c1"></span>        <span class="k">if</span> <span class="nb">int32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">allp</span><span class="p">))</span> <span class="o">!=</span> <span class="nx">nprocs</span> <span class="p">{</span>
                <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allpLock</span><span class="p">)</span>
                <span class="nx">allp</span> <span class="p">=</span> <span class="nx">allp</span><span class="p">[:</span><span class="nx">nprocs</span><span class="p">]</span>
                <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allpLock</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="kd">var</span> <span class="nx">runnablePs</span> <span class="o">*</span><span class="nx">p</span>
        <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">nprocs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
                <span class="nx">p</span> <span class="o">:=</span> <span class="nx">allp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span> <span class="o">==</span> <span class="nx">p</span> <span class="p">{</span>
                        <span class="k">continue</span>
                <span class="p">}</span>
                <span class="nx">p</span><span class="p">.</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">_Pidle</span>
                <span class="k">if</span> <span class="nf">runqempty</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
                        <span class="nf">pidleput</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="nx">p</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nf">mget</span><span class="p">())</span>
                        <span class="nx">p</span><span class="p">.</span><span class="nx">link</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">runnablePs</span><span class="p">)</span>
                        <span class="nx">runnablePs</span> <span class="p">=</span> <span class="nx">p</span>
                <span class="p">}</span>
        <span class="p">}</span>
        <span class="nx">stealOrder</span><span class="p">.</span><span class="nf">reset</span><span class="p">(</span><span class="nb">uint32</span><span class="p">(</span><span class="nx">nprocs</span><span class="p">))</span>
        <span class="kd">var</span> <span class="nx">int32p</span> <span class="o">*</span><span class="kt">int32</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">gomaxprocs</span> <span class="c1">// make compiler check that gomaxprocs is an int32
</span><span class="c1"></span>        <span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">((</span><span class="o">*</span><span class="kt">uint32</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">int32p</span><span class="p">)),</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">nprocs</span><span class="p">))</span>
        <span class="k">return</span> <span class="nx">runnablePs</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="233-p-数量调整">2.3.3 P 数量调整</h4>
<p>通过 <code>runtime.GOMAXPROCS()</code> 接口可以动态调整程序的并发数，也就是 P 的数量，看一下其实现（runtime/debug.go）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">GOMAXPROCS</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
        <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
        <span class="nx">ret</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">gomaxprocs</span><span class="p">)</span>
        <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">n</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">n</span> <span class="o">==</span> <span class="nx">ret</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">ret</span>
        <span class="p">}</span>
        
        <span class="c1">// STW !
</span><span class="c1"></span>        <span class="nf">stopTheWorldGC</span><span class="p">(</span><span class="s">&#34;GOMAXPROCS&#34;</span><span class="p">)</span>

        <span class="c1">// 调整全局变量
</span><span class="c1"></span>        <span class="c1">// newprocs will be processed by startTheWorld
</span><span class="c1"></span>        <span class="nx">newprocs</span> <span class="p">=</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
        
        <span class="c1">// 恢复，恢复时会进行 P 的缩扩
</span><span class="c1"></span>        <span class="nf">startTheWorldGC</span><span class="p">()</span>
        <span class="k">return</span> <span class="nx">ret</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>stopTheWorld；</li>
<li>调整全局变量 <code>newprocs</code> 的值，而该值后续在恢复时会被使用；</li>
<li>startTheWorld 恢复，恢复中一个步骤就是根据 <code>newprocs</code> 调用 <code>procresize()</code> 函数进行调整；</li>
</ol>
<h4 id="234-p-的可运行队列">2.3.4 P 的可运行队列</h4>
<p><code>p.runq</code> 保存着 P 独有的 runnable G，<code>p.runnext</code> 为最高优先级的 G。在下面源码中，经常可以看到调用 <code>runqget()</code> 从可运行队列得到一个 G:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Get g from local runnable queue.
</span><span class="c1">// If inheritTime is true, gp should inherit the remaining time in the
</span><span class="c1">// current time slice. Otherwise, it should start a new time slice.
</span><span class="c1">// Executed only by the owner P.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">runqget</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">inheritTime</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 返回 runnext
</span><span class="c1"></span>        <span class="k">for</span> <span class="p">{</span>
                <span class="nx">next</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runnext</span>
                <span class="k">if</span> <span class="nx">next</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                        <span class="k">break</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runnext</span><span class="p">.</span><span class="nf">cas</span><span class="p">(</span><span class="nx">next</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                        <span class="k">return</span> <span class="nx">next</span><span class="p">.</span><span class="nf">ptr</span><span class="p">(),</span> <span class="kc">true</span>
                <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="c1">// 从 runq 获取
</span><span class="c1"></span>        <span class="k">for</span> <span class="p">{</span>
                <span class="nx">h</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadAcq</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqhead</span><span class="p">)</span> <span class="c1">// load-acquire, synchronize with other consumers
</span><span class="c1"></span>                <span class="nx">t</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runqtail</span>
                <span class="k">if</span> <span class="nx">t</span> <span class="o">==</span> <span class="nx">h</span> <span class="p">{</span>
                        <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span>
                <span class="p">}</span>
                <span class="nx">gp</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">[</span><span class="nx">h</span><span class="o">%</span><span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">))].</span><span class="nf">ptr</span><span class="p">()</span>
                <span class="c1">// head 变动
</span><span class="c1"></span>                <span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CasRel</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqhead</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">h</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// cas-release, commits consume
</span><span class="c1"></span>                        <span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span>
                <span class="p">}</span>
        <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>当一个 G 新创建，或者从 _Gwaiting -&gt; _Grunning 时，G 会有加入到 P 的可运行队列，调用 <code>runqput()</code> 函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// runqput tries to put g on the local runnable queue.
</span><span class="c1">// If next is false, runqput adds g to the tail of the runnable queue.
</span><span class="c1">// If next is true, runqput puts g in the _p_.runnext slot.
</span><span class="c1">// If the run queue is full, runnext puts g on the global queue.
</span><span class="c1">// Executed only by the owner P.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">runqput</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">next</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 放置到 runnext
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">randomizeScheduler</span> <span class="o">&amp;&amp;</span> <span class="nx">next</span> <span class="o">&amp;&amp;</span> <span class="nf">fastrand</span><span class="p">()</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">next</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">next</span> <span class="p">{</span>
	<span class="nx">retryNext</span><span class="p">:</span>
		<span class="nx">oldnext</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runnext</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runnext</span><span class="p">.</span><span class="nf">cas</span><span class="p">(</span><span class="nx">oldnext</span><span class="p">,</span> <span class="nf">guintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">gp</span><span class="p">)))</span> <span class="p">{</span>
			<span class="k">goto</span> <span class="nx">retryNext</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">oldnext</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="c1">// Kick the old runnext out to the regular run queue.
</span><span class="c1"></span>		<span class="nx">gp</span> <span class="p">=</span> <span class="nx">oldnext</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
	<span class="p">}</span>

<span class="nx">retry</span><span class="p">:</span>
	<span class="c1">// 放到 runq
</span><span class="c1"></span>	<span class="nx">h</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadAcq</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqhead</span><span class="p">)</span> <span class="c1">// load-acquire, synchronize with consumers
</span><span class="c1"></span>	<span class="nx">t</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runqtail</span>
	<span class="k">if</span> <span class="nx">t</span><span class="o">-</span><span class="nx">h</span> <span class="p">&lt;</span> <span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">))</span> <span class="p">{</span>
		<span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">[</span><span class="nx">t</span><span class="o">%</span><span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">))].</span><span class="nf">set</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreRel</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqtail</span><span class="p">,</span> <span class="nx">t</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// store-release, makes the item available for consumption
</span><span class="c1"></span>		<span class="k">return</span>
	<span class="p">}</span>
	
	<span class="c1">// 本地 P 放不下了，放置到全局运行队列
</span><span class="c1"></span>	<span class="k">if</span> <span class="nf">runqputslow</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="nx">gp</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">// the queue is not full, now the put above must succeed
</span><span class="c1"></span>	<span class="k">goto</span> <span class="nx">retry</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>如果指定，放置到 <code>q.runnext</code>；</li>
<li>放置到 <code>q.runq</code>；</li>
<li>如果<strong>本地队列满了，那么放置到全局运行队列</strong> <code>sched.runq</code>。为了优化效率，<strong>每次会转移一半的本地队列 G</strong>；</li>
</ol>
<h3 id="24-schedt">2.4 schedt</h3>
<p><strong><code>schedt</code></strong> 是一个单例全局变量，包含一些全局的链表（runtime/runtime2.go）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">sched</span> <span class="nx">schedt</span>

<span class="kd">type</span> <span class="nx">schedt</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="c1">// When increasing nmidle, nmidlelocked, nmsys, or nmfreed, be
</span><span class="c1"></span>        <span class="c1">// sure to call checkdead().
</span><span class="c1"></span>
        <span class="nx">midle</span>        <span class="nx">muintptr</span> <span class="c1">// idle m&#39;s waiting for work
</span><span class="c1"></span>        <span class="nx">nmidle</span>       <span class="kt">int32</span>    <span class="c1">// number of idle m&#39;s waiting for work
</span><span class="c1"></span>
        <span class="nx">pidle</span>      <span class="nx">puintptr</span> <span class="c1">// idle p&#39;s
</span><span class="c1"></span>        <span class="nx">npidle</span>     <span class="kt">uint32</span>

        <span class="c1">// Global runnable queue.
</span><span class="c1"></span>        <span class="nx">runq</span>     <span class="nx">gQueue</span>
        <span class="nx">runqsize</span> <span class="kt">int32</span>

        <span class="c1">// disable controls selective disabling of the scheduler.
</span><span class="c1"></span>        <span class="c1">//
</span><span class="c1"></span>        <span class="c1">// Use schedEnableUser to control this.
</span><span class="c1"></span>        <span class="c1">//
</span><span class="c1"></span>        <span class="c1">// disable is protected by sched.lock.
</span><span class="c1"></span>        <span class="nx">disable</span> <span class="kd">struct</span> <span class="p">{</span>
                <span class="c1">// user disables scheduling of user goroutines.
</span><span class="c1"></span>                <span class="nx">user</span>     <span class="kt">bool</span>
                <span class="nx">runnable</span> <span class="nx">gQueue</span> <span class="c1">// pending runnable Gs
</span><span class="c1"></span>                <span class="nx">n</span>        <span class="kt">int32</span>  <span class="c1">// length of runnable
</span><span class="c1"></span>        <span class="p">}</span>

        <span class="c1">// Global cache of dead G&#39;s.
</span><span class="c1"></span>        <span class="nx">gFree</span> <span class="kd">struct</span> <span class="p">{</span>
                <span class="nx">lock</span>    <span class="nx">mutex</span>
                <span class="nx">stack</span>   <span class="nx">gList</span> <span class="c1">// Gs with stacks
</span><span class="c1"></span>                <span class="nx">noStack</span> <span class="nx">gList</span> <span class="c1">// Gs without stacks
</span><span class="c1"></span>                <span class="nx">n</span>       <span class="kt">int32</span>
        <span class="p">}</span>

        <span class="c1">// Central cache of sudog structs.
</span><span class="c1"></span>        <span class="nx">sudoglock</span>  <span class="nx">mutex</span>
        <span class="nx">sudogcache</span> <span class="o">*</span><span class="nx">sudog</span>

        <span class="c1">// Central pool of available defer structs of different sizes.
</span><span class="c1"></span>        <span class="nx">deferlock</span> <span class="nx">mutex</span>
        <span class="nx">deferpool</span> <span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">*</span><span class="nx">_defer</span>

        <span class="c1">// freem is the list of m&#39;s waiting to be freed when their
</span><span class="c1"></span>        <span class="c1">// m.exited is set. Linked through m.freelink.
</span><span class="c1"></span>        <span class="nx">freem</span> <span class="o">*</span><span class="nx">m</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li><strong><code>midle</code></strong> ：<strong>空闲的 M 的链表</strong>；</li>
<li><strong><code>pidle</code></strong> ：<strong>空闲的 P 的链表</strong>；</li>
<li><strong><code>runq</code></strong> ：<strong>全局的可运行的 G 队列</strong>；</li>
<li><strong><code>gFree</code></strong> ：全局的可复用的 g 结构队列；</li>
<li><code>freem</code> ：等待释放的 M 的链表，当 M 新建时会将其释放，并复用 m 对象；</li>
</ul>
<h2 id="3-调度循环">3 调度循环</h2>
<p>前面 M 的启动看到，每个 M 创建后会进入 <code>schedule()</code> 的调度循环，并且不会返回，每个 M 执行大致流程如下：








    <br><img src="/posts/language/golang/language/goroutine/img4.png"/>


</p>
<ol>
<li>执行 <code>schedule()</code>， <strong>使得 M 找到一个可用的 G，并绑定</strong>；</li>
<li>执行 <code>execute()</code>，<strong>完成执行 G.fn 的准备工作</strong>；</li>
<li><strong>调用 G 的函数</strong>；</li>
<li>G 函数调用退出后，调用 <code>goexit()</code> 函数<strong>清理相关资源，并重新进入 <code>schedule()</code></strong>；</li>
</ol>
<p>当然，上面是正常 G 执行并退出的逻辑，多数情况下 G 执行的过程中都会经历抢占与调度，也就是说会 M 可能会切换 P、切换 G 执行。</p>
<h3 id="31-schedule">3.1 schedule()</h3>
<p><code>schedule()</code> 是调度循环的第一步，M 会在这里尽力寻找一个 runnable G，然后进入 <code>execute() </code>执行 G 的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// One round of scheduler: find a runnable goroutine and execute it.
</span><span class="c1">// Never returns.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">schedule</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
        
        <span class="c1">// 锁定了 G, 那么还是执行锁定的 G
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedg</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="nf">stoplockedm</span><span class="p">()</span>
                <span class="nf">execute</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedg</span><span class="p">.</span><span class="nf">ptr</span><span class="p">(),</span> <span class="kc">false</span><span class="p">)</span> <span class="c1">// Never returns.
</span><span class="c1"></span>        <span class="p">}</span>

<span class="nx">top</span><span class="p">:</span>
        <span class="nx">pp</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
        <span class="nx">pp</span><span class="p">.</span><span class="nx">preempt</span> <span class="p">=</span> <span class="kc">false</span>

        <span class="c1">// STW 中，等待结束
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="nf">gcstopm</span><span class="p">()</span>
                <span class="k">goto</span> <span class="nx">top</span>
        <span class="p">}</span>
        
        <span class="c1">// 运行 timer
</span><span class="c1"></span>        <span class="nf">checkTimers</span><span class="p">(</span><span class="nx">pp</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1">// gp 为新调度到的 G
</span><span class="c1"></span>        <span class="kd">var</span> <span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span>
        <span class="kd">var</span> <span class="nx">inheritTime</span> <span class="kt">bool</span>

        <span class="c1">// Normal goroutines will check for need to wakeP in ready,
</span><span class="c1"></span>        <span class="c1">// but GCworkers and tracereaders will not, so the check must
</span><span class="c1"></span>        <span class="c1">// be done here instead.
</span><span class="c1"></span>        <span class="nx">tryWakeP</span> <span class="o">:=</span> <span class="kc">false</span>
        <span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="o">||</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">shutdown</span> <span class="p">{</span>
                <span class="nx">gp</span> <span class="p">=</span> <span class="nf">traceReader</span><span class="p">()</span>
                <span class="k">if</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
                        <span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
                        <span class="nf">traceGoUnpark</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                        <span class="nx">tryWakeP</span> <span class="p">=</span> <span class="kc">true</span>
                <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="c1">// GC 扫描开始工作，尝试 GCWorker 的 G
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">gcBlackenEnabled</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="nx">gp</span> <span class="p">=</span> <span class="nx">gcController</span><span class="p">.</span><span class="nf">findRunnableGCWorker</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">())</span>
                <span class="nx">tryWakeP</span> <span class="p">=</span> <span class="nx">tryWakeP</span> <span class="o">||</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span>
        <span class="p">}</span>
        <span class="c1">// 定期直接从 全局可运行队列 获取 G，防止饥饿
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="c1">// Check the global runnable queue once in a while to ensure fairness.
</span><span class="c1"></span>                <span class="c1">// Otherwise two goroutines can completely occupy the local runqueue
</span><span class="c1"></span>                <span class="c1">// by constantly respawning each other.
</span><span class="c1"></span>                <span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">schedtick</span><span class="o">%</span><span class="mi">61</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">runqsize</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
                        <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
                        <span class="nx">gp</span> <span class="p">=</span> <span class="nf">globrunqget</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>
                        <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
                <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// 从当前 P 的 可运行队列 获取一个 G
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="nx">gp</span><span class="p">,</span> <span class="nx">inheritTime</span> <span class="p">=</span> <span class="nf">runqget</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">())</span>
                <span class="c1">// We can see gp != nil here even if the M is spinning,
</span><span class="c1"></span>                <span class="c1">// if checkTimers added a local goroutine via goready.
</span><span class="c1"></span>        <span class="p">}</span>
        <span class="c1">// 上面都尝试了，尽可能去找到一个 G，这里会阻塞
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="nx">gp</span><span class="p">,</span> <span class="nx">inheritTime</span> <span class="p">=</span> <span class="nf">findrunnable</span><span class="p">()</span> <span class="c1">// blocks until work is available
</span><span class="c1"></span>        <span class="p">}</span>

        <span class="c1">// This thread is going to run a goroutine and is not spinning anymore,
</span><span class="c1"></span>        <span class="c1">// so if it was marked as spinning we need to reset it now and potentially
</span><span class="c1"></span>        <span class="c1">// start a new spinning M.
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">{</span>
                <span class="nf">resetspinning</span><span class="p">()</span>
        <span class="p">}</span>

        <span class="c1">// 帮忙唤醒别的 P
</span><span class="c1"></span>        <span class="c1">// If about to schedule a not-normal goroutine (a GCworker or tracereader),
</span><span class="c1"></span>        <span class="c1">// wake a P if there is one.
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">tryWakeP</span> <span class="p">{</span>
                <span class="nf">wakep</span><span class="p">()</span>
        <span class="p">}</span>
        
        <span class="c1">// 如果选出的 G 是被别的 M 锁定的，那么只能重新走流程
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">lockedm</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="c1">// Hands off own p to the locked m,
</span><span class="c1"></span>                <span class="c1">// then blocks waiting for a new p.
</span><span class="c1"></span>                <span class="nf">startlockedm</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
                <span class="k">goto</span> <span class="nx">top</span>
        <span class="p">}</span>

        <span class="c1">// 执行新的 G
</span><span class="c1"></span>        <span class="nf">execute</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">inheritTime</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>M 有锁定的 G，<strong>执行锁定 G 代码</strong>；</li>
<li>从各个地方得到一个 runnable G，包括：
<ol>
<li><strong>GCWork 的 G</strong>，见：</li>
<li>定期直接从 <strong>全局可运行的队列 获取 G</strong>，防止全局队列的 G 长时间饥饿；</li>
<li>从绑定的 <strong>P 的 可运行队列 获取 G</strong>；</li>
<li>通过 <code>fundrunnable()</code> <strong>尽可能获取一个 G</strong>；</li>
</ol>
</li>
<li>最终，获取到一个 G 后，<code>execute()</code> 执行 G 的代码；</li>
</ol>
<h4 id="311-fundrunnable">3.1.1 fundrunnable()</h4>
<p>为了找到可以运行的 G，findrunnable() 会尝试各个手段。但是这个代码比较复杂，这里捡最关键的点看（runtime/proc.go）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Finds a runnable goroutine to execute.
</span><span class="c1">// Tries to steal from other P&#39;s, get g from local or global queue, poll network.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">findrunnable</span><span class="p">()</span> <span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">inheritTime</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

<span class="nx">top</span><span class="p">:</span>
        <span class="c1">// 正在垃圾回收 STW，休眠轮询
</span><span class="c1"></span>        <span class="nx">_p_</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
        <span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="nf">gcstopm</span><span class="p">()</span>
                <span class="k">goto</span> <span class="nx">top</span>
        <span class="p">}</span>

        <span class="nx">now</span><span class="p">,</span> <span class="nx">pollUntil</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nf">checkTimers</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="nx">fingwait</span> <span class="o">&amp;&amp;</span> <span class="nx">fingwake</span> <span class="p">{</span>
                <span class="k">if</span> <span class="nx">gp</span> <span class="o">:=</span> <span class="nf">wakefing</span><span class="p">();</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
                        <span class="nf">ready</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
                <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// 从绑定的 P 队列获取
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">gp</span><span class="p">,</span> <span class="nx">inheritTime</span> <span class="o">:=</span> <span class="nf">runqget</span><span class="p">(</span><span class="nx">_p_</span><span class="p">);</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="nx">inheritTime</span>
        <span class="p">}</span>

        <span class="c1">// 从全局队列获取
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">runqsize</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
                <span class="nx">gp</span> <span class="o">:=</span> <span class="nf">globrunqget</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
                <span class="k">if</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
                        <span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span>
                <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// 检查全局的 netpoll 的 G
</span><span class="c1"></span>        <span class="k">if</span> <span class="nf">netpollinited</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">netpollWaiters</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lastpoll</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="k">if</span> <span class="nx">list</span> <span class="o">:=</span> <span class="nf">netpoll</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="p">!</span><span class="nx">list</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// non-blocking
</span><span class="c1"></span>                        <span class="nx">gp</span> <span class="o">:=</span> <span class="nx">list</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
                        <span class="nf">injectglist</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">list</span><span class="p">)</span>
                        <span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
                                <span class="nf">traceGoUnpark</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                        <span class="p">}</span>
                        <span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span>
                <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// 从别的 P 偷取一半的任务
</span><span class="c1"></span>        <span class="c1">// Steal work from other P&#39;s.
</span><span class="c1"></span>        <span class="nx">procs</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">gomaxprocs</span><span class="p">)</span>
        <span class="nx">ranTimer</span> <span class="o">:=</span> <span class="kc">false</span>
        <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
                <span class="k">for</span> <span class="nx">enum</span> <span class="o">:=</span> <span class="nx">stealOrder</span><span class="p">.</span><span class="nf">start</span><span class="p">(</span><span class="nf">fastrand</span><span class="p">());</span> <span class="p">!</span><span class="nx">enum</span><span class="p">.</span><span class="nf">done</span><span class="p">();</span> <span class="nx">enum</span><span class="p">.</span><span class="nf">next</span><span class="p">()</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
                                <span class="k">goto</span> <span class="nx">top</span>
                        <span class="p">}</span>
                        <span class="nx">stealRunNextG</span> <span class="o">:=</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">2</span> <span class="c1">// first look for ready queues with more than 1 g
</span><span class="c1"></span>                        <span class="nx">p2</span> <span class="o">:=</span> <span class="nx">allp</span><span class="p">[</span><span class="nx">enum</span><span class="p">.</span><span class="nf">position</span><span class="p">()]</span>
                        <span class="k">if</span> <span class="nx">_p_</span> <span class="o">==</span> <span class="nx">p2</span> <span class="p">{</span>
                                <span class="k">continue</span>
                        <span class="p">}</span>
                        <span class="k">if</span> <span class="nx">gp</span> <span class="o">:=</span> <span class="nf">runqsteal</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="nx">p2</span><span class="p">,</span> <span class="nx">stealRunNextG</span><span class="p">);</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
                                <span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span>
                        <span class="p">}</span>

	        <span class="c1">// Consider stealing timers from p2.
</span><span class="c1"></span>	        <span class="c1">// This call to checkTimers is the only place where
</span><span class="c1"></span>	        <span class="c1">// we hold a lock on a different P&#39;s timers.
</span><span class="c1"></span>	        <span class="c1">// Lock contention can be a problem here, so
</span><span class="c1"></span>	        <span class="c1">// initially avoid grabbing the lock if p2 is running
</span><span class="c1"></span>	        <span class="c1">// and is not marked for preemption. If p2 is running
</span><span class="c1"></span>	        <span class="c1">// and not being preempted we assume it will handle its
</span><span class="c1"></span>	        <span class="c1">// own timers.
</span><span class="c1"></span>	        <span class="c1">// If we&#39;re still looking for work after checking all
</span><span class="c1"></span>	        <span class="c1">// the P&#39;s, then go ahead and steal from an active P.
</span><span class="c1"></span>	        <span class="k">if</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">2</span> <span class="o">||</span> <span class="p">(</span><span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nf">shouldStealTimers</span><span class="p">(</span><span class="nx">p2</span><span class="p">))</span> <span class="p">{</span>
	                <span class="nx">tnow</span><span class="p">,</span> <span class="nx">w</span><span class="p">,</span> <span class="nx">ran</span> <span class="o">:=</span> <span class="nf">checkTimers</span><span class="p">(</span><span class="nx">p2</span><span class="p">,</span> <span class="nx">now</span><span class="p">)</span>
	                <span class="nx">now</span> <span class="p">=</span> <span class="nx">tnow</span>
	                <span class="k">if</span> <span class="nx">w</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">pollUntil</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">w</span> <span class="p">&lt;</span> <span class="nx">pollUntil</span><span class="p">)</span> <span class="p">{</span>
	                        <span class="nx">pollUntil</span> <span class="p">=</span> <span class="nx">w</span>
	                <span class="p">}</span>
	                <span class="k">if</span> <span class="nx">ran</span> <span class="p">{</span>
	                        <span class="c1">// Running the timers may have
</span><span class="c1"></span>	                        <span class="c1">// made an arbitrary number of G&#39;s
</span><span class="c1"></span>	                        <span class="c1">// ready and added them to this P&#39;s
</span><span class="c1"></span>	                        <span class="c1">// local run queue. That invalidates
</span><span class="c1"></span>	                        <span class="c1">// the assumption of runqsteal
</span><span class="c1"></span>	                        <span class="c1">// that is always has room to add
</span><span class="c1"></span>	                        <span class="c1">// stolen G&#39;s. So check now if there
</span><span class="c1"></span>	                        <span class="c1">// is a local G to run.
</span><span class="c1"></span>	                        <span class="k">if</span> <span class="nx">gp</span><span class="p">,</span> <span class="nx">inheritTime</span> <span class="o">:=</span> <span class="nf">runqget</span><span class="p">(</span><span class="nx">_p_</span><span class="p">);</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	                                <span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="nx">inheritTime</span>
	                        <span class="p">}</span>
	                        <span class="nx">ranTimer</span> <span class="p">=</span> <span class="kc">true</span>
	                <span class="p">}</span>
	        <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nx">ranTimer</span> <span class="p">{</span>
                <span class="c1">// Running a timer may have made some goroutine ready.
</span><span class="c1"></span>                <span class="k">goto</span> <span class="nx">top</span>
        <span class="p">}</span>

<span class="nx">stop</span><span class="p">:</span>

        <span class="c1">// …
</span><span class="c1"></span>        <span class="c1">// 依旧按照顺序尝试各个地方获取
</span><span class="c1"></span>        
        <span class="c1">// 一无所获，进入休眠
</span><span class="c1"></span>        <span class="nf">stopm</span><span class="p">()</span>
        <span class="k">goto</span> <span class="nx">top</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>从绑定的 <strong>P 本地队列获取</strong>；</li>
<li>从<strong>全局队列获取</strong>；</li>
<li><strong>检查 netpoll 是否有就绪的 G</strong>（会执行一次非阻塞的 epollwait()）；</li>
<li>通过 <code>runtime.runqsteal()</code> 从<strong>其他的 P 的运行中偷取 G</strong>，还可能同时把 P 的 timer 获取了；</li>
</ol>
<h3 id="32-execute">3.2 execute()</h3>
<p><code>execute()</code> 让当前线程执行 G 的代码，并且不会返回：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Schedules gp to run on the current M.
</span><span class="c1">// If inheritTime is true, gp inherits the remaining time in the
</span><span class="c1">// current time slice. Otherwise, it starts a new time slice.
</span><span class="c1">// Never returns.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">execute</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">inheritTime</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

        <span class="c1">// Assign gp.m before entering _Grunning so running Gs have an
</span><span class="c1"></span>        <span class="c1">// M.
</span><span class="c1"></span>        <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span> <span class="p">=</span> <span class="nx">gp</span>
        <span class="nx">gp</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span>
        <span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">)</span>
        <span class="nx">gp</span><span class="p">.</span><span class="nx">waitsince</span> <span class="p">=</span> <span class="mi">0</span>
        <span class="nx">gp</span><span class="p">.</span><span class="nx">preempt</span> <span class="p">=</span> <span class="kc">false</span>
        <span class="nx">gp</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">+</span> <span class="nx">_StackGuard</span>
        <span class="k">if</span> <span class="p">!</span><span class="nx">inheritTime</span> <span class="p">{</span>
                <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">schedtick</span><span class="o">++</span>
        <span class="p">}</span>
        
        <span class="c1">// …
</span><span class="c1"></span>
        <span class="nf">gogo</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>不过 <code>execute()</code> 执行的是一些初始化的操作，切换 PC、SP 等操作只能通过汇编的 <code>gogo</code> 实现，注意关键的 <code>g.sched</code> 结构（<code>gobuf</code> 结构）的传参。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// func gogo(buf *gobuf)
</span><span class="c1">// restore state from Gobuf; longjmp
</span><span class="c1"></span><span class="nx">TEXT</span> <span class="nx">runtime</span><span class="err">·</span><span class="nf">gogo</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">NOSPLIT</span><span class="p">,</span> <span class="err">$</span><span class="mi">16</span><span class="o">-</span><span class="mi">8</span>
        <span class="nx">MOVQ</span>        <span class="nx">buf</span><span class="o">+</span><span class="mi">0</span><span class="p">(</span><span class="nx">FP</span><span class="p">),</span> <span class="nx">BX</span>                <span class="c1">// gobuf 内容放到 BX 寄存器
</span><span class="c1"></span>        <span class="nx">MOVQ</span>        <span class="nf">gobuf_g</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">DX</span>
        <span class="nx">MOVQ</span>        <span class="mi">0</span><span class="p">(</span><span class="nx">DX</span><span class="p">),</span> <span class="nx">CX</span>                <span class="c1">// make sure g != nil
</span><span class="c1"></span>        <span class="nf">get_tls</span><span class="p">(</span><span class="nx">CX</span><span class="p">)</span>
        <span class="nx">MOVQ</span>        <span class="nx">DX</span><span class="p">,</span> <span class="nf">g</span><span class="p">(</span><span class="nx">CX</span><span class="p">)</span>
        <span class="nx">MOVQ</span>        <span class="nf">gobuf_sp</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">SP</span>        <span class="c1">// 将 SP 地址设置为 gobuf.sp。第一次执行 G 时，这里是 goexit 函数地址
</span><span class="c1"></span>        <span class="nx">MOVQ</span>        <span class="nf">gobuf_ret</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">AX</span>
        <span class="nx">MOVQ</span>        <span class="nf">gobuf_ctxt</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">DX</span>
        <span class="nx">MOVQ</span>        <span class="nf">gobuf_bp</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">BP</span>
        <span class="nx">MOVQ</span>        <span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="nf">gobuf_sp</span><span class="p">(</span><span class="nx">BX</span><span class="p">)</span>        <span class="c1">// clear to help garbage collector
</span><span class="c1"></span>        <span class="nx">MOVQ</span>        <span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="nf">gobuf_ret</span><span class="p">(</span><span class="nx">BX</span><span class="p">)</span>
        <span class="nx">MOVQ</span>        <span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="nf">gobuf_ctxt</span><span class="p">(</span><span class="nx">BX</span><span class="p">)</span>
        <span class="nx">MOVQ</span>        <span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="nf">gobuf_bp</span><span class="p">(</span><span class="nx">BX</span><span class="p">)</span>
        <span class="nx">MOVQ</span>        <span class="nf">gobuf_pc</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">BX</span>  <span class="c1">// 将 BX 寄存器设置为 gobuf.pc。第一次执行 G 时，这里是 G 的函数地址
</span><span class="c1"></span>        <span class="nx">JMP</span>        <span class="nx">BX</span>  <span class="c1">// JMP gobuf.pc，开始执行
</span></code></pre></td></tr></table>
</div>
</div><p>这里最关键的就是切换为 G 的执行上下文：</p>
<ul>
<li>将 <strong>SP 设置为 <code>gobuf.sp</code></strong>。如果 G 没有执行过，那么值就是创建 g 结构时填入的 <code>goexit()</code> 函数的地址。</li>
<li>代码流通过 <strong>JMP 指令跳转到 <code>gobuf.pc</code></strong>。如果 G 没有执行过，那么就是 G 对应代码的地址。</li>
</ul>
<p>这里我们也可以知道了，因为函数调用就是将 返回函数、参数 压栈的过程。而这里将栈顶设置为 <code>goexit()</code> 函数，<strong>所以当 G 对应用户代码执行完后，就会继续执行 <code>goexit()</code> 函数</strong>。这就是 M 不断执行调度循环的关键。








    <br><img src="/posts/language/golang/language/goroutine/img5.png"/>


</p>
<h3 id="33-goexit">3.3 goexit()</h3>
<p><code>goexit()</code> 在 G 用户代码执行后，执行的汇编代码，其最后通过切换到 g0 栈调用 <code>goexit0()</code> 函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// goexit continuation on g0.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">goexit0</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
        
        <span class="c1">// G running 变为 dead
</span><span class="c1"></span>        <span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Gdead</span><span class="p">)</span>
        
        <span class="c1">// 重置 g 的属性
</span><span class="c1"></span>        <span class="k">if</span> <span class="nf">isSystemGoroutine</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">ngsys</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">gp</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="kc">nil</span>
        <span class="nx">locked</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">lockedm</span> <span class="o">!=</span> <span class="mi">0</span>
        <span class="nx">gp</span><span class="p">.</span><span class="nx">lockedm</span> <span class="p">=</span> <span class="mi">0</span>
        <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedg</span> <span class="p">=</span> <span class="mi">0</span>
        <span class="nx">gp</span><span class="p">.</span><span class="nx">preemptStop</span> <span class="p">=</span> <span class="kc">false</span>
        <span class="nx">gp</span><span class="p">.</span><span class="nx">paniconfault</span> <span class="p">=</span> <span class="kc">false</span>
        <span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span> <span class="p">=</span> <span class="kc">nil</span> <span class="c1">// should be true already but just in case.
</span><span class="c1"></span>        <span class="nx">gp</span><span class="p">.</span><span class="nx">_panic</span> <span class="p">=</span> <span class="kc">nil</span> <span class="c1">// non-nil for Goexit during panic. points at stack-allocated data.
</span><span class="c1"></span>        <span class="nx">gp</span><span class="p">.</span><span class="nx">writebuf</span> <span class="p">=</span> <span class="kc">nil</span>
        <span class="nx">gp</span><span class="p">.</span><span class="nx">waitreason</span> <span class="p">=</span> <span class="mi">0</span>
        <span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>
        <span class="nx">gp</span><span class="p">.</span><span class="nx">labels</span> <span class="p">=</span> <span class="kc">nil</span>
        <span class="nx">gp</span><span class="p">.</span><span class="nx">timer</span> <span class="p">=</span> <span class="kc">nil</span>

        <span class="k">if</span> <span class="nx">gcBlackenEnabled</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">gcAssistBytes</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="c1">// Flush assist credit to the global pool. This gives
</span><span class="c1"></span>                <span class="c1">// better information to pacing if the application is
</span><span class="c1"></span>                <span class="c1">// rapidly creating an exiting goroutines.
</span><span class="c1"></span>                <span class="nx">scanCredit</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">assistWorkPerByte</span> <span class="o">*</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">gcAssistBytes</span><span class="p">))</span>
                <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">bgScanCredit</span><span class="p">,</span> <span class="nx">scanCredit</span><span class="p">)</span>
                <span class="nx">gp</span><span class="p">.</span><span class="nx">gcAssistBytes</span> <span class="p">=</span> <span class="mi">0</span>
        <span class="p">}</span>

        <span class="c1">// 解除 M 与 G 的绑定
</span><span class="c1"></span>        <span class="nf">dropg</span><span class="p">()</span>

        <span class="c1">// 将 dead G 放到 p.gFree 或者 sched.gFree
</span><span class="c1"></span>        <span class="nf">gfput</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">(),</span> <span class="nx">gp</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">locked</span> <span class="p">{</span>
                <span class="c1">// 如果 M 与 G 是锁定的，那么 M 线程退出
</span><span class="c1"></span>                <span class="c1">// The goroutine may have locked this thread because
</span><span class="c1"></span>                <span class="c1">// it put it in an unusual kernel state. Kill it
</span><span class="c1"></span>                <span class="c1">// rather than returning it to the thread pool.
</span><span class="c1"></span>
                <span class="c1">// Return to mstart, which will release the P and exit
</span><span class="c1"></span>                <span class="c1">// the thread.
</span><span class="c1"></span>                <span class="k">if</span> <span class="nx">GOOS</span> <span class="o">!=</span> <span class="s">&#34;plan9&#34;</span> <span class="p">{</span> <span class="c1">// See golang.org/issue/22227.
</span><span class="c1"></span>                        <span class="nf">gogo</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">g0</span><span class="p">.</span><span class="nx">sched</span><span class="p">)</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="c1">// Clear lockedExt on plan9 since we may end up re-using
</span><span class="c1"></span>                        <span class="c1">// this thread.
</span><span class="c1"></span>                        <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedExt</span> <span class="p">=</span> <span class="mi">0</span>
                <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="c1">// 重新进入调度循环
</span><span class="c1"></span>        <span class="nf">schedule</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>G 状态由 _Grunning 变为 _Gdead；</li>
<li>重置 G 的属性；</li>
<li>通过 <code>dropg()</code> <strong>解除 M 与 G 的绑定</strong>；</li>
<li>将 g 对象放到 <code>p.gFree</code> 或者 <code>sched.gFree</code>，以便后续创建 G 时可以复用对象；</li>
<li><strong>如果 M 与 G 是锁定着的，而 G 执行完毕，让 m 回到 <code>mstart()</code> 函数继续执行，这样 M 线程会被销毁并退出</strong>；</li>
<li><strong>重新进入 <code>schedule()</code> 调度循环</strong>；</li>
</ol>
<h2 id="4-调度切换">4 调度切换</h2>
<p>当前，调度循环中描述的情况是一个 M 执行 G 不被抢占与调度的情况。大多数情况下，当 M 执行 G.fn 的过程中就会被切换，执行其他的 G 的情况。</p>
<h3 id="41-切换时机">4.1 切换时机</h3>
<p>先大体总结一下可能的切换时机：</p>
<ul>
<li><strong>主动挂起</strong>
<ul>
<li>遇到 runtime 级别阻塞（例如 channel 读写阻塞）</li>
</ul>
</li>
<li><strong>主动调度</strong>
<ul>
<li>调用 <code>runtime.Gosched()</code> 主动进行调度</li>
</ul>
</li>
<li><strong>系统调用</strong>
<ul>
<li>系统调用结束后，M 可能进行 G 的切换；</li>
</ul>
</li>
<li><strong>抢占</strong>
<ul>
<li>sysmon 判断 G 运行时间大于 10ms，进行抢占；</li>
</ul>
</li>
</ul>
<h3 id="42-主动挂起">4.2 主动挂起</h3>
<p>在 G 遇到非系统调用的阻塞前，就会调用 <code>gopark()</code>，<strong>将 G 由 _Grunning -&gt; _Gwaiting，而 M 解绑 G，重新进入调度循环</strong>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Puts the current goroutine into a waiting state and calls unlockf.
</span><span class="c1">// If unlockf returns false, the goroutine is resumed.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">gopark</span><span class="p">(</span><span class="nx">unlockf</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">lock</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">reason</span> <span class="nx">waitReason</span><span class="p">,</span> <span class="nx">traceEv</span> <span class="kt">byte</span><span class="p">,</span> <span class="nx">traceskip</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">reason</span> <span class="o">!=</span> <span class="nx">waitReasonSleep</span> <span class="p">{</span>
                <span class="nf">checkTimeouts</span><span class="p">()</span> <span class="c1">// timeouts may expire while two goroutines keep the scheduler busy
</span><span class="c1"></span>        <span class="p">}</span>
        <span class="nx">mp</span> <span class="o">:=</span> <span class="nf">acquirem</span><span class="p">()</span>
        <span class="nx">gp</span> <span class="o">:=</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">curg</span>
        <span class="nx">status</span> <span class="o">:=</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
        <span class="nx">mp</span><span class="p">.</span><span class="nx">waitlock</span> <span class="p">=</span> <span class="nx">lock</span>
        <span class="nx">mp</span><span class="p">.</span><span class="nx">waitunlockf</span> <span class="p">=</span> <span class="nx">unlockf</span>
        <span class="nx">gp</span><span class="p">.</span><span class="nx">waitreason</span> <span class="p">=</span> <span class="nx">reason</span>
        <span class="nx">mp</span><span class="p">.</span><span class="nx">waittraceev</span> <span class="p">=</span> <span class="nx">traceEv</span>
        <span class="nx">mp</span><span class="p">.</span><span class="nx">waittraceskip</span> <span class="p">=</span> <span class="nx">traceskip</span>
        <span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
        <span class="c1">// can&#39;t do anything that might move the G between Ms here.
</span><span class="c1"></span>        <span class="nf">mcall</span><span class="p">(</span><span class="nx">park_m</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// park continuation on g0.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">park_m</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

        <span class="c1">// 改变 G 状态
</span><span class="c1"></span>        <span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">)</span>
        
        <span class="c1">// M 解绑 G
</span><span class="c1"></span>        <span class="nf">dropg</span><span class="p">()</span>

        <span class="k">if</span> <span class="nx">fn</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">waitunlockf</span><span class="p">;</span> <span class="nx">fn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="nx">ok</span> <span class="o">:=</span> <span class="nf">fn</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">waitlock</span><span class="p">)</span>
                <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">waitunlockf</span> <span class="p">=</span> <span class="kc">nil</span>
                <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">waitlock</span> <span class="p">=</span> <span class="kc">nil</span>
                <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
                                <span class="nf">traceGoUnpark</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
                        <span class="p">}</span>
                        <span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
                        <span class="nf">execute</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span> <span class="c1">// Schedule it back, never returns.
</span><span class="c1"></span>                <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="c1">// 重新进入调度循环
</span><span class="c1"></span>        <span class="nf">schedule</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="details admonition note open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-pencil-alt fa-fw" aria-hidden="true"></i>Note<i class="details-icon fas fa-angle-right fa-fw" aria-hidden="true"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><p>上面没有任何地方记录 _Gwaiting 状态的 G，Why？</p>
<p>因为这时 <code>gopark()</code> 调用者的责任，例如 channel 读写阻塞时，会将 g 记录到 channel 时，在唤醒时将 G 重新加入到可运行队列。</p>
</div>
        </div>
    </div>
<p>当进入 _Gwaiting 状态的 G 需要恢复时，调用 <code>goready()</code> / <code>goparkunlock()</code> 函数进行恢复：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">goready</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">traceskip</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
                <span class="nf">ready</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">traceskip</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
        <span class="p">})</span>
<span class="p">}</span>

<span class="c1">// Mark gp ready to run.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">ready</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">traceskip</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">next</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">status</span> <span class="o">:=</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>

        <span class="c1">// 获取一个 M
</span><span class="c1"></span>        <span class="c1">// Mark runnable.
</span><span class="c1"></span>        <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
        <span class="nx">mp</span> <span class="o">:=</span> <span class="nf">acquirem</span><span class="p">()</span> <span class="c1">// disable preemption because it can be holding p in a local var
</span><span class="c1"></span>
        <span class="c1">// waiting -&gt; runnable
</span><span class="c1"></span>        <span class="c1">// status is Gwaiting or Gscanwaiting, make Grunnable and put on runq
</span><span class="c1"></span>        <span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
        
        <span class="c1">// 放置到 M 对应 P 的 runq，等待调度执行
</span><span class="c1"></span>        <span class="nf">runqput</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">(),</span> <span class="nx">gp</span><span class="p">,</span> <span class="nx">next</span><span class="p">)</span>
        <span class="nf">wakep</span><span class="p">()</span>
        <span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>调用 <code>gopark()</code> 的地方有许多，列出主要的几个地方：</p>
<ul>
<li><strong>channel 的发送/接受阻塞</strong>；</li>
<li><strong>select 所有 case 不满足，陷入阻塞</strong>；</li>
<li><strong>time.Sleep 使得 goroutine 进入阻塞</strong>；</li>
<li><strong>GC 工作的 gcwork 挂起等待唤醒</strong>；</li>
<li><strong>main goroutine 挂起并且不会被唤醒</strong>；</li>
</ul>
<h3 id="43-主动调度">4.3 主动调度</h3>
<p>标准库接口 <code>runtime.Gosched()</code> 可以在用户代码中使 G 主动让出 M：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Gosched</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">checkTimeouts</span><span class="p">()</span>
        <span class="nf">mcall</span><span class="p">(</span><span class="nx">gosched_m</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Gosched continuation on g0.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">gosched_m</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">goschedImpl</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">goschedImpl</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// running 状态变为 runnable
</span><span class="c1"></span>        <span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
        
        <span class="c1">// M 与 G 解绑
</span><span class="c1"></span>        <span class="nf">dropg</span><span class="p">()</span>
        
        <span class="c1">// 放到 global runq
</span><span class="c1"></span>        <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
        <span class="nf">globrunqput</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
        <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

        <span class="nf">schedule</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>最后会调用 <code>goschedImpl()</code>，将 G 由 _Grunning -&gt; _Grunnable 状态，M 与 G 解绑，并将其放到全局运行队列。
<div class="details admonition note open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-pencil-alt fa-fw" aria-hidden="true"></i>Note<i class="details-icon fas fa-angle-right fa-fw" aria-hidden="true"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">因为调用 <code>goschedImpl()</code> 是要切换正在运行的 G，所以放到全局队列。</div>
        </div>
    </div></p>
<h3 id="44-系统调用">4.4 系统调用</h3>
<p>Go 通过 <code>syscall.Syscall</code> 和 <code>syscall.RawSyscall</code> 来封装系统的所有系统调用。</p>
<ul>
<li><code>syscall.Syscall</code> <strong>针对可能长时间阻塞的系统调用</strong>，例如 IO 操作。<br>
使得在陷入系统调用之间，系统调用结束后，可以触发一些准备和情况工作。</li>
<li><code>syscall.RawSyscall</code> <strong>针对不太会长时间阻塞的系统调用</strong>，例如 读取时间等。<br>
直接进行系统调用，不做其他处理。</li>
</ul>
<div class="details admonition tip open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-lightbulb fa-fw" aria-hidden="true"></i>系统调用分类<i class="details-icon fas fa-angle-right fa-fw" aria-hidden="true"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">大神将各个系统调用分类了，见 <a href="https://gist.github.com/draveness/50c88883f30fa99d548cf1163c98aeb1" target="_blank" rel="noopener noreffer"><strong>这里</strong></a></div>
        </div>
    </div>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">TEXT</span> <span class="err">·</span><span class="nf">Syscall</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span><span class="nx">NOSPLIT</span><span class="p">,</span><span class="err">$</span><span class="mi">0</span><span class="o">-</span><span class="mi">56</span>
        <span class="nx">CALL</span>        <span class="nx">runtime</span><span class="err">·</span><span class="nf">entersyscall</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span> <span class="c1">// 调用 entersyscall()
</span><span class="c1"></span>        <span class="nx">MOVQ</span>        <span class="nx">a1</span><span class="o">+</span><span class="mi">8</span><span class="p">(</span><span class="nx">FP</span><span class="p">),</span> <span class="nx">DI</span>
        <span class="nx">MOVQ</span>        <span class="nx">a2</span><span class="o">+</span><span class="mi">16</span><span class="p">(</span><span class="nx">FP</span><span class="p">),</span> <span class="nx">SI</span>
        <span class="nx">MOVQ</span>        <span class="nx">a3</span><span class="o">+</span><span class="mi">24</span><span class="p">(</span><span class="nx">FP</span><span class="p">),</span> <span class="nx">DX</span>
        <span class="nx">MOVQ</span>        <span class="nx">trap</span><span class="o">+</span><span class="mi">0</span><span class="p">(</span><span class="nx">FP</span><span class="p">),</span> <span class="nx">AX</span>        <span class="c1">// syscall entry
</span><span class="c1"></span>        <span class="nx">SYSCALL</span>
        <span class="nx">CMPQ</span>        <span class="nx">AX</span><span class="p">,</span> <span class="err">$</span><span class="mh">0xfffffffffffff001</span>
        <span class="nx">JLS</span>        <span class="nx">ok</span>
        <span class="nx">MOVQ</span>        <span class="err">$</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">r1</span><span class="o">+</span><span class="mi">32</span><span class="p">(</span><span class="nx">FP</span><span class="p">)</span>
        <span class="nx">MOVQ</span>        <span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="nx">r2</span><span class="o">+</span><span class="mi">40</span><span class="p">(</span><span class="nx">FP</span><span class="p">)</span>
        <span class="nx">NEGQ</span>        <span class="nx">AX</span>
        <span class="nx">MOVQ</span>        <span class="nx">AX</span><span class="p">,</span> <span class="nx">err</span><span class="o">+</span><span class="mi">48</span><span class="p">(</span><span class="nx">FP</span><span class="p">)</span>
        <span class="nx">CALL</span>        <span class="nx">runtime</span><span class="err">·</span><span class="nf">exitsyscall</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>  <span class="c1">// 结束调用 exitsyscall()
</span><span class="c1"></span>        <span class="nx">RET</span>
<span class="nx">ok</span><span class="p">:</span>
        <span class="nx">MOVQ</span>        <span class="nx">AX</span><span class="p">,</span> <span class="nx">r1</span><span class="o">+</span><span class="mi">32</span><span class="p">(</span><span class="nx">FP</span><span class="p">)</span>
        <span class="nx">MOVQ</span>        <span class="nx">DX</span><span class="p">,</span> <span class="nx">r2</span><span class="o">+</span><span class="mi">40</span><span class="p">(</span><span class="nx">FP</span><span class="p">)</span>
        <span class="nx">MOVQ</span>        <span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="nx">err</span><span class="o">+</span><span class="mi">48</span><span class="p">(</span><span class="nx">FP</span><span class="p">)</span>
        <span class="nx">CALL</span>        <span class="nx">runtime</span><span class="err">·</span><span class="nf">exitsyscall</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span> <span class="c1">// 结束调用 exitsyscall()
</span><span class="c1"></span>        <span class="nx">RET</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>系统调用前，执行 <code>entersyscall()</code>；</li>
<li>执行系统调用；</li>
<li>系统调用后，执行 <code>exitsyscall()</code>；</li>
</ol>
<h4 id="441-系统调用前的准备">4.4.1 系统调用前的准备</h4>
<p><code>entersyscall()</code> 会调用 <code>reentersyscall()</code> 函数，执行进入系统调用前的准备工作：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">reentersyscall</span><span class="p">(</span><span class="nx">pc</span><span class="p">,</span> <span class="nx">sp</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
        <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span><span class="o">++</span>
        <span class="nx">_g_</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">stackPreempt</span>
        <span class="nx">_g_</span><span class="p">.</span><span class="nx">throwsplit</span> <span class="p">=</span> <span class="kc">true</span>

        <span class="nf">save</span><span class="p">(</span><span class="nx">pc</span><span class="p">,</span> <span class="nx">sp</span><span class="p">)</span>
        <span class="nx">_g_</span><span class="p">.</span><span class="nx">syscallsp</span> <span class="p">=</span> <span class="nx">sp</span>
        <span class="nx">_g_</span><span class="p">.</span><span class="nx">syscallpc</span> <span class="p">=</span> <span class="nx">pc</span>
        <span class="nf">casgstatus</span><span class="p">(</span><span class="nx">_g_</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Gsyscall</span><span class="p">)</span>

        <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">syscalltick</span> <span class="p">=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">syscalltick</span>
        <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">mcache</span> <span class="p">=</span> <span class="kc">nil</span>
        <span class="nx">pp</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
        <span class="nx">pp</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="mi">0</span>
        <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">oldp</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">pp</span><span class="p">)</span>
        <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="p">=</span> <span class="mi">0</span>
        <span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pp</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="nx">_Psyscall</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="nf">systemstack</span><span class="p">(</span><span class="nx">entersyscall_gcwait</span><span class="p">)</span>
                <span class="nf">save</span><span class="p">(</span><span class="nx">pc</span><span class="p">,</span> <span class="nx">sp</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span><span class="o">--</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>禁止线程上发生的抢占，防止出现内存不一致的问题；</li>
<li>保证当前函数不会触发栈分裂或者增长；</li>
<li>通过 <code>save()</code> 保存 PC、SP 值至 g.sched；</li>
<li>G 状态 _Grunning -&gt; _Gsyscall；</li>
<li><code>m.oldp</code> 设置为当前 P，<code>m.p</code> 设置为 0，这意味着记录但是解绑当前的 P，而 P 状态为 _Psyscall；</li>
</ol>
<p>这里比较重要的就是让 <strong>M 与 P 解绑，使得其他 M 可以获取到该 P 并执行 G</strong>。</p>
<p>因此，P 代表的是并发数，而不是线程数。</p>
<h4 id="442-系统调用后的恢复">4.4.2 系统调用后的恢复</h4>
<p>系统调用结束后，执行 <code>exitsyscall()</code> 进行恢复操作。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">exitsyscall</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

        <span class="c1">// M 尝试绑定阻塞前使用的 P，或者一个新的 P
</span><span class="c1"></span>        <span class="nx">oldp</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">oldp</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
        <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">oldp</span> <span class="p">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="nf">exitsyscallfast</span><span class="p">(</span><span class="nx">oldp</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">syscalltick</span><span class="o">++</span>
                <span class="nf">casgstatus</span><span class="p">(</span><span class="nx">_g_</span><span class="p">,</span> <span class="nx">_Gsyscall</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">)</span>
                <span class="o">...</span>

        <span class="k">return</span>
        <span class="p">}</span>

        <span class="c1">// M 解绑 G，重新进入调用循环
</span><span class="c1"></span>        <span class="nf">mcall</span><span class="p">(</span><span class="nx">exitsyscall0</span><span class="p">)</span>
        <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">syscalltick</span><span class="o">++</span>
        <span class="nx">_g_</span><span class="p">.</span><span class="nx">throwsplit</span> <span class="p">=</span> <span class="kc">false</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li><strong>M 尝试获取一个空闲的 P</strong>，从两个地方：
<ul>
<li>如果 <code>m.oldp</code> 还是为 _Psyscall 状态，说明没被人使用，那么记录使用阻塞前的 P；</li>
<li>从全局空闲 P <code>sched.pidle</code> 链表中获取一个 P；</li>
</ul>
</li>
<li>如果没有 P，那么确实 M 无法执行当前 G，就 <strong>M 解绑 G，将 G 放入全局队列</strong>；</li>
<li>无论如何，<strong>最后 M 都会调用 <code>schedule()</code> 重启进入调度循环</strong>，切换一个 G 执行。</li>
</ol>
<h3 id="45-抢占">4.5 抢占</h3>
<p>每个运行中的 G 会有一个运行的时间片，而 sysmon 会<strong>周期性检查部分 G，如果其执行时间大于 10ms，就会触发抢占</strong>。</p>
<p>抢占包括两种方式：</p>
<ul>
<li><strong><code>抢占标志</code></strong>：通过设置 <code>g.stackguard0=stackPreempt</code>。这必然会导致 G 执行下次函数调用时触发栈扩容逻辑，从而走到切换调度的逻辑；</li>
<li><strong><code>信号抢占</code></strong>（v1.14）：信号抢占会使得 M 线程触发信号中断，执行信号处理函数，从而重新进入调度循环。</li>
</ul>
<h4 id="451-触发抢占时机">4.5.1 触发抢占时机</h4>
<p>sysmon 会重启执行 <code>retake()</code> 函数，判断哪些正在运行的 G 是需要抢占的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">retake</span><span class="p">(</span><span class="nx">now</span> <span class="kt">int64</span><span class="p">)</span> <span class="kt">uint32</span> <span class="p">{</span>
        <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span>
        <span class="c1">// Prevent allp slice changes. This lock will be completely
</span><span class="c1"></span>        <span class="c1">// uncontended unless we&#39;re already stopping the world.
</span><span class="c1"></span>        <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allpLock</span><span class="p">)</span>
        
        <span class="c1">// 遍历所有 P
</span><span class="c1"></span>        <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">allp</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
                <span class="nx">_p_</span> <span class="o">:=</span> <span class="nx">allp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
                <span class="nx">pd</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">sysmontick</span>
                <span class="nx">s</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span>
                <span class="nx">sysretake</span> <span class="o">:=</span> <span class="kc">false</span>
                
                <span class="c1">// 允许抢占 _Prunning 与 _Psyscall 状态的 P
</span><span class="c1"></span>                <span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="nx">_Prunning</span> <span class="o">||</span> <span class="nx">s</span> <span class="o">==</span> <span class="nx">_Psyscall</span> <span class="p">{</span>
                        <span class="nx">t</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">schedtick</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">pd</span><span class="p">.</span><span class="nx">schedtick</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">t</span> <span class="p">{</span>
                                <span class="nx">pd</span><span class="p">.</span><span class="nx">schedtick</span> <span class="p">=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
                                <span class="nx">pd</span><span class="p">.</span><span class="nx">schedwhen</span> <span class="p">=</span> <span class="nx">now</span>
                        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">pd</span><span class="p">.</span><span class="nx">schedwhen</span><span class="o">+</span><span class="nx">forcePreemptNS</span> <span class="o">&lt;=</span> <span class="nx">now</span> <span class="p">{</span>
                                <span class="c1">// 到达抢占时间
</span><span class="c1"></span>                                <span class="nf">preemptone</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
                                <span class="c1">// In case of syscall, preemptone() doesn&#39;t
</span><span class="c1"></span>                                <span class="c1">// work, because there is no M wired to P.
</span><span class="c1"></span>                                <span class="nx">sysretake</span> <span class="p">=</span> <span class="kc">true</span>
                        <span class="p">}</span>
                <span class="p">}</span>
                
                <span class="c1">// 对于 _Psyscall，可以让其与 M 解绑，等其他的 M 绑定
</span><span class="c1"></span>                <span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="nx">_Psyscall</span> <span class="p">{</span>
                        <span class="nx">t</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">syscalltick</span><span class="p">)</span>
                        <span class="k">if</span> <span class="p">!</span><span class="nx">sysretake</span> <span class="o">&amp;&amp;</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">pd</span><span class="p">.</span><span class="nx">syscalltick</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">t</span> <span class="p">{</span>
                                <span class="nx">pd</span><span class="p">.</span><span class="nx">syscalltick</span> <span class="p">=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
                                <span class="nx">pd</span><span class="p">.</span><span class="nx">syscallwhen</span> <span class="p">=</span> <span class="nx">now</span>
                                <span class="k">continue</span>
                        <span class="p">}</span>
                        <span class="k">if</span> <span class="nf">runqempty</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">)</span><span class="o">+</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">npidle</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">pd</span><span class="p">.</span><span class="nx">syscallwhen</span><span class="o">+</span><span class="mi">10</span><span class="o">*</span><span class="mi">1000</span><span class="o">*</span><span class="mi">1000</span> <span class="p">&gt;</span> <span class="nx">now</span> <span class="p">{</span>
                                <span class="k">continue</span>
                        <span class="p">}</span>
                        <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allpLock</span><span class="p">)</span>
                        <span class="nf">incidlelocked</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">_Pidle</span><span class="p">)</span> <span class="p">{</span>
                                <span class="nx">n</span><span class="o">++</span>
                                <span class="nx">_p_</span><span class="p">.</span><span class="nx">syscalltick</span><span class="o">++</span>
                                <span class="nf">handoffp</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
                        <span class="p">}</span>
                        <span class="nf">incidlelocked</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                        <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allpLock</span><span class="p">)</span>
                <span class="p">}</span>
        <span class="p">}</span>
        <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allpLock</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>运行中的 G 运行超过 10ms，调用 <code>preemptone()</code> 进行抢占；</li>
<li>对于 _Psyscall 中的 P，将其解绑 M，使得其他 M 可以绑定该 P；</li>
</ol>
<h4 id="452-触发抢占">4.5.2 触发抢占</h4>
<p><code>preemptone()</code> 触发抢占，通过上面所述的两种方式。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">preemptone</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
        <span class="nx">mp</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
        <span class="nx">gp</span> <span class="o">:=</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">curg</span>
        <span class="nx">gp</span><span class="p">.</span><span class="nx">preempt</span> <span class="p">=</span> <span class="kc">true</span>

        <span class="c1">// 设置抢占标志
</span><span class="c1"></span>        <span class="c1">// Every call in a go routine checks for stack overflow by
</span><span class="c1"></span>        <span class="c1">// comparing the current stack pointer to gp-&gt;stackguard0.
</span><span class="c1"></span>        <span class="c1">// Setting gp-&gt;stackguard0 to StackPreempt folds
</span><span class="c1"></span>        <span class="c1">// preemption into the normal stack overflow check.
</span><span class="c1"></span>        <span class="nx">gp</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">stackPreempt</span>

        <span class="c1">// 信号抢占
</span><span class="c1"></span>        <span class="c1">// Request an async preemption of this P.
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">preemptMSupported</span> <span class="o">&amp;&amp;</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">asyncpreemptoff</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="nx">_p_</span><span class="p">.</span><span class="nx">preempt</span> <span class="p">=</span> <span class="kc">true</span>
                <span class="nf">preemptM</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li><strong>设置 G 的抢占标志，gp.stackguard0 = stackPreempt</strong>；</li>
<li><strong>执行 <code>preemptM()</code> 进行信号抢占</strong>；</li>
</ol>
<h4 id="453-通过抢占标志抢占">4.5.3 通过抢占标志抢占</h4>
<p>前面看到，设置 <code>gp.stackguard0 = stackPreempt</code>，而这在每次 G 函数调用前的检查是否扩容栈时，<strong>必然会触发 G 栈扩容逻辑</strong> <a href="../memory-manager/#33-%e6%a0%88%e7%9a%84%e6%89%a9%e5%ae%b9" rel=""><strong>newstack()</strong></a>。</p>
<p>而在 <a href="../memory-manager/#33-%e6%a0%88%e7%9a%84%e6%89%a9%e5%ae%b9" rel=""><strong>内存管理</strong></a> 时，介绍了 <code>newstack()</code> 如果扩容 G 的栈，但是省略了一个重要的逻辑分支：<strong><code>newstack()</code> 函数中还会进行 G 的调度</strong>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">newstack</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">thisg</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
        <span class="nx">gp</span> <span class="o">:=</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span>
        <span class="c1">// …
</span><span class="c1"></span>        <span class="nx">preempt</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Loaduintptr</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stackguard0</span><span class="p">)</span> <span class="o">==</span> <span class="nx">stackPreempt</span>
        <span class="c1">// 特殊情况下不能抢占时，继续走 G 代码逻辑
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">preempt</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">!</span><span class="nf">canPreemptM</span><span class="p">(</span><span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
                        <span class="c1">// Let the goroutine keep running for now.
</span><span class="c1"></span>                        <span class="c1">// gp-&gt;preempt is set, so it will be preempted next time.
</span><span class="c1"></span>                        <span class="nx">gp</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">+</span> <span class="nx">_StackGuard</span>
                        <span class="nf">gogo</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">)</span> <span class="c1">// never return
</span><span class="c1"></span>                <span class="p">}</span>
        
        <span class="c1">// …
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">preempt</span> <span class="p">{</span>
                <span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">g0</span> <span class="p">{</span>
                        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: preempt g0&#34;</span><span class="p">)</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: g is running but p is not&#34;</span><span class="p">)</span>
                <span class="p">}</span>

        <span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">preemptShrink</span> <span class="p">{</span>
                <span class="c1">// We&#39;re at a synchronous safe point now, so
</span><span class="c1"></span>                <span class="c1">// do the pending stack shrink.
</span><span class="c1"></span>                <span class="nx">gp</span><span class="p">.</span><span class="nx">preemptShrink</span> <span class="p">=</span> <span class="kc">false</span>
                <span class="nf">shrinkstack</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">preemptStop</span> <span class="p">{</span>
                <span class="nf">preemptPark</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span> <span class="c1">// never returns
</span><span class="c1"></span>        <span class="p">}</span>

        <span class="c1">// Act like goroutine called runtime.Gosched.
</span><span class="c1"></span>        <span class="nf">gopreempt_m</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span> <span class="c1">// never return
</span><span class="c1"></span>        <span class="p">}</span>
        <span class="c1">// …
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">gopreempt_m</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 老朋友了
</span><span class="c1"></span>        <span class="nf">goschedImpl</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>判断到 <code>gp.stackguard0 = stackPreempt</code> 后，无论如何都会走重新调度的逻辑，M 重新进入调度循环。</p>
<h4 id="454-信号抢占">4.5.4 信号抢占</h4>
<p>执行 <code>preemptM()</code> 会对 M 进行信号抢占，<strong>通过发送 SIGURG 信号触发 M 线程的信号处理函数</strong>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="nx">sigPreempt</span> <span class="p">=</span> <span class="nx">_SIGURG</span>

<span class="kd">func</span> <span class="nf">preemptM</span><span class="p">(</span><span class="nx">mp</span> <span class="o">*</span><span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;darwin&#34;</span> <span class="o">&amp;&amp;</span> <span class="nx">GOARCH</span> <span class="o">==</span> <span class="s">&#34;arm64&#34;</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">iscgo</span> <span class="p">{</span>
                <span class="k">return</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mp</span><span class="p">.</span><span class="nx">signalPending</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;darwin&#34;</span> <span class="p">{</span>
                        <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pendingPreemptSignals</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="p">}</span>

        <span class="c1">// If multiple threads are preempting the same M, it may send many
</span><span class="c1"></span>        <span class="c1">// signals to the same M such that it hardly make progress, causing
</span><span class="c1"></span>        <span class="c1">// live-lock problem. Apparently this could happen on darwin. See
</span><span class="c1"></span>        <span class="c1">// issue #37741.
</span><span class="c1"></span>        <span class="c1">// Only send a signal if there isn&#39;t already one pending.
</span><span class="c1"></span>        <span class="nf">signalM</span><span class="p">(</span><span class="nx">mp</span><span class="p">,</span> <span class="nx">sigPreempt</span><span class="p">)</span>
        <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>M 会执行信号处理函数 <code>asyncPreempt()</code>，最后调用到 <code>asyncPreempt2()</code>，使得 M 进入重新调度：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// asyncPreempt saves all user registers and calls asyncPreempt2.
</span><span class="c1">//
</span><span class="c1">// When stack scanning encounters an asyncPreempt frame, it scans that
</span><span class="c1">// frame and its parent frame conservatively.
</span><span class="c1">//
</span><span class="c1">// asyncPreempt is implemented in assembly.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">asyncPreempt</span><span class="p">()</span>

<span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">asyncPreempt2</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">asyncSafePoint</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">preemptStop</span> <span class="p">{</span>
		<span class="nf">mcall</span><span class="p">(</span><span class="nx">preemptPark</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nf">mcall</span><span class="p">(</span><span class="nx">gopreempt_m</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">asyncSafePoint</span> <span class="p">=</span> <span class="kc">false</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>无论是走 <code>preemptPark()</code> 还是 <code>gopreempt_m()</code>，最后都会使得 <strong>M 解绑当前 G，执行 <code>schedule()</code>，开始调度循环</strong>。</p>
<div class="details admonition tip open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-lightbulb fa-fw" aria-hidden="true"></i>处理信号的时机<i class="details-icon fas fa-angle-right fa-fw" aria-hidden="true"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><p><strong>信号处理不是及时的</strong>，内核会把信号记录在进程（线程）的 pending 队列上，然后触发软中断将进程变为 running 状态。</p>
<p>当进程被唤醒或者被内核调度得到 CPU 后，从内核态返回用户态时，会检查 pending 队列的信号，并执行信号处理函数。</p>
</div>
        </div>
    </div>
<h2 id="总结">总结</h2>
<p>相对于 <a href="../memory-manager/" rel=""><strong>内存管理</strong></a> 与 <a href="../garbage-collection/" rel=""><strong>垃圾收集</strong></a>，竟然感觉并发调度的结构还算简单。</p>
<p>需要弄清楚的有以下几点：</p>
<ul>
<li><a href="#11-%e8%bf%9b%e7%a8%8b%e7%ba%bf%e7%a8%8b%e4%b8%8e%e5%8d%8f%e7%a8%8b" rel=""><strong>协程出现的意义</strong></a></li>
<li><a href="#12-%e8%b0%83%e5%ba%a6%e5%99%a8" rel=""><strong>调度器的工作</strong></a></li>
<li><a href="#2-gmp-%e6%a8%a1%e5%9e%8b" rel=""><strong>GMP 模型整体框架</strong></a></li>
<li><a href="#2-gmp-%e6%a8%a1%e5%9e%8b" rel=""><strong>G、M、P 代表的意义</strong></a></li>
<li>调度循环的流程
<ul>
<li><a href="#31-schedule" rel=""><strong>进入调度循环 M 的行为</strong></a></li>
<li><a href="#311-fundrunnable" rel=""><strong>找寻 G 的各个途径</strong></a></li>
<li><a href="#32-execute" rel=""><strong>M 执行 G 时，如何切换上下文</strong></a></li>
<li><a href="#32-execute" rel=""><strong>如何退出回到调度循环</strong></a></li>
</ul>
</li>
<li>调度切换
<ul>
<li><a href="#41-%e5%88%87%e6%8d%a2%e6%97%b6%e6%9c%ba" rel=""><strong>切换的各个时机</strong></a></li>
<li><a href="#44-%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8" rel=""><strong>系统调用进行调度切换的行为</strong></a></li>
<li><a href="#45-%e6%8a%a2%e5%8d%a0" rel=""><strong>抢占的两种方式</strong></a></li>
</ul>
</li>
</ul>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://github.com/qyuhen/book" target="_blank" rel="noopener noreffer">《Golang 学习笔记》</a></li>
<li><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/" target="_blank" rel="noopener noreffer">《Golang 设计与实现》：调度器</a></li>
</ul>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2022-12-29&nbsp;<a class="git-hash" href="https://github.com/KanShiori/KanShiori.github.io/commit/d3ea9b7ffc6994602f6a00bc9c32886eb1eb85f0" target="_blank" title="commit by Shiori(yshshihaoren@qq.com) d3ea9b7ffc6994602f6a00bc9c32886eb1eb85f0: Post(Scheduler Implement) (#28)">
                                    <i class="fas fa-hashtag fa-fw" aria-hidden="true"></i>d3ea9b7</a></span>
            </div></div>
        <div class="post-info-line">
            <div class="post-info-md"><span>
                            <a class="link-to-markdown" href="/posts/language/golang/language/goroutine/index.md" target="_blank">阅读原始文档</a>
                        </span></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="分享到 Twitter" data-sharer="twitter" data-url="https://KanShiori.github.io/posts/language/golang/language/goroutine/" data-title="Go 并发调度总结" data-hashtags="Golang,Golang 原理"><i class="fab fa-twitter fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 Facebook" data-sharer="facebook" data-url="https://KanShiori.github.io/posts/language/golang/language/goroutine/" data-hashtag="Golang"><i class="fab fa-facebook-square fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 Hacker News" data-sharer="hackernews" data-url="https://KanShiori.github.io/posts/language/golang/language/goroutine/" data-title="Go 并发调度总结"><i class="fab fa-hacker-news fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 Line" data-sharer="line" data-url="https://KanShiori.github.io/posts/language/golang/language/goroutine/" data-title="Go 并发调度总结"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@6.20.0/icons/line.svg" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="https://KanShiori.github.io/posts/language/golang/language/goroutine/" data-title="Go 并发调度总结"><i class="fab fa-weibo fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 百度" data-sharer="baidu" data-url="https://KanShiori.github.io/posts/language/golang/language/goroutine/" data-title="Go 并发调度总结"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@6.20.0/icons/baidu.svg" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 Evernote" data-sharer="evernote" data-url="https://KanShiori.github.io/posts/language/golang/language/goroutine/" data-title="Go 并发调度总结"><i class="fab fa-evernote fa-fw" aria-hidden="true"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;<a href="/tags/golang/">Golang</a>,&nbsp;<a href="/tags/golang-%E5%8E%9F%E7%90%86/">Golang 原理</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/language/golang/language/garbage-collection/" class="prev" rel="prev" title="Go 垃圾收集总结"><i class="fas fa-angle-left fa-fw" aria-hidden="true"></i>Go 垃圾收集总结</a>
            <a href="/posts/linux/net/linux-%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91%E5%8C%85%E8%BF%87%E7%A8%8B%E6%80%BB%E7%BB%93/" class="next" rel="next" title="Linux 网络收发包过程总结">Linux 网络收发包过程总结<i class="fas fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
</article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><i class="far fa-copyright fa-fw" aria-hidden="true"></i><span itemprop="copyrightYear">2020 - 2022</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank">Shiori</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw" aria-hidden="true"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw" aria-hidden="true"></i>
            </a>
        </div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/algoliasearch@4.13.0/dist/algoliasearch-lite.umd.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.1/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":35},"comment":{},"search":{"algoliaAppID":"9NJS0VQU0I","algoliaIndex":"blog","algoliaSearchKey":"85d62ea65a7f7445fbfb413bdca088f2","highlightTag":"em","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"algolia"}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
